Disassembly Listing for blink
Generated From:
C:/Users/LarsErik/MPLABXProjects/blink.X/dist/default/debug/blink.X.debug.elf
15.mar.2018 21:12:36

---  C:/Users/LarsErik/MPLABXProjects/blink.X/mcc_generated_files/usb/usb_device_events.c  --------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /** INCLUDES *******************************************************/
23:            #include <stdbool.h>
24:            #include <stdint.h>
25:            #include "usb_device.h"
26:            #include "usb_device_cdc.h"
27:            
28:            /*******************************************************************
29:             * Function:        bool USER_USB_CALLBACK_EVENT_HANDLER(
30:             *                        USB_EVENT event, void *pdata, uint16_t size)
31:             *
32:             * PreCondition:    None
33:             *
34:             * Input:           USB_EVENT event - the type of event
35:             *                  void *pdata - pointer to the event data
36:             *                  uint16_t size - size of the event data
37:             *
38:             * Output:          None
39:             *
40:             * Side Effects:    None
41:             *
42:             * Overview:        This function is called from the USB stack to
43:             *                  notify a user application that a USB event
44:             *                  occured.  This callback is in interrupt context
45:             *                  when the USB_INTERRUPT option is selected.
46:             *
47:             * Note:            None
48:             *******************************************************************/
49:            bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size)
50:            {
51:                switch( (int) event )
1205  2A0C     GOTO 0x20C
120C  0020     MOVLB 0x0
120D  0861     MOVF 0x61, W
120E  3A00     XORLW 0x0
120F  1903     BTFSC STATUS, 0x2
1210  2A15     GOTO 0x215
1211  3A7F     XORLW 0x7F
1212  1903     BTFSC STATUS, 0x2
1213  2A2F     GOTO 0x22F
1214  2A34     GOTO 0x234
1215  0860     MOVF __pcstackBANK0h, W
1216  3A01     XORLW 0x1
1217  1903     BTFSC STATUS, 0x2
1218  2A06     GOTO 0x206
1219  3A03     XORLW 0x3
121A  1903     BTFSC STATUS, 0x2
121B  2A34     GOTO 0x234
121C  3A01     XORLW 0x1
121D  1903     BTFSC STATUS, 0x2
121E  2A09     GOTO 0x209
121F  3A06     XORLW 0x6
1220  1903     BTFSC STATUS, 0x2
1221  2A34     GOTO 0x234
1222  3A77     XORLW 0x77
1223  1903     BTFSC STATUS, 0x2
1224  2A34     GOTO 0x234
1225  3A01     XORLW 0x1
1226  1903     BTFSC STATUS, 0x2
1227  2A34     GOTO 0x234
1228  3A07     XORLW 0x7
1229  1903     BTFSC STATUS, 0x2
122A  2A34     GOTO 0x234
122B  3A01     XORLW 0x1
122C  1903     BTFSC STATUS, 0x2
122D  2A34     GOTO 0x234
122E  2A34     GOTO 0x234
122F  0860     MOVF __pcstackBANK0h, W
1230  3AFF     XORLW 0xFF
1231  1903     BTFSC STATUS, 0x2
1232  2A34     GOTO 0x234
1233  2A34     GOTO 0x234
1235  2A3C     GOTO 0x23C
123C  0021     MOVLB 0x1
123D  0835     MOVF 0xB5, W
123E  3A00     XORLW 0x0
123F  1903     BTFSC 0x83, 0x2
1240  2A45     GOTO 0x245
1241  3A7F     XORLW 0x7F
1242  1903     BTFSC 0x83, 0x2
1243  2A5F     GOTO 0x25F
1244  2A64     GOTO 0x264
1245  0834     MOVF event, W
1246  3A01     XORLW 0x1
1247  1903     BTFSC 0x83, 0x2
1248  2A36     GOTO 0x236
1249  3A03     XORLW 0x3
124A  1903     BTFSC 0x83, 0x2
124B  2A64     GOTO 0x264
124C  3A01     XORLW 0x1
124D  1903     BTFSC 0x83, 0x2
124E  2A39     GOTO 0x239
124F  3A06     XORLW 0x6
1250  1903     BTFSC 0x83, 0x2
1251  2A64     GOTO 0x264
1252  3A77     XORLW 0x77
1253  1903     BTFSC 0x83, 0x2
1254  2A64     GOTO 0x264
1255  3A01     XORLW 0x1
1256  1903     BTFSC 0x83, 0x2
1257  2A64     GOTO 0x264
1258  3A07     XORLW 0x7
1259  1903     BTFSC 0x83, 0x2
125A  2A64     GOTO 0x264
125B  3A01     XORLW 0x1
125C  1903     BTFSC 0x83, 0x2
125D  2A64     GOTO 0x264
125E  2A64     GOTO 0x264
125F  0834     MOVF event, W
1260  3AFF     XORLW 0xFF
1261  1903     BTFSC 0x83, 0x2
1262  2A64     GOTO 0x264
1263  2A64     GOTO 0x264
52:                {
53:                    case EVENT_TRANSFER:
54:                        break;
55:            
56:                    case EVENT_SOF:
57:                        break;
58:            
59:                    case EVENT_SUSPEND:
60:                        //Call the hardware platform specific handler for suspend events for
61:                        //possible further action (like optionally going reconfiguring the application
62:                        //for lower power states and going to sleep during the suspend event).  This
63:                        //would normally be done in USB compliant bus powered applications, although
64:                        //no further processing is needed for purely self powered applications that
65:                        //don't consume power from the host.
66:                        break;
67:            
68:                    case EVENT_RESUME:
69:                        //Call the hardware platform specific resume from suspend handler (ex: to
70:                        //restore I/O pins to higher power states if they were changed during the 
71:                        //preceding SYSTEM_Initialize(SYSTEM_STATE_USB_SUSPEND) call at the start
72:                        //of the suspend condition.
73:                        break;
74:            
75:                    case EVENT_CONFIGURED:
76:                        CDCInitEP();
1206  3192     MOVLP 0x12
1207  229B     CALL 0x29B
1236  3193     MOVLP 0x13
1237  2307     CALL 0x307
77:                        break;
78:            
79:                    case EVENT_SET_DESCRIPTOR:
80:                        break;
1208  0008     RETURN
1238  0008     RETURN
81:            
82:                    case EVENT_EP0_REQUEST:
83:                        /* We have received a non-standard USB request.  The CDC driver
84:                         * needs to check to see if the request was for it. */
85:                        USBCheckCDCRequest();
1209  3197     MOVLP 0x17
120A  273F     CALL 0x73F
1239  3188     MOVLP 0x8
123A  2088     CALL 0x88
86:                        break;
87:            
88:                    case EVENT_BUS_ERROR:
89:                        break;
90:            
91:                    case EVENT_TRANSFER_TERMINATED:
92:                        break;
93:            
94:                    default:
95:                        break;
96:                }
120B  0008     RETURN
123B  0008     RETURN
97:                return true;
98:            }
1234  0008     RETURN
1264  0008     RETURN
99:            
---  C:/Users/LarsErik/MPLABXProjects/blink.X/mcc_generated_files/usb/usb_device_cdc.c  -----------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /********************************************************************
23:             Change History:
24:              Rev    Description
25:              ----   -----------
26:              2.3    Deprecated the mUSBUSARTIsTxTrfReady() macro.  It is 
27:                     replaced by the USBUSARTIsTxTrfReady() function.
28:            
29:              2.6    Minor definition changes
30:            
31:              2.6a   No Changes
32:            
33:              2.7    Fixed error in the part support list of the variables section
34:                     where the address of the CDC variables are defined.  The 
35:                     PIC18F2553 was incorrectly named PIC18F2453 and the PIC18F4558
36:                     was incorrectly named PIC18F4458.
37:            
38:                     http://www.microchip.com/forums/fb.aspx?m=487397
39:            
40:              2.8    Minor change to CDCInitEP() to enhance ruggedness in
41:                     multi0-threaded usage scenarios.
42:              
43:              2.9b   Updated to implement optional support for DTS reporting.
44:            
45:            ********************************************************************/
46:            
47:            /** I N C L U D E S **********************************************************/
48:            #include "usb.h"
49:            #include "usb_device_cdc.h"
50:            
51:            #ifdef USB_USE_CDC
52:            
53:            #ifndef FIXED_ADDRESS_MEMORY
54:                #define IN_DATA_BUFFER_ADDRESS_TAG
55:                #define OUT_DATA_BUFFER_ADDRESS_TAG
56:                #define CONTROL_BUFFER_ADDRESS_TAG
57:            #endif
58:            
59:            #if !defined(IN_DATA_BUFFER_ADDRESS_TAG) || !defined(OUT_DATA_BUFFER_ADDRESS_TAG) || !defined(CONTROL_BUFFER_ADDRESS_TAG)
60:                #error "One of the fixed memory address definitions is not defined.  Please define the required address tags for the required buffers."
61:            #endif
62:            
63:            /** V A R I A B L E S ********************************************************/
64:            volatile unsigned char cdc_data_tx[CDC_DATA_IN_EP_SIZE] IN_DATA_BUFFER_ADDRESS_TAG;
65:            volatile unsigned char cdc_data_rx[CDC_DATA_OUT_EP_SIZE] OUT_DATA_BUFFER_ADDRESS_TAG;
66:            
67:            typedef union
68:            {
69:                LINE_CODING lineCoding;
70:                CDC_NOTICE cdcNotice;
71:            } CONTROL_BUFFER;
72:            
73:            //static CONTROL_BUFFER controlBuffer CONTROL_BUFFER_ADDRESS_TAG;
74:            
75:            LINE_CODING line_coding;    // Buffer to store line coding information
76:            CDC_NOTICE cdc_notice;
77:            
78:            #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
79:                SERIAL_STATE_NOTIFICATION SerialStatePacket;
80:            #endif
81:            
82:            uint8_t cdc_rx_len;            // total rx length
83:            uint8_t cdc_trf_state;         // States are defined cdc.h
84:            POINTER pCDCSrc;            // Dedicated source pointer
85:            POINTER pCDCDst;            // Dedicated destination pointer
86:            uint8_t cdc_tx_len;            // total tx length
87:            uint8_t cdc_mem_type;          // _ROM, _RAM
88:            
89:            USB_HANDLE CDCDataOutHandle;
90:            USB_HANDLE CDCDataInHandle;
91:            
92:            
93:            CONTROL_SIGNAL_BITMAP control_signal_bitmap;
94:            uint32_t BaudRateGen;			// BRG value calculated from baud rate
95:            
96:            #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
97:                BM_SERIAL_STATE SerialStateBitmap;
98:                BM_SERIAL_STATE OldSerialStateBitmap;
99:                USB_HANDLE CDCNotificationInHandle;
100:           #endif
101:           
102:           /**************************************************************************
103:             SEND_ENCAPSULATED_COMMAND and GET_ENCAPSULATED_RESPONSE are required
104:             requests according to the CDC specification.
105:             However, it is not really being used here, therefore a dummy buffer is
106:             used for conformance.
107:            **************************************************************************/
108:           #define dummy_length    0x08
109:           uint8_t dummy_encapsulated_cmd_response[dummy_length];
110:           
111:           #if defined(USB_CDC_SET_LINE_CODING_HANDLER)
112:           CTRL_TRF_RETURN USB_CDC_SET_LINE_CODING_HANDLER(CTRL_TRF_PARAMS);
113:           #endif
114:           
115:           /** P R I V A T E  P R O T O T Y P E S ***************************************/
116:           void USBCDCSetLineCoding(void);
117:           
118:           /** D E C L A R A T I O N S **************************************************/
119:           //#pragma code
120:           
121:           /** C L A S S  S P E C I F I C  R E Q ****************************************/
122:           /******************************************************************************
123:            	Function:
124:            		void USBCheckCDCRequest(void)
125:            
126:            	Description:
127:            		This routine checks the most recently received SETUP data packet to 
128:            		see if the request is specific to the CDC class.  If the request was
129:            		a CDC specific request, this function will take care of handling the
130:            		request and responding appropriately.
131:            		
132:            	PreCondition:
133:            		This function should only be called after a control transfer SETUP
134:            		packet has arrived from the host.
135:           
136:           	Parameters:
137:           		None
138:           		
139:           	Return Values:
140:           		None
141:           		
142:           	Remarks:
143:           		This function does not change status or do anything if the SETUP packet
144:           		did not contain a CDC class specific request.		 
145:             *****************************************************************************/
146:           void USBCheckCDCRequest(void)
147:           {
148:               /*
149:                * If request recipient is not an interface then return
150:                */
151:               if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD) return;
0888  0020     MOVLB 0x0
0889  0850     MOVF SetupPkt, W
088A  391F     ANDLW 0x1F
088B  3A01     XORLW 0x1
088C  1D03     BTFSS STATUS, 0x2
088D  0008     RETURN
173F  0020     MOVLB 0x0
152:           
153:               /*
154:                * If request type is not class-specific then return
155:                */
156:               if(SetupPkt.RequestType != USB_SETUP_TYPE_CLASS_BITFIELD) return;
088E  0E50     SWAPF SetupPkt, W
088F  0C89     RRF WREG, F
0890  3903     ANDLW 0x3
0891  3A01     XORLW 0x1
0892  1D03     BTFSS STATUS, 0x2
0893  0008     RETURN
1745  0E50     SWAPF SetupPkt, W
1746  0C89     RRF WREG, F
1747  3903     ANDLW 0x3
1748  3A01     XORLW 0x1
1749  1D03     BTFSS STATUS, 0x2
174A  0008     RETURN
157:           
158:               /*
159:                * Interface ID must match interface numbers associated with
160:                * CDC class, else return
161:                */
162:               if((SetupPkt.bIntfID != CDC_COMM_INTF_ID)&&
163:                  (SetupPkt.bIntfID != CDC_DATA_INTF_ID)) return;
0894  0854     MOVF 0x54, W
0895  1903     BTFSC STATUS, 0x2
0896  28D8     GOTO 0xD8
0897  0354     DECF 0x54, W
0898  1D03     BTFSS STATUS, 0x2
0899  0008     RETURN
089A  28D8     GOTO 0xD8
174B  0854     MOVF 0x54, W
174C  1903     BTFSC STATUS, 0x2
174D  2F8C     GOTO 0x78C
174E  0354     DECF 0x54, W
174F  1D03     BTFSS STATUS, 0x2
1750  0008     RETURN
1751  2F8C     GOTO 0x78C
164:               
165:               switch(SetupPkt.bRequest)
08D8  0020     MOVLB 0x0
08D9  0851     MOVF 0x51, W
08DA  3A00     XORLW 0x0
08DB  1903     BTFSC STATUS, 0x2
08DC  289B     GOTO 0x9B
08DD  3A01     XORLW 0x1
08DE  1903     BTFSC STATUS, 0x2
08DF  28A7     GOTO 0xA7
08E0  3A21     XORLW 0x21
08E1  1903     BTFSC STATUS, 0x2
08E2  28AE     GOTO 0xAE
08E3  3A01     XORLW 0x1
08E4  1903     BTFSC STATUS, 0x2
08E5  28C0     GOTO 0xC0
08E6  3A03     XORLW 0x3
08E7  1903     BTFSC STATUS, 0x2
08E8  28CE     GOTO 0xCE
08E9  28EA     GOTO 0xEA
178C  0020     MOVLB 0x0
178D  0851     MOVF 0x51, W
178E  3A00     XORLW 0x0
178F  1903     BTFSC STATUS, 0x2
1790  2F52     GOTO 0x752
1791  3A01     XORLW 0x1
1792  1903     BTFSC STATUS, 0x2
1793  2F5E     GOTO 0x75E
1794  3A21     XORLW 0x21
1795  1903     BTFSC STATUS, 0x2
1796  2F65     GOTO 0x765
1797  3A01     XORLW 0x1
1798  1903     BTFSC STATUS, 0x2
1799  2F75     GOTO 0x775
179A  3A03     XORLW 0x3
179B  1903     BTFSC STATUS, 0x2
179C  2F83     GOTO 0x783
179D  2F9E     GOTO 0x79E
166:               {
167:                   //****** These commands are required ******//
168:                   case SEND_ENCAPSULATED_COMMAND:
169:                    //send the packet
170:                       inPipes[0].pSrc.bRam = (uint8_t*)&dummy_encapsulated_cmd_response;
089B  302E     MOVLW 0x2E
089C  0021     MOVLB 0x1
089D  00C3     MOVWF inPipes
089E  3002     MOVLW 0x2
089F  00C4     MOVWF 0xC4
1752  302E     MOVLW 0x2E
1753  0021     MOVLB 0x1
1754  00C3     MOVWF inPipes
1755  3002     MOVLW 0x2
1756  00C4     MOVWF 0xC4
171:                       inPipes[0].wCount.Val = dummy_length;
08A0  3000     MOVLW 0x0
08A1  00C7     MOVWF 0xC7
08A2  3008     MOVLW 0x8
08A3  00C6     MOVWF 0xC6
1757  3000     MOVLW 0x0
1758  00C7     MOVWF 0xC7
1759  3008     MOVLW 0x8
175A  00C6     MOVWF 0xC6
172:                       inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;
08A4  1445     BSF 0xC5, 0x0
175B  1445     BSF 0xC5, 0x0
173:                       inPipes[0].info.bits.busy = 1;
08A5  17C5     BSF 0xC5, 0x7
175C  17C5     BSF 0xC5, 0x7
174:                       break;
08A6  0008     RETURN
175D  0008     RETURN
175:                   case GET_ENCAPSULATED_RESPONSE:
176:                       // Populate dummy_encapsulated_cmd_response first.
177:                       inPipes[0].pSrc.bRam = (uint8_t*)&dummy_encapsulated_cmd_response;
08A7  302E     MOVLW 0x2E
08A8  0021     MOVLB 0x1
08A9  00C3     MOVWF inPipes
08AA  3002     MOVLW 0x2
08AB  00C4     MOVWF 0xC4
175E  302E     MOVLW 0x2E
175F  0021     MOVLB 0x1
1760  00C3     MOVWF inPipes
1761  3002     MOVLW 0x2
1762  00C4     MOVWF 0xC4
178:                       inPipes[0].info.bits.busy = 1;
08AC  17C5     BSF 0xC5, 0x7
1763  17C5     BSF 0xC5, 0x7
179:                       break;
08AD  0008     RETURN
1764  0008     RETURN
180:                   //****** End of required commands ******//
181:           
182:                   #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D1)
183:                   case SET_LINE_CODING:
184:                       outPipes[0].wCount.Val = SetupPkt.wLength;
08AE  0020     MOVLB 0x0
08AF  0857     MOVF 0x57, W
08B0  0023     MOVLB 0x3
08B1  00B4     MOVWF 0x1B4
08B2  0020     MOVLB 0x0
08B3  0856     MOVF 0x56, W
08B4  0023     MOVLB 0x3
08B5  00B3     MOVWF 0x1B3
1765  0020     MOVLB 0x0
1766  0857     MOVF 0x57, W
1767  0023     MOVLB 0x3
1768  00B4     MOVWF 0x1B4
1769  0020     MOVLB 0x0
176A  0856     MOVF 0x56, W
176B  0023     MOVLB 0x3
176C  00B3     MOVWF 0x1B3
185:                       outPipes[0].pDst.bRam = (uint8_t*)LINE_CODING_TARGET;
08B6  3036     MOVLW 0x36
08B7  0021     MOVLB 0x1
08B8  00A6     MOVWF length
08B9  0826     MOVF length, W
08BA  0023     MOVLB 0x3
08BB  00B0     MOVWF outPipes
176D  3036     MOVLW 0x36
176E  00F0     MOVWF 0x1F0
176F  0870     MOVF 0x1F0, W
1770  00B0     MOVWF outPipes
186:                       outPipes[0].pFunc = LINE_CODING_PFUNC;
08BC  01B5     CLRF 0x1B5
08BD  01B6     CLRF 0x1B6
1771  01B5     CLRF 0x1B5
1772  01B6     CLRF 0x1B6
187:                       outPipes[0].info.bits.busy = 1;
08BE  17B2     BSF 0x1B2, 0x7
1773  17B2     BSF 0x1B2, 0x7
188:                       break;
08BF  0008     RETURN
1774  0008     RETURN
189:                       
190:                   case GET_LINE_CODING:
191:                       USBEP0SendRAMPtr(
08C0  3036     MOVLW 0x36
08C1  0021     MOVLB 0x1
08C2  00C3     MOVWF inPipes
08C3  3002     MOVLW 0x2
08C4  00C4     MOVWF 0xC4
08C5  3000     MOVLW 0x0
08C6  00C7     MOVWF 0xC7
08C7  3007     MOVLW 0x7
08C8  00C6     MOVWF 0xC6
08C9  30C1     MOVLW 0xC1
08CA  00A6     MOVWF length
08CB  0826     MOVF length, W
08CC  00C5     MOVWF 0xC5
1775  3036     MOVLW 0x36
1776  0021     MOVLB 0x1
1777  00C3     MOVWF inPipes
1778  3002     MOVLW 0x2
1779  00C4     MOVWF 0xC4
177A  3000     MOVLW 0x0
177B  00C7     MOVWF 0xC7
177C  3007     MOVLW 0x7
177D  00C6     MOVWF 0xC6
177E  30C1     MOVLW 0xC1
177F  00F0     MOVWF 0xF0
1780  0870     MOVF 0xF0, W
1781  00C5     MOVWF 0xC5
192:                           (uint8_t*)&line_coding,
193:                           LINE_CODING_LENGTH,
194:                           USB_EP0_INCLUDE_ZERO);
195:                       break;
08CD  0008     RETURN
1782  0008     RETURN
196:           
197:                   case SET_CONTROL_LINE_STATE:
198:                       control_signal_bitmap._byte = (uint8_t)SetupPkt.wValue;
08CE  0020     MOVLB 0x0
08CF  0852     MOVF 0x52, W
08D0  0021     MOVLB 0x1
08D1  00A6     MOVWF length
08D2  0826     MOVF length, W
08D3  0023     MOVLB 0x3
08D4  00E6     MOVWF control_signal_bitmap
1783  0020     MOVLB 0x0
1784  0852     MOVF 0x52, W
1785  00F0     MOVWF __pcstackCOMMON
1786  0870     MOVF __pcstackCOMMON, W
1787  0023     MOVLB 0x3
1788  00E6     MOVWF control_signal_bitmap
199:                       //------------------------------------------------------------------            
200:                       //One way to control the RTS pin is to allow the USB host to decide the value
201:                       //that should be output on the RTS pin.  Although RTS and CTS pin functions
202:                       //are technically intended for UART hardware based flow control, some legacy
203:                       //UART devices use the RTS pin like a "general purpose" output pin 
204:                       //from the PC host.  In this usage model, the RTS pin is not related
205:                       //to flow control for RX/TX.
206:                       //In this scenario, the USB host would want to be able to control the RTS
207:                       //pin, and the below line of code should be uncommented.
208:                       //However, if the intention is to implement true RTS/CTS flow control
209:                       //for the RX/TX pair, then this application firmware should override
210:                       //the USB host's setting for RTS, and instead generate a real RTS signal,
211:                       //based on the amount of remaining buffer space available for the 
212:                       //actual hardware UART of this microcontroller.  In this case, the 
213:                       //below code should be left commented out, but instead RTS should be 
214:                       //controlled in the application firmware responsible for operating the 
215:                       //hardware UART of this microcontroller.
216:                       //---------            
217:                       //CONFIGURE_RTS(control_signal_bitmap.CARRIER_CONTROL);  
218:                       //------------------------------------------------------------------            
219:                       
220:                       #if defined(USB_CDC_SUPPORT_DTR_SIGNALING)
221:                           if(control_signal_bitmap.DTE_PRESENT == 1)
222:                           {
223:                               UART_DTR = USB_CDC_DTR_ACTIVE_LEVEL;
224:                           }
225:                           else
226:                           {
227:                               UART_DTR = (USB_CDC_DTR_ACTIVE_LEVEL ^ 1);
228:                           }        
229:                       #endif
230:                       inPipes[0].info.bits.busy = 1;
08D5  0021     MOVLB 0x1
08D6  17C5     BSF 0xC5, 0x7
1789  0021     MOVLB 0x1
178A  17C5     BSF 0xC5, 0x7
231:                       break;
232:                   #endif
233:           
234:                   #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D2)
235:                   case SEND_BREAK:                        // Optional
236:                       inPipes[0].info.bits.busy = 1;
237:           			if (SetupPkt.wValue == 0xFFFF)  //0xFFFF means send break indefinitely until a new SEND_BREAK command is received
238:           			{
239:           				UART_Tx = 0;       // Prepare to drive TX low (for break signaling)
240:           				UART_TRISTx = 0;   // Make sure TX pin configured as an output
241:           				UART_ENABLE = 0;   // Turn off USART (to relinquish TX pin control)
242:           			}
243:           			else if (SetupPkt.wValue == 0x0000) //0x0000 means stop sending indefinite break 
244:           			{
245:               			UART_ENABLE = 1;   // turn on USART
246:           				UART_TRISTx = 1;   // Make TX pin an input
247:           			}
248:           			else
249:           			{
250:                           //Send break signaling on the pin for (SetupPkt.wValue) milliseconds
251:                           UART_SEND_BREAK();
252:           			}
253:                       break;
254:                   #endif
255:                   default:
256:                       break;
257:               }//end switch(SetupPkt.bRequest)
08D7  0008     RETURN
178B  0008     RETURN
258:           
259:           }//end USBCheckCDCRequest
08EA  0008     RETURN
179E  0008     RETURN
260:           
261:           /** U S E R  A P I ***********************************************************/
262:           
263:           /**************************************************************************
264:             Function:
265:                   void CDCInitEP(void)
266:               
267:             Summary:
268:               This function initializes the CDC function driver. This function should
269:               be called after the SET_CONFIGURATION command (ex: within the context of
270:               the USBCBInitEP() function).
271:             Description:
272:               This function initializes the CDC function driver. This function sets
273:               the default line coding (baud rate, bit parity, number of data bits,
274:               and format). This function also enables the endpoints and prepares for
275:               the first transfer from the host.
276:               
277:               This function should be called after the SET_CONFIGURATION command.
278:               This is most simply done by calling this function from the
279:               USBCBInitEP() function.
280:               
281:               Typical Usage:
282:               <code>
283:                   void USBCBInitEP(void)
284:                   {
285:                       CDCInitEP();
286:                   }
287:               </code>
288:             Conditions:
289:               None
290:             Remarks:
291:               None                                                                   
292:             **************************************************************************/
293:           void CDCInitEP(void)
294:           {
295:               //Abstract line coding information
296:               line_coding.dwDTERate   = 19200;      // baud rate
129B  3000     MOVLW 0x0
1307  3000     MOVLW 0x0
1308  0024     MOVLB 0x4
1309  00B9     MOVWF 0x239
130A  3000     MOVLW 0x0
130B  00B8     MOVWF 0x238
130C  304B     MOVLW 0x4B
130D  00B7     MOVWF 0x237
130E  3000     MOVLW 0x0
130F  00B6     MOVWF line_coding
297:               line_coding.bCharFormat = 0x00;             // 1 stop bit
12A4  01BA     CLRF 0x23A
1310  01BA     CLRF 0x23A
298:               line_coding.bParityType = 0x00;             // None
12A5  01BB     CLRF 0x23B
1311  01BB     CLRF 0x23B
299:               line_coding.bDataBits = 0x08;               // 5,6,7,8, or 16
12A6  3008     MOVLW 0x8
12A7  00FD     MOVWF 0x27D
12A8  087D     MOVF 0x27D, W
12A9  00BC     MOVWF 0x23C
1312  3008     MOVLW 0x8
1313  0021     MOVLB 0x1
1314  00B3     MOVWF byte_to_send
1315  0833     MOVF byte_to_send, W
1316  0024     MOVLB 0x4
1317  00BC     MOVWF 0x23C
300:           
301:               cdc_rx_len = 0;
12AA  0023     MOVLB 0x3
12AB  01EA     CLRF cdc_rx_len
1318  0023     MOVLB 0x3
1319  01EA     CLRF cdc_rx_len
302:               
303:               /*
304:                * Do not have to init Cnt of IN pipes here.
305:                * Reason:  Number of BYTEs to send to the host
306:                *          varies from one transaction to
307:                *          another. Cnt should equal the exact
308:                *          number of BYTEs to transmit for
309:                *          a given IN transaction.
310:                *          This number of BYTEs will only
311:                *          be known right before the data is
312:                *          sent.
313:                */
314:               USBEnableEndpoint(CDC_COMM_EP,USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
12AC  301A     MOVLW 0x1A
12AD  00FD     MOVWF 0x1FD
12AE  087D     MOVF 0x1FD, W
12AF  00F7     MOVWF 0x1F7
12B0  3001     MOVLW 0x1
12B1  3191     MOVLP 0x11
12B2  2157     CALL 0x157
12B3  3192     MOVLP 0x12
131A  301A     MOVLW 0x1A
131B  0021     MOVLB 0x1
131C  00B3     MOVWF byte_to_send
131D  0833     MOVF byte_to_send, W
131E  00AD     MOVWF options
131F  3001     MOVLW 0x1
1320  3191     MOVLP 0x11
1321  21B7     CALL 0x1B7
1322  3193     MOVLP 0x13
315:               USBEnableEndpoint(CDC_DATA_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
12B4  301E     MOVLW 0x1E
12B5  00FD     MOVWF 0xFD
12B6  087D     MOVF 0xFD, W
12B7  00F7     MOVWF 0xF7
12B8  3002     MOVLW 0x2
12B9  3191     MOVLP 0x11
12BA  2157     CALL 0x157
12BB  3192     MOVLP 0x12
1323  301E     MOVLW 0x1E
1324  0021     MOVLB 0x1
1325  00B3     MOVWF byte_to_send
1326  0833     MOVF byte_to_send, W
1327  00AD     MOVWF options
1328  3002     MOVLW 0x2
1329  3191     MOVLP 0x11
132A  21B7     CALL 0x1B7
132B  3193     MOVLP 0x13
316:           
317:               CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(uint8_t*)&cdc_data_rx,sizeof(cdc_data_rx));
12BC  01F0     CLRF 0xF0
12BD  30C0     MOVLW 0xC0
12BE  00F1     MOVWF 0xF1
12BF  3020     MOVLW 0x20
12C0  00F2     MOVWF 0xF2
12C1  3040     MOVLW 0x40
12C2  00FD     MOVWF 0xFD
12C3  087D     MOVF 0xFD, W
12C4  00F3     MOVWF 0xF3
12C5  3002     MOVLW 0x2
12C6  318C     MOVLP 0xC
12C7  2496     CALL 0x496
12C8  0871     MOVF 0xF1, W
12C9  0023     MOVLB 0x3
12CA  00D0     MOVWF 0x1D0
12CB  0870     MOVF 0x1F0, W
12CC  00CF     MOVWF CDCDataOutHandle
132C  0021     MOVLB 0x1
132D  01A6     CLRF length
132E  30C0     MOVLW 0xC0
132F  00A7     MOVWF p
1330  3020     MOVLW 0x20
1331  00A8     MOVWF data
1332  3040     MOVLW 0x40
1333  00B3     MOVWF byte_to_send
1334  0833     MOVF byte_to_send, W
1335  00A9     MOVWF len
1336  3002     MOVLW 0x2
1337  3187     MOVLP 0x7
1338  2778     CALL 0x778
1339  0021     MOVLB 0x1
133A  0827     MOVF p, W
133B  0023     MOVLB 0x3
133C  00D0     MOVWF 0x1D0
133D  0021     MOVLB 0x1
133E  0826     MOVF length, W
133F  0023     MOVLB 0x3
1340  00CF     MOVWF CDCDataOutHandle
318:               CDCDataInHandle = NULL;
12CD  01CD     CLRF CDCDataInHandle
12CE  01CE     CLRF 0x1CE
1341  01CD     CLRF CDCDataInHandle
1342  01CE     CLRF 0x1CE
319:           
320:               #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
321:                 	CDCNotificationInHandle = NULL;
322:                   mInitDTSPin();  //Configure DTS as a digital input
323:                 	SerialStateBitmap.byte = 0x00;
324:                 	OldSerialStateBitmap.byte = !SerialStateBitmap.byte;    //To force firmware to send an initial serial state packet to the host.
325:                   //Prepare a SerialState notification element packet (contains info like DSR state)
326:                   SerialStatePacket.bmRequestType = 0xA1; //Always 0xA1 for this type of packet.
327:                   SerialStatePacket.bNotification = SERIAL_STATE;
328:                   SerialStatePacket.wValue = 0x0000;  //Always 0x0000 for this type of packet
329:                   SerialStatePacket.wIndex = CDC_COMM_INTF_ID;  //Interface number  
330:                   SerialStatePacket.SerialState.byte = 0x00;
331:                   SerialStatePacket.Reserved = 0x00;
332:                   SerialStatePacket.wLength = 0x02;   //Always 2 bytes for this type of packet    
333:                   CDCNotificationHandler();
334:             	#endif
335:             	
336:             	#if defined(USB_CDC_SUPPORT_DTR_SIGNALING)
337:             	    mInitDTRPin();
338:             	#endif
339:             	
340:             	#if defined(USB_CDC_SUPPORT_HARDWARE_FLOW_CONTROL)
341:             	    mInitRTSPin();
342:             	    mInitCTSPin();
343:             	#endif
344:               
345:               cdc_trf_state = CDC_TX_READY;
12CF  01E9     CLRF cdc_trf_state
1343  01E9     CLRF cdc_trf_state
346:           }//end CDCInitEP
12D0  0008     RETURN
1344  0008     RETURN
347:           
348:           
349:           /**************************************************************************
350:             Function: void CDCNotificationHandler(void)
351:             Summary: Checks for changes in DSR status and reports them to the USB host.
352:             Description: Checks for changes in DSR pin state and reports any changes
353:                          to the USB host. 
354:             Conditions: CDCInitEP() must have been called previously, prior to calling
355:                         CDCNotificationHandler() for the first time.
356:             Remarks:
357:               This function is only implemented and needed when the 
358:               USB_CDC_SUPPORT_DSR_REPORTING option has been enabled.  If the function is
359:               enabled, it should be called periodically to sample the DSR pin and feed
360:               the information to the USB host.  This can be done by calling 
361:               CDCNotificationHandler() by itself, or, by calling CDCTxService() which
362:               also calls CDCNotificationHandler() internally, when appropriate.
363:             **************************************************************************/
364:           #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
365:           void CDCNotificationHandler(void)
366:           {
367:               //Check the DTS I/O pin and if a state change is detected, notify the 
368:               //USB host by sending a serial state notification element packet.
369:               if(UART_DTS == USB_CDC_DSR_ACTIVE_LEVEL) //UART_DTS must be defined to be an I/O pin in the hardware profile to use the DTS feature (ex: "PORTXbits.RXY")
370:               {
371:                   SerialStateBitmap.bits.DSR = 1;
372:               }  
373:               else
374:               {
375:                   SerialStateBitmap.bits.DSR = 0;
376:               }        
377:               
378:               //If the state has changed, and the endpoint is available, send a packet to
379:               //notify the hUSB host of the change.
380:               if((SerialStateBitmap.byte != OldSerialStateBitmap.byte) && (!USBHandleBusy(CDCNotificationInHandle)))
381:               {
382:                   //Copy the updated value into the USB packet buffer to send.
383:                   SerialStatePacket.SerialState.byte = SerialStateBitmap.byte;
384:                   //We don't need to write to the other bytes in the SerialStatePacket USB
385:                   //buffer, since they don't change and will always be the same as our
386:                   //initialized value.
387:           
388:                   //Send the packet over USB to the host.
389:                   CDCNotificationInHandle = USBTransferOnePacket(CDC_COMM_EP, IN_TO_HOST, (uint8_t*)&SerialStatePacket, sizeof(SERIAL_STATE_NOTIFICATION));
390:                   
391:                   //Save the old value, so we can detect changes later.
392:                   OldSerialStateBitmap.byte = SerialStateBitmap.byte;
393:               }    
394:           }//void CDCNotificationHandler(void)    
395:           #else
396:               #define CDCNotificationHandler() {}
397:           #endif
398:           
399:           
400:           /**********************************************************************************
401:             Function:
402:               bool USBCDCEventHandler(USB_EVENT event, void *pdata, uint16_t size)
403:               
404:             Summary:
405:               Handles events from the USB stack, which may have an effect on the CDC 
406:               endpoint(s).
407:           
408:             Description:
409:               Handles events from the USB stack.  This function should be called when 
410:               there is a USB event that needs to be processed by the CDC driver.
411:               
412:             Conditions:
413:               Value of input argument 'len' should be smaller than the maximum
414:               endpoint size responsible for receiving bulk data from USB host for CDC
415:               class. Input argument 'buffer' should point to a buffer area that is
416:               bigger or equal to the size specified by 'len'.
417:             Input:
418:               event - the type of event that occurred
419:               pdata - pointer to the data that caused the event
420:               size - the size of the data that is pointed to by pdata
421:                                                                                              
422:             **********************************************************************************/
423:           bool USBCDCEventHandler(USB_EVENT event, void *pdata, uint16_t size)
424:           {
425:               switch( (uint16_t)event )
426:               {  
427:                   case EVENT_TRANSFER_TERMINATED:
428:                       if(pdata == CDCDataOutHandle)
429:                       {
430:                           CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(uint8_t*)&cdc_data_rx,sizeof(cdc_data_rx));
431:                       }
432:                       if(pdata == CDCDataInHandle)
433:                       {
434:                           //flush all of the data in the CDC buffer
435:                           cdc_trf_state = CDC_TX_READY;
436:                           cdc_tx_len = 0;
437:                       }
438:                       break;
439:                   default:
440:                       return false;
441:               }      
442:               return true;
443:           }
444:           
445:           /**********************************************************************************
446:             Function:
447:                   uint8_t getsUSBUSART(char *buffer, uint8_t len)
448:               
449:             Summary:
450:               getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
451:               endpoint to a user's specified location. It is a non-blocking function.
452:               It does not wait for data if there is no data available. Instead it
453:               returns '0' to notify the caller that there is no data available.
454:           
455:             Description:
456:               getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
457:               endpoint to a user's specified location. It is a non-blocking function.
458:               It does not wait for data if there is no data available. Instead it
459:               returns '0' to notify the caller that there is no data available.
460:               
461:               Typical Usage:
462:               <code>
463:                   uint8_t numBytes;
464:                   uint8_t buffer[64]
465:               
466:                   numBytes = getsUSBUSART(buffer,sizeof(buffer)); //until the buffer is free.
467:                   if(numBytes \> 0)
468:                   {
469:                       //we received numBytes bytes of data and they are copied into
470:                       //  the "buffer" variable.  We can do something with the data
471:                       //  here.
472:                   }
473:               </code>
474:             Conditions:
475:               Value of input argument 'len' should be smaller than the maximum
476:               endpoint size responsible for receiving bulk data from USB host for CDC
477:               class. Input argument 'buffer' should point to a buffer area that is
478:               bigger or equal to the size specified by 'len'.
479:             Input:
480:               buffer -  Pointer to where received BYTEs are to be stored
481:               len -     The number of BYTEs expected.
482:                                                                                              
483:             **********************************************************************************/
484:           uint8_t getsUSBUSART(uint8_t *buffer, uint8_t len)
1684  0021     MOVLB 0x1
1685  00B4     MOVWF event
485:           {
486:               cdc_rx_len = 0;
1686  0023     MOVLB 0x3
1687  01EA     CLRF cdc_rx_len
487:               
488:               if(!USBHandleBusy(CDCDataOutHandle))
1688  084F     MOVF CDCDataOutHandle, W
1689  0450     IORWF 0x1D0, W
168A  1903     BTFSC 0x183, 0x2
168B  2E92     GOTO 0x692
168C  084F     MOVF CDCDataOutHandle, W
168D  0086     MOVWF 0x186
168E  0850     MOVF 0x1D0, W
168F  0087     MOVWF 0x187
1690  1B81     BTFSC 0x181, 0x7
1691  2EDE     GOTO 0x6DE
489:               {
490:                   /*
491:                    * Adjust the expected number of BYTEs to equal
492:                    * the actual number of BYTEs received.
493:                    */
494:                   if(len > USBHandleGetLength(CDCDataOutHandle))
1692  084F     MOVF CDCDataOutHandle, W
1693  0086     MOVWF 0x186
1694  0850     MOVF 0x1D0, W
1695  0087     MOVWF 0x187
1696  3141     ADDFSR 1, 1
1697  0021     MOVLB 0x1
1698  0831     MOVF len, W
1699  0201     SUBWF 0x81, W
169A  1803     BTFSC 0x83, 0x0
169B  2EA7     GOTO 0x6A7
495:                       len = USBHandleGetLength(CDCDataOutHandle);
169C  0023     MOVLB 0x3
169D  084F     MOVF CDCDataOutHandle, W
169E  0086     MOVWF 0x186
169F  0850     MOVF 0x1D0, W
16A0  0087     MOVWF 0x187
16A1  3141     ADDFSR 1, 1
16A2  0801     MOVF 0x181, W
16A3  0021     MOVLB 0x1
16A4  00B2     MOVWF i
16A5  0832     MOVF i, W
16A6  00B1     MOVWF len
496:                   
497:                   /*
498:                    * Copy data from dual-ram buffer to user's buffer
499:                    */
500:                   for(cdc_rx_len = 0; cdc_rx_len < len; cdc_rx_len++)
16A7  0023     MOVLB 0x3
16A8  01EA     CLRF cdc_rx_len
16A9  0021     MOVLB 0x1
16AA  0831     MOVF len, W
16AB  0023     MOVLB 0x3
16AC  026A     SUBWF cdc_rx_len, W
16AD  1803     BTFSC 0x183, 0x0
16AE  2EC9     GOTO 0x6C9
16C3  3001     MOVLW 0x1
16C4  00B2     MOVWF 0x1B2
16C5  0832     MOVF 0x1B2, W
16C6  0023     MOVLB 0x3
16C7  07EA     ADDWF cdc_rx_len, F
16C8  2EA9     GOTO 0x6A9
501:                       buffer[cdc_rx_len] = cdc_data_rx[cdc_rx_len];
16AF  086A     MOVF cdc_rx_len, W
16B0  3EC0     ADDLW 0xC0
16B1  0086     MOVWF 0x186
16B2  0187     CLRF 0x187
16B3  3020     MOVLW 0x20
16B4  3D87     ADDWFC 0x187, F
16B5  0801     MOVF 0x181, W
16B6  0021     MOVLB 0x1
16B7  00B2     MOVWF i
16B8  0023     MOVLB 0x3
16B9  086A     MOVF cdc_rx_len, W
16BA  0021     MOVLB 0x1
16BB  0734     ADDWF event, W
16BC  00B3     MOVWF byte_to_send
16BD  0833     MOVF byte_to_send, W
16BE  0086     MOVWF 0x86
16BF  3002     MOVLW 0x2
16C0  0087     MOVWF 0x87
16C1  0832     MOVF i, W
16C2  0081     MOVWF 0x81
502:           
503:                   /*
504:                    * Prepare dual-ram buffer for next OUT transaction
505:                    */
506:           
507:                   CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(uint8_t*)&cdc_data_rx,sizeof(cdc_data_rx));
16C9  0021     MOVLB 0x1
16CA  01A6     CLRF length
16CB  30C0     MOVLW 0xC0
16CC  00A7     MOVWF p
16CD  3020     MOVLW 0x20
16CE  00A8     MOVWF data
16CF  3040     MOVLW 0x40
16D0  00B2     MOVWF i
16D1  0832     MOVF i, W
16D2  00A9     MOVWF len
16D3  3002     MOVLW 0x2
16D4  3187     MOVLP 0x7
16D5  2778     CALL 0x778
16D6  0021     MOVLB 0x1
16D7  0827     MOVF p, W
16D8  0023     MOVLB 0x3
16D9  00D0     MOVWF 0x1D0
16DA  0021     MOVLB 0x1
16DB  0826     MOVF length, W
16DC  0023     MOVLB 0x3
16DD  00CF     MOVWF CDCDataOutHandle
508:           
509:               }//end if
510:               
511:               return cdc_rx_len;
16DE  086A     MOVF cdc_rx_len, W
16DF  0008     RETURN
512:               
513:           }//end getsUSBUSART
514:           
515:           /******************************************************************************
516:             Function:
517:           	void putUSBUSART(char *data, uint8_t length)
518:           		
519:             Summary:
520:               putUSBUSART writes an array of data to the USB. Use this version, is
521:               capable of transferring 0x00 (what is typically a NULL character in any of
522:               the string transfer functions).
523:           
524:             Description:
525:               putUSBUSART writes an array of data to the USB. Use this version, is
526:               capable of transferring 0x00 (what is typically a NULL character in any of
527:               the string transfer functions).
528:               
529:               Typical Usage:
530:               <code>
531:                   if(USBUSARTIsTxTrfReady())
532:                   {
533:                       char data[] = {0x00, 0x01, 0x02, 0x03, 0x04};
534:                       putUSBUSART(data,5);
535:                   }
536:               </code>
537:               
538:               The transfer mechanism for device-to-host(put) is more flexible than
539:               host-to-device(get). It can handle a string of data larger than the
540:               maximum size of bulk IN endpoint. A state machine is used to transfer a
541:               \long string of data over multiple USB transactions. CDCTxService()
542:               must be called periodically to keep sending blocks of data to the host.
543:           
544:             Conditions:
545:               USBUSARTIsTxTrfReady() must return true. This indicates that the last
546:               transfer is complete and is ready to receive a new block of data. The
547:               string of characters pointed to by 'data' must equal to or smaller than
548:               255 BYTEs.
549:           
550:             Input:
551:               char *data - pointer to a RAM array of data to be transfered to the host
552:               uint8_t length - the number of bytes to be transfered (must be less than 255).
553:           		
554:            *****************************************************************************/
555:           void putUSBUSART(uint8_t *data, uint8_t  length)
10C6  0021     MOVLB 0x1
10C7  00A8     MOVWF data
556:           {
557:               /*
558:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
559:                * before calling this function.
560:                * As a safety precaution, this function checks the state one more time
561:                * to make sure it does not override any pending transactions.
562:                *
563:                * Currently it just quits the routine without reporting any errors back
564:                * to the user.
565:                *
566:                * Bottom line: User MUST make sure that USBUSARTIsTxTrfReady()==1
567:                *             before calling this function!
568:                * Example:
569:                * if(USBUSARTIsTxTrfReady())
570:                *     putUSBUSART(pData, Length);
571:                *
572:                * IMPORTANT: Never use the following blocking while loop to wait:
573:                * while(!USBUSARTIsTxTrfReady())
574:                *     putUSBUSART(pData, Length);
575:                *
576:                * The whole firmware framework is written based on cooperative
577:                * multi-tasking and a blocking code is not acceptable.
578:                * Use a state machine instead.
579:                */
580:               USBMaskInterrupts();
10C8  1112     BCF PIE2, 0x2
581:               if(cdc_trf_state == CDC_TX_READY)
10C9  0023     MOVLB 0x3
10CA  0869     MOVF cdc_trf_state, W
10CB  1D03     BTFSS 0x183, 0x2
10CC  28DD     GOTO 0xDD
582:               {
583:                   mUSBUSARTTxRam((uint8_t*)data, length);     // See cdc.h
10CD  0021     MOVLB 0x1
10CE  0828     MOVF data, W
10CF  0023     MOVLB 0x3
10D0  00D3     MOVWF pCDCSrc
10D1  3003     MOVLW 0x3
10D2  00D4     MOVWF 0x1D4
10D3  0021     MOVLB 0x1
10D4  0826     MOVF length, W
10D5  00A7     MOVWF p
10D6  0827     MOVF p, W
10D7  0023     MOVLB 0x3
10D8  00E8     MOVWF cdc_tx_len
10D9  01E7     CLRF cdc_mem_type
10DA  0AE7     INCF cdc_mem_type, F
10DB  01E9     CLRF cdc_trf_state
10DC  0AE9     INCF cdc_trf_state, F
584:               }
585:               USBUnmaskInterrupts();
10DD  0021     MOVLB 0x1
10DE  1512     BSF PIE2, 0x2
586:           }//end putUSBUSART
10DF  0008     RETURN
587:           
588:           /******************************************************************************
589:           	Function:
590:           		void putsUSBUSART(char *data)
591:           		
592:             Summary:
593:               putsUSBUSART writes a string of data to the USB including the null
594:               character. Use this version, 'puts', to transfer data from a RAM buffer.
595:           
596:             Description:
597:               putsUSBUSART writes a string of data to the USB including the null
598:               character. Use this version, 'puts', to transfer data from a RAM buffer.
599:               
600:               Typical Usage:
601:               <code>
602:                   if(USBUSARTIsTxTrfReady())
603:                   {
604:                       char data[] = "Hello World";
605:                       putsUSBUSART(data);
606:                   }
607:               </code>
608:               
609:               The transfer mechanism for device-to-host(put) is more flexible than
610:               host-to-device(get). It can handle a string of data larger than the
611:               maximum size of bulk IN endpoint. A state machine is used to transfer a
612:               \long string of data over multiple USB transactions. CDCTxService()
613:               must be called periodically to keep sending blocks of data to the host.
614:           
615:             Conditions:
616:               USBUSARTIsTxTrfReady() must return true. This indicates that the last
617:               transfer is complete and is ready to receive a new block of data. The
618:               string of characters pointed to by 'data' must equal to or smaller than
619:               255 BYTEs.
620:           
621:             Input:
622:               char *data -  null\-terminated string of constant data. If a
623:                                       null character is not found, 255 BYTEs of data
624:                                       will be transferred to the host.
625:           		
626:            *****************************************************************************/
627:            
628:           void putsUSBUSART(char *data)
629:           {
630:               uint8_t len;
631:               char *pData;
632:           
633:               /*
634:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
635:                * before calling this function.
636:                * As a safety precaution, this function checks the state one more time
637:                * to make sure it does not override any pending transactions.
638:                *
639:                * Currently it just quits the routine without reporting any errors back
640:                * to the user.
641:                *
642:                * Bottom line: User MUST make sure that USBUSARTIsTxTrfReady()==1
643:                *             before calling this function!
644:                * Example:
645:                * if(USBUSARTIsTxTrfReady())
646:                *     putsUSBUSART(pData, Length);
647:                *
648:                * IMPORTANT: Never use the following blocking while loop to wait:
649:                * while(!USBUSARTIsTxTrfReady())
650:                *     putsUSBUSART(pData);
651:                *
652:                * The whole firmware framework is written based on cooperative
653:                * multi-tasking and a blocking code is not acceptable.
654:                * Use a state machine instead.
655:                */
656:               USBMaskInterrupts();
657:               if(cdc_trf_state != CDC_TX_READY)
658:               {
659:                   USBUnmaskInterrupts();
660:                   return;
661:               }
662:               
663:               /*
664:                * While loop counts the number of BYTEs to send including the
665:                * null character.
666:                */
667:               len = 0;
668:               pData = data;
669:               do
670:               {
671:                   len++;
672:                   if(len == 255) break;       // Break loop once max len is reached.
673:               }while(*pData++);
674:               
675:               /*
676:                * Second piece of information (length of data to send) is ready.
677:                * Call mUSBUSARTTxRam to setup the transfer.
678:                * The actual transfer process will be handled by CDCTxService(),
679:                * which should be called once per Main Program loop.
680:                */
681:               mUSBUSARTTxRam((uint8_t*)data, len);     // See cdc.h
682:               USBUnmaskInterrupts();
683:           }//end putsUSBUSART
684:           
685:           /**************************************************************************
686:             Function:
687:                   void putrsUSBUSART(const const char *data)
688:               
689:             Summary:
690:               putrsUSBUSART writes a string of data to the USB including the null
691:               character. Use this version, 'putrs', to transfer data literals and
692:               data located in program memory.
693:           
694:             Description:
695:               putrsUSBUSART writes a string of data to the USB including the null
696:               character. Use this version, 'putrs', to transfer data literals and
697:               data located in program memory.
698:               
699:               Typical Usage:
700:               <code>
701:                   if(USBUSARTIsTxTrfReady())
702:                   {
703:                       putrsUSBUSART("Hello World");
704:                   }
705:               </code>
706:               
707:               The transfer mechanism for device-to-host(put) is more flexible than
708:               host-to-device(get). It can handle a string of data larger than the
709:               maximum size of bulk IN endpoint. A state machine is used to transfer a
710:               \long string of data over multiple USB transactions. CDCTxService()
711:               must be called periodically to keep sending blocks of data to the host.
712:           
713:             Conditions:
714:               USBUSARTIsTxTrfReady() must return true. This indicates that the last
715:               transfer is complete and is ready to receive a new block of data. The
716:               string of characters pointed to by 'data' must equal to or smaller than
717:               255 BYTEs.
718:           
719:             Input:
720:               const const char *data -  null\-terminated string of constant data. If a
721:                                       null character is not found, 255 uint8_ts of data
722:                                       will be transferred to the host.
723:                                                                                      
724:             **************************************************************************/
725:           void putrsUSBUSART(const const char *data)
726:           {
727:               uint8_t len;
728:               const const char *pData;
729:           
730:               /*
731:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
732:                * before calling this function.
733:                * As a safety precaution, this function checks the state one more time
734:                * to make sure it does not override any pending transactions.
735:                *
736:                * Currently it just quits the routine without reporting any errors back
737:                * to the user.
738:                *
739:                * Bottom line: User MUST make sure that USBUSARTIsTxTrfReady()
740:                *             before calling this function!
741:                * Example:
742:                * if(USBUSARTIsTxTrfReady())
743:                *     putsUSBUSART(pData);
744:                *
745:                * IMPORTANT: Never use the following blocking while loop to wait:
746:                * while(cdc_trf_state != CDC_TX_READY)
747:                *     putsUSBUSART(pData);
748:                *
749:                * The whole firmware framework is written based on cooperative
750:                * multi-tasking and a blocking code is not acceptable.
751:                * Use a state machine instead.
752:                */
753:               USBMaskInterrupts();
754:               if(cdc_trf_state != CDC_TX_READY)
755:               {
756:                   USBUnmaskInterrupts();
757:                   return;
758:               }
759:               
760:               /*
761:                * While loop counts the number of BYTEs to send including the
762:                * null character.
763:                */
764:               len = 0;
765:               pData = data;
766:               do
767:               {
768:                   len++;
769:                   if(len == 255) break;       // Break loop once max len is reached.
770:               }while(*pData++);
771:               
772:               /*
773:                * Second piece of information (length of data to send) is ready.
774:                * Call mUSBUSARTTxRom to setup the transfer.
775:                * The actual transfer process will be handled by CDCTxService(),
776:                * which should be called once per Main Program loop.
777:                */
778:           
779:               mUSBUSARTTxRom((const uint8_t*)data,len); // See cdc.h
780:               USBUnmaskInterrupts();
781:           
782:           }//end putrsUSBUSART
783:           
784:           /************************************************************************
785:             Function:
786:                   void CDCTxService(void)
787:               
788:             Summary:
789:               CDCTxService handles device-to-host transaction(s). This function
790:               should be called once per Main Program loop after the device reaches
791:               the configured state.
792:             Description:
793:               CDCTxService handles device-to-host transaction(s). This function
794:               should be called once per Main Program loop after the device reaches
795:               the configured state (after the CDCIniEP() function has already executed).
796:               This function is needed, in order to advance the internal software state 
797:               machine that takes care of sending multiple transactions worth of IN USB
798:               data to the host, associated with CDC serial data.  Failure to call 
799:               CDCTxService() periodically will prevent data from being sent to the
800:               USB host, over the CDC serial data interface.
801:               
802:               Typical Usage:
803:               <code>
804:               void main(void)
805:               {
806:                   USBDeviceInit();
807:                   while(1)
808:                   {
809:                       USBDeviceTasks();
810:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
811:                          (USBIsDeviceSuspended() == true))
812:                       {
813:                           //Either the device is not configured or we are suspended
814:                           //  so we don't want to do execute any application code
815:                           continue;   //go back to the top of the while loop
816:                       }
817:                       else
818:                       {
819:                           //Keep trying to send data to the PC as required
820:                           CDCTxService();
821:               
822:                           //Run application code.
823:                           UserApplication();
824:                       }
825:                   }
826:               }
827:               </code>
828:             Conditions:
829:               CDCIniEP() function should have already executed/the device should be
830:               in the CONFIGURED_STATE.
831:             Remarks:
832:               None                                                                 
833:             ************************************************************************/
834:            
835:           void CDCTxService(void)
836:           {
837:               uint8_t byte_to_send;
838:               uint8_t i;
839:               
840:               USBMaskInterrupts();
0496  0021     MOVLB 0x1
0497  1112     BCF PIE2, 0x2
841:               
842:               CDCNotificationHandler();
843:               
844:               if(USBHandleBusy(CDCDataInHandle)) 
0498  0023     MOVLB 0x3
0499  084D     MOVF CDCDataInHandle, W
049A  044E     IORWF 0x1CE, W
049B  1903     BTFSC 0x183, 0x2
049C  2CA6     GOTO 0x4A6
049D  084D     MOVF CDCDataInHandle, W
049E  0086     MOVWF 0x186
049F  084E     MOVF 0x1CE, W
04A0  0087     MOVWF 0x187
04A1  1F81     BTFSS 0x181, 0x7
04A2  2CA6     GOTO 0x4A6
845:               {
846:                   USBUnmaskInterrupts();
04A3  0021     MOVLB 0x1
04A4  1512     BSF PIE2, 0x2
847:                   return;
04A5  0008     RETURN
848:               }
849:           
850:               /*
851:                * Completing stage is necessary while [ mCDCUSartTxIsBusy()==1 ].
852:                * By having this stage, user can always check cdc_trf_state,
853:                * and not having to call mCDCUsartTxIsBusy() directly.
854:                */
855:               if(cdc_trf_state == CDC_TX_COMPLETING)
04A6  3003     MOVLW 0x3
04A7  0023     MOVLB 0x3
04A8  0669     XORWF cdc_trf_state, W
04A9  1903     BTFSC 0x183, 0x2
856:                   cdc_trf_state = CDC_TX_READY;
04AA  01E9     CLRF cdc_trf_state
857:               
858:               /*
859:                * If CDC_TX_READY state, nothing to do, just return.
860:                */
861:               if(cdc_trf_state == CDC_TX_READY)
04AB  0869     MOVF cdc_trf_state, W
04AC  1D03     BTFSS 0x183, 0x2
04AD  2CB1     GOTO 0x4B1
862:               {
863:                   USBUnmaskInterrupts();
04AE  0021     MOVLB 0x1
04AF  1512     BSF PIE2, 0x2
864:                   return;
04B0  0008     RETURN
865:               }
866:               
867:               /*
868:                * If CDC_TX_BUSY_ZLP state, send zero length packet
869:                */
870:               if(cdc_trf_state == CDC_TX_BUSY_ZLP)
04B1  3002     MOVLW 0x2
04B2  0023     MOVLB 0x3
04B3  0669     XORWF cdc_trf_state, W
04B4  1D03     BTFSS 0x183, 0x2
04B5  2CD1     GOTO 0x4D1
871:               {
872:                   CDCDataInHandle = USBTxOnePacket(CDC_DATA_EP,NULL,0);
04B6  0021     MOVLB 0x1
04B7  01A6     CLRF length
04B8  0AA6     INCF length, F
04B9  3000     MOVLW 0x0
04BA  00A7     MOVWF p
04BB  3000     MOVLW 0x0
04BC  00A8     MOVWF data
04BD  01A9     CLRF len
04BE  3002     MOVLW 0x2
04BF  3187     MOVLP 0x7
04C0  2778     CALL 0x778
04C1  3184     MOVLP 0x4
04C2  0021     MOVLB 0x1
04C3  0827     MOVF p, W
04C4  0023     MOVLB 0x3
04C5  00CE     MOVWF 0x1CE
04C6  0021     MOVLB 0x1
04C7  0826     MOVF length, W
04C8  0023     MOVLB 0x3
04C9  00CD     MOVWF CDCDataInHandle
873:                   //CDC_DATA_BD_IN.CNT = 0;
874:                   cdc_trf_state = CDC_TX_COMPLETING;
04CA  3003     MOVLW 0x3
04CB  0021     MOVLB 0x1
04CC  00B1     MOVWF len
04CD  0831     MOVF len, W
04CE  0023     MOVLB 0x3
04CF  00E9     MOVWF cdc_trf_state
875:               }
04D0  2D5F     GOTO 0x55F
876:               else if(cdc_trf_state == CDC_TX_BUSY)
04D1  0369     DECF cdc_trf_state, W
04D2  1D03     BTFSS 0x183, 0x2
04D3  2D5F     GOTO 0x55F
877:               {
878:                   /*
879:                    * First, have to figure out how many byte of data to send.
880:                    */
881:               	if(cdc_tx_len > sizeof(cdc_data_tx))
04D4  3041     MOVLW 0x41
04D5  0268     SUBWF cdc_tx_len, W
04D6  1C03     BTFSS 0x183, 0x0
04D7  2CDA     GOTO 0x4DA
882:               	    byte_to_send = sizeof(cdc_data_tx);
04D8  3040     MOVLW 0x40
04D9  2CDC     GOTO 0x4DC
883:               	else
884:               	    byte_to_send = cdc_tx_len;
04DA  0023     MOVLB 0x3
04DB  0868     MOVF cdc_tx_len, W
04DC  0021     MOVLB 0x1
04DD  00B1     MOVWF len
04DE  0831     MOVF len, W
04DF  00B3     MOVWF byte_to_send
885:           
886:                   /*
887:                    * Subtract the number of bytes just about to be sent from the total.
888:                    */
889:               	cdc_tx_len = cdc_tx_len - byte_to_send;
04E0  0333     DECF byte_to_send, W
04E1  3AFF     XORLW 0xFF
04E2  0023     MOVLB 0x3
04E3  0768     ADDWF cdc_tx_len, W
04E4  0021     MOVLB 0x1
04E5  00B1     MOVWF len
04E6  0831     MOVF len, W
04E7  0023     MOVLB 0x3
04E8  00E8     MOVWF cdc_tx_len
890:               	  
891:                   pCDCDst.bRam = (uint8_t*)&cdc_data_tx; // Set destination pointer
04E9  3020     MOVLW 0x20
04EA  00D2     MOVWF 0x1D2
04EB  3080     MOVLW 0x80
04EC  00D1     MOVWF pCDCDst
892:                   
893:                   i = byte_to_send;
04ED  0021     MOVLB 0x1
04EE  0833     MOVF byte_to_send, W
04EF  00B1     MOVWF len
04F0  0831     MOVF len, W
04F1  00B2     MOVWF i
894:                   if(cdc_mem_type == USB_EP0_ROM)            // Determine type of memory source
04F2  0023     MOVLB 0x3
04F3  0867     MOVF cdc_mem_type, W
04F4  1903     BTFSC 0x183, 0x2
04F5  2D13     GOTO 0x513
04F6  2D34     GOTO 0x534
895:                   {
896:                       while(i)
0513  0021     MOVLB 0x1
0514  0832     MOVF i, W
0515  1903     BTFSC 0x83, 0x2
0516  2D38     GOTO 0x538
0517  2CF7     GOTO 0x4F7
897:                       {
898:                           *pCDCDst.bRam = *pCDCSrc.bRom;
04F7  0023     MOVLB 0x3
04F8  0853     MOVF pCDCSrc, W
04F9  0086     MOVWF 0x186
04FA  0854     MOVF 0x1D4, W
04FB  0087     MOVWF 0x187
04FC  0801     MOVF 0x181, W
04FD  0021     MOVLB 0x1
04FE  00B1     MOVWF len
04FF  0023     MOVLB 0x3
0500  0851     MOVF pCDCDst, W
0501  0086     MOVWF 0x186
0502  0852     MOVF 0x1D2, W
0503  0087     MOVWF 0x187
0504  0021     MOVLB 0x1
0505  0831     MOVF len, W
0506  0081     MOVWF 0x81
899:                           pCDCDst.bRam++;
0507  3001     MOVLW 0x1
0508  0023     MOVLB 0x3
0509  07D1     ADDWF pCDCDst, F
050A  3000     MOVLW 0x0
050B  3DD2     ADDWFC 0x1D2, F
900:                           pCDCSrc.bRom++;
050C  3001     MOVLW 0x1
050D  07D3     ADDWF pCDCSrc, F
050E  3000     MOVLW 0x0
050F  3DD4     ADDWFC 0x1D4, F
901:                           i--;
0510  3001     MOVLW 0x1
0511  0021     MOVLB 0x1
0512  02B2     SUBWF i, F
902:                       }//end while(byte_to_send)
903:                   }
904:                   else
905:                   {
906:                       while(i)
0534  0021     MOVLB 0x1
0535  0832     MOVF i, W
0536  1D03     BTFSS 0x83, 0x2
0537  2D18     GOTO 0x518
907:                       {
908:                           *pCDCDst.bRam = *pCDCSrc.bRam;
0518  0023     MOVLB 0x3
0519  0853     MOVF pCDCSrc, W
051A  0086     MOVWF 0x186
051B  0854     MOVF 0x1D4, W
051C  0087     MOVWF 0x187
051D  0801     MOVF 0x181, W
051E  0021     MOVLB 0x1
051F  00B1     MOVWF len
0520  0023     MOVLB 0x3
0521  0851     MOVF pCDCDst, W
0522  0086     MOVWF 0x186
0523  0852     MOVF 0x1D2, W
0524  0087     MOVWF 0x187
0525  0021     MOVLB 0x1
0526  0831     MOVF len, W
0527  0081     MOVWF 0x81
909:                           pCDCDst.bRam++;
0528  3001     MOVLW 0x1
0529  0023     MOVLB 0x3
052A  07D1     ADDWF pCDCDst, F
052B  3000     MOVLW 0x0
052C  3DD2     ADDWFC 0x1D2, F
910:                           pCDCSrc.bRam++;
052D  3001     MOVLW 0x1
052E  07D3     ADDWF pCDCSrc, F
052F  3000     MOVLW 0x0
0530  3DD4     ADDWFC 0x1D4, F
911:                           i--;
0531  3001     MOVLW 0x1
0532  0021     MOVLB 0x1
0533  02B2     SUBWF i, F
912:                       }
913:                   }
914:                   
915:                   /*
916:                    * Lastly, determine if a zero length packet state is necessary.
917:                    * See explanation in USB Specification 2.0: Section 5.8.3
918:                    */
919:                   if(cdc_tx_len == 0)
0538  0023     MOVLB 0x3
0539  0868     MOVF cdc_tx_len, W
053A  1D03     BTFSS 0x183, 0x2
053B  2D49     GOTO 0x549
920:                   {
921:                       if(byte_to_send == CDC_DATA_IN_EP_SIZE)
053C  3040     MOVLW 0x40
053D  0021     MOVLB 0x1
053E  0633     XORWF byte_to_send, W
053F  1D03     BTFSS 0x83, 0x2
0540  2D43     GOTO 0x543
922:                           cdc_trf_state = CDC_TX_BUSY_ZLP;
0541  3002     MOVLW 0x2
0542  2D45     GOTO 0x545
923:                       else
924:                           cdc_trf_state = CDC_TX_COMPLETING;
0543  3003     MOVLW 0x3
0544  0021     MOVLB 0x1
0545  00B1     MOVWF len
0546  0831     MOVF len, W
0547  0023     MOVLB 0x3
0548  00E9     MOVWF cdc_trf_state
925:                   }//end if(cdc_tx_len...)
926:                   CDCDataInHandle = USBTxOnePacket(CDC_DATA_EP,(uint8_t*)&cdc_data_tx,byte_to_send);
0549  0021     MOVLB 0x1
054A  01A6     CLRF length
054B  0AA6     INCF length, F
054C  3080     MOVLW 0x80
054D  00A7     MOVWF p
054E  3020     MOVLW 0x20
054F  00A8     MOVWF data
0550  0833     MOVF byte_to_send, W
0551  00B1     MOVWF len
0552  0831     MOVF len, W
0553  00A9     MOVWF len
0554  3002     MOVLW 0x2
0555  3187     MOVLP 0x7
0556  2778     CALL 0x778
0557  0021     MOVLB 0x1
0558  0827     MOVF p, W
0559  0023     MOVLB 0x3
055A  00CE     MOVWF 0x1CE
055B  0021     MOVLB 0x1
055C  0826     MOVF length, W
055D  0023     MOVLB 0x3
055E  00CD     MOVWF CDCDataInHandle
927:           
928:               }//end if(cdc_tx_sate == CDC_TX_BUSY)
929:               
930:               USBUnmaskInterrupts();
055F  0021     MOVLB 0x1
0560  1512     BSF PIE2, 0x2
931:           }//end CDCTxService
0561  0008     RETURN
932:           
933:           #endif //USB_USE_CDC
934:           
935:           /** EOF cdc.c ****************************************************************/
---  C:/Users/LarsErik/MPLABXProjects/blink.X/mcc_generated_files/usb/usb_device.c  ---------------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /*******************************************************************************
23:              USB Device Layer
24:            
25:              Company:
26:                Microchip Technology Inc.
27:            
28:              File Name:
29:                usb_device.c
30:            
31:              Summary:
32:               Provides basic USB device functionality, including enumeration and USB
33:               chapter 9 required behavior.
34:            
35:              Description:
36:               Provides basic USB device functionality, including enumeration and USB
37:               chapter 9 required behavior.
38:            *******************************************************************************/
39:            
40:            // *****************************************************************************
41:            // *****************************************************************************
42:            // Section: Included Files
43:            // *****************************************************************************
44:            // *****************************************************************************
45:            #include <xc.h>
46:            
47:            #include <stdint.h>
48:            #include <stddef.h>
49:            #include <string.h>
50:            
51:            #include "usb_device_config.h"
52:            
53:            #include "usb.h"
54:            #include "usb_ch9.h"
55:            #include "usb_device.h"
56:            #include "usb_device_local.h"
57:            
58:            #ifndef uintptr_t
59:                #if  defined(__XC8__) || defined(__XC16__)
60:                    #define uintptr_t uint16_t
61:                #elif defined (__XC32__)
62:                    #define uintptr_t uint32_t
63:                #endif
64:            #endif
65:            
66:            #if defined(USB_USE_MSD)
67:                #include "usb_device_msd.h"
68:            #endif
69:            
70:            // *****************************************************************************
71:            // *****************************************************************************
72:            // Section: File Scope or Global Constants
73:            // *****************************************************************************
74:            // *****************************************************************************
75:            #if !defined(USE_USB_BUS_SENSE_IO)
76:                //Assume the +5V VBUS is always present (like it would be in a bus powered
77:                //only application), unless USE_USB_BUS_SENSE_IO and USB_BUS_SENSE have
78:                //been properly defined elsewhere in the project.
79:                #undef USB_BUS_SENSE
80:                #define USB_BUS_SENSE 1
81:            #endif
82:            
83:            #if defined(USB_DEVICE_DISABLE_DTS_CHECKING)
84:                #define _DTS_CHECKING_ENABLED 0
85:            #else
86:                #define _DTS_CHECKING_ENABLED _DTSEN
87:            #endif
88:            
89:            #if !defined(self_power)
90:                //Assume the application is always bus powered, unless self_power has been
91:                //defined elsewhere in the project
92:                #define self_power 0    //0 = bus powered
93:            #endif
94:            
95:            #if !defined(USB_MAX_NUM_CONFIG_DSC)
96:                //Assume the application only implements one configuration descriptor,
97:                //unless otherwise specified elsewhere in the project
98:                #define USB_MAX_NUM_CONFIG_DSC      1
99:            #endif
100:           
101:           #if defined(__XC8)
102:               //Suppress expected/harmless compiler warning message about unused RAM variables
103:               //and certain function pointer usage.
104:               //Certain variables and function pointers are not used if you don't use all
105:               //of the USB stack APIs.  However, these variables should not be
106:               //removed (since they are still used/needed in some applications, and this
107:               //is a common file shared by many projects, some of which rely on the "unused"
108:               //variables/function pointers).
109:               #pragma warning disable 1090
110:               #if __XC8_VERSION > 1300
111:                   #pragma warning disable 1471
112:               #endif
113:           #endif
114:           
115:           // *****************************************************************************
116:           // *****************************************************************************
117:           // Section: File Scope Data Types
118:           // *****************************************************************************
119:           // *****************************************************************************
120:           typedef union
121:           {
122:               uint8_t Val;
123:               struct __PACKED
124:               {
125:                   unsigned b0:1;
126:                   unsigned b1:1;
127:                   unsigned b2:1;
128:                   unsigned b3:1;
129:                   unsigned b4:1;
130:                   unsigned b5:1;
131:                   unsigned b6:1;
132:                   unsigned b7:1;
133:               } bits;
134:           } uint8_t_VAL, uint8_t_BITS;
135:           
136:           // *****************************************************************************
137:           // *****************************************************************************
138:           // Section: Variables
139:           // *****************************************************************************
140:           // *****************************************************************************
141:           USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
142:           USB_VOLATILE uint8_t USBActiveConfiguration;
143:           USB_VOLATILE uint8_t USBAlternateInterface[USB_MAX_NUM_INT];
144:           volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
145:           volatile BDT_ENTRY *pBDTEntryEP0OutNext;
146:           volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
147:           volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
148:           USB_VOLATILE uint8_t shortPacketStatus;
149:           USB_VOLATILE uint8_t controlTransferState;
150:           USB_VOLATILE IN_PIPE inPipes[1];
151:           USB_VOLATILE OUT_PIPE outPipes[1];
152:           USB_VOLATILE uint8_t *pDst;
153:           USB_VOLATILE bool RemoteWakeup;
154:           USB_VOLATILE bool USBBusIsSuspended;
155:           USB_VOLATILE USTAT_FIELDS USTATcopy;
156:           USB_VOLATILE uint8_t endpoint_number;
157:           USB_VOLATILE bool BothEP0OutUOWNsSet;
158:           USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
159:           USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
160:           USB_VOLATILE uint8_t USBStatusStageTimeoutCounter;
161:           volatile bool USBDeferStatusStagePacket;
162:           volatile bool USBStatusStageEnabledFlag1;
163:           volatile bool USBStatusStageEnabledFlag2;
164:           volatile bool USBDeferINDataStagePackets;
165:           volatile bool USBDeferOUTDataStagePackets;
166:           USB_VOLATILE uint32_t USB1msTickCount;
167:           USB_VOLATILE uint8_t USBTicksSinceSuspendEnd;
168:           
169:           /** USB FIXED LOCATION VARIABLES ***********************************/
170:           #if defined(COMPILER_MPLAB_C18)
171:               #pragma udata USB_BDT=USB_BDT_ADDRESS
172:           #endif
173:           
174:           volatile BDT_ENTRY BDT[BDT_NUM_ENTRIES] BDT_BASE_ADDR_TAG;
175:           
176:           /********************************************************************
177:            * EP0 Buffer Space
178:            *******************************************************************/
179:           volatile CTRL_TRF_SETUP SetupPkt CTRL_TRF_SETUP_ADDR_TAG;
180:           volatile uint8_t CtrlTrfData[USB_EP0_BUFF_SIZE] CTRL_TRF_DATA_ADDR_TAG;
181:           
182:           /********************************************************************
183:            * non-EP0 Buffer Space
184:            *******************************************************************/
185:           #if defined(USB_USE_MSD)
186:               //Check if the MSD application specific USB endpoint buffer placement address 
187:               //macros have already been defined or not (ex: in a processor specific header)
188:               //The msd_cbw and msd_csw buffers must be USB module accessible (and therefore
189:               //must be at a certain address range on certain microcontrollers).
190:               #if !defined(MSD_CBW_ADDR_TAG)
191:                   //Not previously defined.  Assume in this case all microcontroller RAM is
192:                   //USB module accessible, and therefore, no specific address tag value is needed.
193:                   #define MSD_CBW_ADDR_TAG
194:                   #define MSD_CSW_ADDR_TAG
195:               #endif
196:           	volatile USB_MSD_CBW msd_cbw MSD_CBW_ADDR_TAG;  //Must be located in USB module accessible RAM
197:           	volatile USB_MSD_CSW msd_csw MSD_CSW_ADDR_TAG;  //Must be located in USB module accessible RAM
198:           
199:               #if defined(__18CXX) || defined(__XC8)
200:                   volatile char msd_buffer[512] @ MSD_BUFFER_ADDRESS;
201:               #else
202:                   volatile char msd_buffer[512];
203:           	#endif
204:           #endif
205:           
206:           //Depricated in v2.2 - will be removed in a future revision
207:           #if !defined(USB_USER_DEVICE_DESCRIPTOR)
208:               //Device descriptor
209:               extern const USB_DEVICE_DESCRIPTOR device_dsc;
210:           #else
211:               USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
212:           #endif
213:           
214:           #if !defined(USB_USER_CONFIG_DESCRIPTOR)
215:               //Array of configuration descriptors
216:               extern const uint8_t *const USB_CD_Ptr[];
217:           #else
218:               USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
219:           #endif
220:           
221:           extern const uint8_t *const USB_SD_Ptr[];
222:           
223:           
224:           // *****************************************************************************
225:           // *****************************************************************************
226:           // Section: Private and External Prototypes
227:           // *****************************************************************************
228:           // *****************************************************************************
229:           extern bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size);
230:           
231:           static void USBCtrlEPService(void);
232:           static void USBCtrlTrfSetupHandler(void);
233:           static void USBCtrlTrfInHandler(void);
234:           static void USBCheckStdRequest(void);
235:           static void USBStdGetDscHandler(void);
236:           static void USBCtrlEPServiceComplete(void);
237:           static void USBCtrlTrfTxService(void);
238:           static void USBCtrlTrfRxService(void);
239:           static void USBStdSetCfgHandler(void);
240:           static void USBStdGetStatusHandler(void);
241:           static void USBStdFeatureReqHandler(void);
242:           static void USBCtrlTrfOutHandler(void);
243:           static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction);
244:           static void USBWakeFromSuspend(void);
245:           static void USBSuspend(void);
246:           static void USBStallHandler(void);
247:           
248:           // *****************************************************************************
249:           // *****************************************************************************
250:           // Section: Macros or Functions
251:           // *****************************************************************************
252:           // *****************************************************************************
253:           
254:           /**************************************************************************
255:               Function:
256:                   void USBDeviceInit(void)
257:               
258:               Description:
259:                   This function initializes the device stack it in the default state. The
260:                   USB module will be completely reset including all of the internal
261:                   variables, registers, and interrupt flags.
262:                           
263:               Precondition:
264:                   This function must be called before any of the other USB Device
265:                   functions can be called, including USBDeviceTasks().
266:                   
267:               Parameters:
268:                   None
269:                
270:               Return Values:
271:                   None
272:                   
273:               Remarks:
274:                   None
275:                                                                     
276:             ***************************************************************************/
277:           void USBDeviceInit(void)
278:           {
279:               uint8_t i;
280:           
281:               USBDisableInterrupts();
0562  0021     MOVLB 0x1
0563  1112     BCF PIE2, 0x2
06CB  0021     MOVLB 0x1
282:           
283:               //Make sure that if a GPIO output driver exists on VBUS, that it is 
284:               //tri-stated to avoid potential contention with the host
285:               USB_HAL_VBUSTristate();
286:               
287:               // Clear all USB error flags
288:               USBClearInterruptRegister(U1EIR);  
0564  003D     MOVLB 0x1D
0565  0193     CLRF UEIR
06CD  003D     MOVLB 0x1D
06CE  0193     CLRF UEIR
289:                  
290:               // Clears all USB interrupts          
291:               USBClearInterruptRegister(U1IR); 
0566  0190     CLRF UIR
06CF  0190     CLRF UIR
292:           
293:               //Clear all of the endpoint control registers
294:               U1EP0 = 0;
0567  0198     CLRF UEP0
06D0  0198     CLRF UEP0
295:               
296:               DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
0568  300E     MOVLW 0xE
0569  0021     MOVLB 0x1
056A  00A8     MOVWF data
056B  3099     MOVLW 0x99
056C  00A7     MOVWF p
056D  01A9     CLRF len
056E  3002     MOVLW 0x2
056F  0229     SUBWF len, W
0570  1803     BTFSC 0x83, 0x0
0571  2D83     GOTO 0x583
0572  0827     MOVF p, W
0573  0086     MOVWF 0x86
0574  0828     MOVF data, W
0575  0087     MOVWF 0x87
0576  0181     CLRF 0x81
0577  3001     MOVLW 0x1
0578  07A7     ADDWF p, F
0579  3000     MOVLW 0x0
057A  3DA8     ADDWFC data, F
057B  3001     MOVLW 0x1
057C  00A6     MOVWF length
057D  0826     MOVF length, W
057E  07A9     ADDWF len, F
057F  3002     MOVLW 0x2
0580  0229     SUBWF len, W
0581  1C03     BTFSS 0x83, 0x0
0582  2D72     GOTO 0x572
06D1  300E     MOVLW 0xE
06D2  00F2     MOVWF 0xF2
06D3  3099     MOVLW 0x99
06D4  00F1     MOVWF 0xF1
06D5  01F3     CLRF 0xF3
06D6  3002     MOVLW 0x2
06D7  0273     SUBWF 0xF3, W
06D8  1803     BTFSC 0x83, 0x0
06D9  2EEB     GOTO 0x6EB
06DA  0871     MOVF 0xF1, W
06DB  0086     MOVWF 0x86
06DC  0872     MOVF 0xF2, W
06DD  0087     MOVWF 0x87
06DE  0181     CLRF 0x81
06DF  3001     MOVLW 0x1
06E0  07F1     ADDWF 0xF1, F
06E1  3000     MOVLW 0x0
06E2  3DF2     ADDWFC 0xF2, F
06E3  3001     MOVLW 0x1
06E4  00F0     MOVWF 0xF0
06E5  0870     MOVF 0xF0, W
06E6  07F3     ADDWF 0xF3, F
06E7  3002     MOVLW 0x2
06E8  0273     SUBWF 0xF3, W
06E9  1C03     BTFSS 0x83, 0x0
06EA  2EDA     GOTO 0x6DA
297:           
298:               SetConfigurationOptions();
0583  3016     MOVLW 0x16
0584  003D     MOVLB 0x1D
0585  0091     MOVWF UCFG
0586  309F     MOVLW 0x9F
0587  0097     MOVWF UEIE
0588  307B     MOVLW 0x7B
0589  0092     MOVWF UIE
06EB  3016     MOVLW 0x16
06EC  003D     MOVLB 0x1D
06ED  0091     MOVWF UCFG
06EE  309F     MOVLW 0x9F
06EF  0097     MOVWF UEIE
06F0  307B     MOVLW 0x7B
06F1  0092     MOVWF UIE
299:           
300:               //power up the module (if not already powered)
301:               USBPowerModule();
302:           
303:               //set the address of the BDT (if applicable)
304:               USBSetBDTAddress(BDT);
305:           
306:               //Clear all of the BDT entries
307:               for(i = 0; i < (sizeof(BDT)/sizeof(BDT_ENTRY)); i++)
058A  0021     MOVLB 0x1
058B  01AA     CLRF i
058C  300C     MOVLW 0xC
058D  022A     SUBWF i, W
058E  1803     BTFSC 0x83, 0x0
058F  2DA9     GOTO 0x5A9
05A1  3001     MOVLW 0x1
05A2  00A6     MOVWF length
05A3  0826     MOVF length, W
05A4  07AA     ADDWF i, F
05A5  300C     MOVLW 0xC
05A6  022A     SUBWF i, W
05A7  1C03     BTFSS 0x83, 0x0
05A8  2D90     GOTO 0x590
06F2  01F4     CLRF 0xF4
06F3  300C     MOVLW 0xC
06F4  0274     SUBWF 0xF4, W
06F5  1803     BTFSC 0x83, 0x0
06F6  2F10     GOTO 0x710
0708  3001     MOVLW 0x1
0709  00F0     MOVWF 0xF0
070A  0870     MOVF 0xF0, W
070B  07F4     ADDWF 0xF4, F
070C  300C     MOVLW 0xC
070D  0274     SUBWF 0xF4, W
070E  1C03     BTFSS 0x83, 0x0
070F  2EF7     GOTO 0x6F7
308:               {
309:                   BDT[i].Val = 0x00;
0590  082A     MOVF i, W
0591  00A6     MOVWF length
0592  3001     MOVLW 0x1
0593  35A6     LSLF length, F
0594  3EFF     ADDLW 0xFF
0595  1D03     BTFSS 0x83, 0x2
0596  2D93     GOTO 0x593
0597  3526     LSLF length, W
0598  3E20     ADDLW 0x20
0599  0086     MOVWF 0x86
059A  0187     CLRF 0x87
059B  3000     MOVLW 0x0
059C  3FC0     MOVWI 0[FSR1]
059D  3000     MOVLW 0x0
059E  3FC1     MOVWI 1[FSR1]
059F  3FC2     MOVWI 2[FSR1]
05A0  3FC3     MOVWI 3[FSR1]
06F7  0874     MOVF 0xF4, W
06F8  00F0     MOVWF 0xF0
06F9  3001     MOVLW 0x1
06FA  35F0     LSLF 0xF0, F
06FB  3EFF     ADDLW 0xFF
06FC  1D03     BTFSS 0x83, 0x2
06FD  2EFA     GOTO 0x6FA
06FE  3570     LSLF 0xF0, W
06FF  3E20     ADDLW 0x20
0700  0086     MOVWF 0x86
0701  0187     CLRF 0x87
0702  3000     MOVLW 0x0
0703  3FC0     MOVWI 0[FSR1]
0704  3000     MOVLW 0x0
0705  3FC1     MOVWI 1[FSR1]
0706  3FC2     MOVWI 2[FSR1]
0707  3FC3     MOVWI 3[FSR1]
310:               }
311:           
312:               // Assert reset request to all of the Ping Pong buffer pointers
313:               USBPingPongBufferReset = 1;                    
05A9  003D     MOVLB 0x1D
05AA  170E     BSF UCON, 0x6
0710  003D     MOVLB 0x1D
0711  170E     BSF UCON, 0x6
314:           
315:               // Reset to default address
316:               U1ADDR = 0x00;                   
05AB  0196     CLRF UADDR
0712  0196     CLRF UADDR
317:           
318:               // Make sure packet processing is enabled
319:               USBPacketDisable = 0;           
05AC  120E     BCF UCON, 0x4
0713  120E     BCF UCON, 0x4
320:           
321:               //Stop trying to reset ping pong buffer pointers
322:               USBPingPongBufferReset = 0;
05AD  130E     BCF UCON, 0x6
0714  130E     BCF UCON, 0x6
323:           
324:               // Flush any pending transactions
325:               do
326:               {
327:                   USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
05AE  30F7     MOVLW 0xF7
05AF  0021     MOVLB 0x1
05B0  00A6     MOVWF length
05B1  0826     MOVF length, W
05B2  003D     MOVLB 0x1D
05B3  0590     ANDWF UIR, F
0715  30F7     MOVLW 0xF7
0716  00F0     MOVWF 0xEF0
0717  0870     MOVF 0xEF0, W
0718  0590     ANDWF UIR, F
328:                   //Initialize USB stack software state variables
329:                   inPipes[0].info.Val = 0;
05B4  0021     MOVLB 0x1
05B5  01C5     CLRF 0xC5
0719  0021     MOVLB 0x1
071A  01C5     CLRF 0xC5
330:                   outPipes[0].info.Val = 0;
05B6  0023     MOVLB 0x3
05B7  01B2     CLRF 0x1B2
071B  0023     MOVLB 0x3
071C  01B2     CLRF 0x1B2
331:                   outPipes[0].wCount.Val = 0;
05B8  01B3     CLRF 0x1B3
05B9  01B4     CLRF 0x1B4
071D  01B3     CLRF 0x1B3
071E  01B4     CLRF 0x1B4
332:               }while(USBTransactionCompleteIF == 1);
05BA  003D     MOVLB 0x1D
05BB  1990     BTFSC UIR, 0x3
05BC  2DAE     GOTO 0x5AE
071F  003D     MOVLB 0x1D
0720  1990     BTFSC UIR, 0x3
0721  2F15     GOTO 0x715
333:           
334:               //Set flags to true, so the USBCtrlEPAllowStatusStage() function knows not to
335:               //try and arm a status stage, even before the first control transfer starts.
336:               USBStatusStageEnabledFlag1 = true;
05BD  3001     MOVLW 0x1
05BE  0021     MOVLB 0x1
05BF  00A6     MOVWF length
05C0  0826     MOVF length, W
05C1  0023     MOVLB 0x3
05C2  00DA     MOVWF USBStatusStageEnabledFlag1
0722  3001     MOVLW 0x1
0723  00F0     MOVWF 0x1F0
0724  0870     MOVF 0x1F0, W
0725  0023     MOVLB 0x3
0726  00DA     MOVWF USBStatusStageEnabledFlag1
337:               USBStatusStageEnabledFlag2 = true;
05C3  3001     MOVLW 0x1
05C4  0021     MOVLB 0x1
05C5  00A6     MOVWF length
05C6  0826     MOVF length, W
05C7  0023     MOVLB 0x3
05C8  00D9     MOVWF USBStatusStageEnabledFlag2
0727  3001     MOVLW 0x1
0728  00F0     MOVWF 0x1F0
0729  0870     MOVF 0x1F0, W
072A  00D9     MOVWF USBStatusStageEnabledFlag2
338:               //Initialize other flags
339:               USBDeferINDataStagePackets = false;
05C9  01D8     CLRF USBDeferINDataStagePackets
072B  01D8     CLRF USBDeferINDataStagePackets
340:               USBDeferOUTDataStagePackets = false;
05CA  01D7     CLRF USBDeferOUTDataStagePackets
072C  01D7     CLRF USBDeferOUTDataStagePackets
341:               USBBusIsSuspended = false;
05CB  01DF     CLRF USBBusIsSuspended
072D  01DF     CLRF USBBusIsSuspended
342:           
343:               //Initialize all pBDTEntryIn[] and pBDTEntryOut[]
344:               //pointers to NULL, so they don't get used inadvertently.
345:               for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
05CC  0021     MOVLB 0x1
05CD  01AA     CLRF i
05CE  3003     MOVLW 0x3
05CF  022A     SUBWF i, W
05D0  1803     BTFSC 0x83, 0x0
05D1  2DF6     GOTO 0x5F6
05EE  3001     MOVLW 0x1
05EF  00A6     MOVWF length
05F0  0826     MOVF length, W
05F1  07AA     ADDWF i, F
05F2  3003     MOVLW 0x3
05F3  022A     SUBWF i, W
05F4  1C03     BTFSS 0x83, 0x0
05F5  2DD2     GOTO 0x5D2
072E  01F4     CLRF 0xF4
072F  3003     MOVLW 0x3
0730  0274     SUBWF 0xF4, W
0731  1803     BTFSC 0x83, 0x0
0732  2F57     GOTO 0x757
074F  3001     MOVLW 0x1
0750  00F0     MOVWF 0xF0
0751  0870     MOVF 0xF0, W
0752  07F4     ADDWF 0xF4, F
0753  3003     MOVLW 0x3
0754  0274     SUBWF 0xF4, W
0755  1C03     BTFSS 0x83, 0x0
0756  2F33     GOTO 0x733
346:               {
347:                   pBDTEntryIn[i] = 0u;
05D2  352A     LSLF i, W
05D3  3EB7     ADDLW 0xB7
05D4  0086     MOVWF 0x86
05D5  3001     MOVLW 0x1
05D6  0087     MOVWF 0x87
05D7  3000     MOVLW 0x0
05D8  3FC0     MOVWI 0[FSR1]
05D9  3FC1     MOVWI 1[FSR1]
0733  3574     LSLF 0xF4, W
0734  3EB7     ADDLW 0xB7
0735  0086     MOVWF 0x86
0736  3001     MOVLW 0x1
0737  0087     MOVWF 0x87
0738  3000     MOVLW 0x0
0739  3FC0     MOVWI 0[FSR1]
073A  3FC1     MOVWI 1[FSR1]
348:                   pBDTEntryOut[i] = 0u;
05DA  352A     LSLF i, W
05DB  3EBD     ADDLW 0xBD
05DC  0086     MOVWF 0x86
05DD  3001     MOVLW 0x1
05DE  0087     MOVWF 0x87
05DF  3000     MOVLW 0x0
05E0  3FC0     MOVWI 0[FSR1]
05E1  3FC1     MOVWI 1[FSR1]
073B  3574     LSLF 0xF4, W
073C  3EBD     ADDLW 0xBD
073D  0086     MOVWF 0x86
073E  3001     MOVLW 0x1
073F  0087     MOVWF 0x87
0740  3000     MOVLW 0x0
0741  3FC0     MOVWI 0[FSR1]
0742  3FC1     MOVWI 1[FSR1]
349:                   ep_data_in[i].Val = 0u;
05E2  082A     MOVF i, W
05E3  3ECA     ADDLW 0xCA
05E4  0086     MOVWF 0x86
05E5  3001     MOVLW 0x1
05E6  0087     MOVWF 0x87
05E7  0181     CLRF 0x81
0743  0874     MOVF 0xF4, W
0744  3ECA     ADDLW 0xCA
0745  0086     MOVWF 0x86
0746  3001     MOVLW 0x1
0747  0087     MOVWF 0x87
0748  0181     CLRF 0x81
350:                   ep_data_out[i].Val = 0u;
05E8  082A     MOVF i, W
05E9  3EC7     ADDLW 0xC7
05EA  0086     MOVWF 0x86
05EB  3001     MOVLW 0x1
05EC  0087     MOVWF 0x87
05ED  0181     CLRF 0x81
0749  0874     MOVF 0xF4, W
074A  3EC7     ADDLW 0xC7
074B  0086     MOVWF 0x86
074C  3001     MOVLW 0x1
074D  0087     MOVWF 0x87
074E  0181     CLRF 0x81
351:               }
352:           
353:               //Get ready for the first packet
354:               pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
05F6  3028     MOVLW 0x28
05F7  0023     MOVLB 0x3
05F8  00B7     MOVWF pBDTEntryIn
05F9  3000     MOVLW 0x0
05FA  00B8     MOVWF 0x1B8
0757  3028     MOVLW 0x28
0758  0023     MOVLB 0x3
0759  00B7     MOVWF pBDTEntryIn
075A  3000     MOVLW 0x0
075B  00B8     MOVWF 0x1B8
355:               // Initialize EP0 as a Ctrl EP
356:               U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;        
05FB  3016     MOVLW 0x16
05FC  003D     MOVLB 0x1D
05FD  0098     MOVWF UEP0
075C  3016     MOVLW 0x16
075D  003D     MOVLB 0x1D
075E  0098     MOVWF UEP0
357:           	//Prepare for the first SETUP on EP0 OUT
358:               BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
05FE  3000     MOVLW 0x0
05FF  0020     MOVLB 0x0
0600  00A3     MOVWF 0x23
0601  3050     MOVLW 0x50
0602  00A2     MOVWF 0x22
075F  3000     MOVLW 0x0
0760  0020     MOVLB 0x0
0761  00A3     MOVWF 0x23
0762  3050     MOVLW 0x50
0763  00A2     MOVWF 0x22
359:               BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
0603  3008     MOVLW 0x8
0604  00A1     MOVWF 0x21
0764  3008     MOVLW 0x8
0765  00A1     MOVWF 0x21
360:               BDT[EP0_OUT_EVEN].STAT.Val = _DAT0|_BSTALL;
0605  3004     MOVLW 0x4
0606  0021     MOVLB 0x1
0607  00A6     MOVWF length
0608  0826     MOVF length, W
0609  0020     MOVLB 0x0
060A  00A0     MOVWF BDT
0766  3004     MOVLW 0x4
0767  00F0     MOVWF __pcstackCOMMON
0768  0870     MOVF __pcstackCOMMON, W
0769  00A0     MOVWF BDT
361:               BDT[EP0_OUT_EVEN].STAT.Val |= _USIE;
060B  17A0     BSF BDT, 0x7
076A  17A0     BSF BDT, 0x7
362:           
363:               // Clear active configuration
364:               USBActiveConfiguration = 0;     
060C  0023     MOVLB 0x3
060D  01EE     CLRF USBActiveConfiguration
076B  0023     MOVLB 0x3
076C  01EE     CLRF USBActiveConfiguration
365:           
366:               USB1msTickCount = 0;            //Keeps track of total number of milliseconds since calling USBDeviceInit() when first initializing the USB module/stack code.
060E  3000     MOVLW 0x0
060F  00C6     MOVWF 0x1C6
0610  3000     MOVLW 0x0
0611  00C5     MOVWF 0x1C5
0612  3000     MOVLW 0x0
0613  00C4     MOVWF 0x1C4
0614  3000     MOVLW 0x0
0615  00C3     MOVWF USB1msTickCount
076D  3000     MOVLW 0x0
076E  00C6     MOVWF 0x1C6
076F  3000     MOVLW 0x0
0770  00C5     MOVWF 0x1C5
0771  3000     MOVLW 0x0
0772  00C4     MOVWF 0x1C4
0773  3000     MOVLW 0x0
0774  00C3     MOVWF USB1msTickCount
367:               USBTicksSinceSuspendEnd = 0;    //Keeps track of the number of milliseconds since a suspend condition has ended.
0616  01D6     CLRF USBTicksSinceSuspendEnd
0775  01D6     CLRF USBTicksSinceSuspendEnd
368:           
369:               //Indicate that we are now in the detached state
370:               USBDeviceState = DETACHED_STATE;
0617  01E5     CLRF USBDeviceState
0776  01E5     CLRF USBDeviceState
371:           }
0618  0008     RETURN
0777  0008     RETURN
372:           
373:           
374:           
375:           /**************************************************************************
376:             Function:
377:                   void USBDeviceTasks(void)
378:               
379:             Summary:
380:               This function is the main state machine/transaction handler of the USB 
381:               device side stack.  When the USB stack is operated in "USB_POLLING" mode 
382:               (usb_device_config.h user option) the USBDeviceTasks() function should be called 
383:               periodically to receive and transmit packets through the stack. This 
384:               function also takes care of control transfers associated with the USB 
385:               enumeration process, and detecting various USB events (such as suspend).  
386:               This function should be called at least once every 1.8ms during the USB 
387:               enumeration process. After the enumeration process is complete (which can 
388:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
389:               USBDeviceTasks() handler may be called the faster of: either once 
390:               every 9.8ms, or as often as needed to make sure that the hardware USTAT 
391:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
392:               a minimum rate of either the frequency that USBTransferOnePacket() gets 
393:               called, or, once/1.8ms, whichever is faster.  See the inline code comments 
394:               near the top of usb_device.c for more details about minimum timing 
395:               requirements when calling USBDeviceTasks().
396:               
397:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
398:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
399:               mode, the USBDeviceTasks() handler only needs to execute when a USB 
400:               interrupt occurs, and therefore only needs to be called from the interrupt 
401:               context.
402:           
403:             Description:
404:               This function is the main state machine/transaction handler of the USB 
405:               device side stack.  When the USB stack is operated in "USB_POLLING" mode 
406:               (usb_device_config.h user option) the USBDeviceTasks() function should be called 
407:               periodically to receive and transmit packets through the stack. This 
408:               function also takes care of control transfers associated with the USB 
409:               enumeration process, and detecting various USB events (such as suspend).  
410:               This function should be called at least once every 1.8ms during the USB 
411:               enumeration process. After the enumeration process is complete (which can 
412:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
413:               USBDeviceTasks() handler may be called the faster of: either once 
414:               every 9.8ms, or as often as needed to make sure that the hardware USTAT 
415:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
416:               a minimum rate of either the frequency that USBTransferOnePacket() gets 
417:               called, or, once/1.8ms, whichever is faster.  See the inline code comments 
418:               near the top of usb_device.c for more details about minimum timing 
419:               requirements when calling USBDeviceTasks().
420:               
421:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
422:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
423:               mode, the USBDeviceTasks() handler only needs to execute when a USB 
424:               interrupt occurs, and therefore only needs to be called from the interrupt 
425:               context.
426:           
427:               Typical usage:
428:               <code>
429:               void main(void)
430:               {
431:                   USBDeviceInit();
432:                   while(1)
433:                   {
434:                       USBDeviceTasks(); //Takes care of enumeration and other USB events
435:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
436:                          (USBIsDeviceSuspended() == true))
437:                       {
438:                           //Either the device is not configured or we are suspended,
439:                           // so we don't want to execute any USB related application code
440:                           continue;   //go back to the top of the while loop
441:                       }
442:                       else
443:                       {
444:                           //Otherwise we are free to run USB and non-USB related user 
445:                           //application code.
446:                           UserApplication();
447:                       }
448:                   }
449:               }
450:               </code>
451:           
452:             Precondition:
453:               Make sure the USBDeviceInit() function has been called prior to calling
454:               USBDeviceTasks() for the first time.
455:             Remarks:
456:               USBDeviceTasks() does not need to be called while in the USB suspend mode, 
457:               if the user application firmware in the USBCBSuspend() callback function
458:               enables the ACTVIF USB interrupt source and put the microcontroller into 
459:               sleep mode.  If the application firmware decides not to sleep the 
460:               microcontroller core during USB suspend (ex: continues running at full 
461:               frequency, or clock switches to a lower frequency), then the USBDeviceTasks()
462:               function must still be called periodically, at a rate frequent enough to 
463:               ensure the 10ms resume recovery interval USB specification is met.  Assuming
464:               a worst case primary oscillator and PLL start up time of less than 5ms, then
465:               USBDeviceTasks() should be called once every 5ms in this scenario.
466:              
467:               When the USB cable is detached, or the USB host is not actively powering 
468:               the VBUS line to +5V nominal, the application firmware does not always have 
469:               to call USBDeviceTasks() frequently, as no USB activity will be taking 
470:               place.  However, if USBDeviceTasks() is not called regularly, some 
471:               alternative means of promptly detecting when VBUS is powered (indicating 
472:               host attachment), or not powered (host powered down or USB cable unplugged)
473:               is still needed.  For self or dual self/bus powered USB applications, see 
474:               the USBDeviceAttach() and USBDeviceDetach() API documentation for additional 
475:               considerations.
476:               ***************************************************************************/
477:           void USBDeviceTasks(void)
478:           {
479:               uint8_t i;
480:           
481:               #ifdef USB_SUPPORT_OTG
482:                   //SRP Time Out Check
483:                   if (USBOTGSRPIsReady())
484:                   {
485:                       if (USBT1MSECIF && USBT1MSECIE)
486:                       {
487:                           if (USBOTGGetSRPTimeOutFlag())
488:                           {
489:                               if (USBOTGIsSRPTimeOutExpired())
490:                               {
491:                                   USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
492:                               }
493:                           }
494:           
495:                           //Clear Interrupt Flag
496:                           USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
497:                       }
498:                   }
499:               #endif
500:           
501:               #if defined(USB_POLLING)
502:               //If the interrupt option is selected then the customer is required
503:               //  to notify the stack when the device is attached or removed from the
504:               //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
505:               if (USB_BUS_SENSE != 1)
506:               {
507:                    // Disable module & detach from bus
508:                    U1CON = 0;             
509:           
510:                    // Mask all USB interrupts              
511:                    U1IE = 0;          
512:           
513:                    //Move to the detached state                  
514:                    USBDeviceState = DETACHED_STATE;
515:           
516:                    #ifdef  USB_SUPPORT_OTG    
517:                        //Disable D+ Pullup
518:                        U1OTGCONbits.DPPULUP = 0;
519:           
520:                        //Disable HNP
521:                        USBOTGDisableHnp();
522:           
523:                        //Deactivate HNP
524:                        USBOTGDeactivateHnp();
525:                        
526:                        //If ID Pin Changed State
527:                        if (USBIDIF && USBIDIE)
528:                        {  
529:                            //Re-detect & Initialize
530:                             USBOTGInitialize();
531:           
532:                             //Clear ID Interrupt Flag
533:                             USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
534:                        }
535:                    #endif
536:           
537:                    #if defined __C30__ || defined __XC16__
538:                        //USBClearInterruptFlag(U1OTGIR, 3); 
539:                    #endif
540:                       //return so that we don't go through the rest of 
541:                       //the state machine
542:                    USBClearUSBInterrupt();
543:                    return;
544:               }
545:           
546:           	#ifdef USB_SUPPORT_OTG
547:               //If Session Is Started Then
548:               else
549:           	{
550:                   //If SRP Is Ready
551:                   if (USBOTGSRPIsReady())
552:                   {   
553:                       //Clear SRPReady
554:                       USBOTGClearSRPReady();
555:           
556:                       //Clear SRP Timeout Flag
557:                       USBOTGClearSRPTimeOutFlag();
558:           
559:                       //Indicate Session Started
560:                       UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
561:                   }
562:               }
563:           	#endif	//#ifdef USB_SUPPORT_OTG
564:           
565:               //if we are in the detached state
566:               if(USBDeviceState == DETACHED_STATE)
567:               {
568:           	    //Initialize register to known value
569:                   U1CON = 0;                          
570:           
571:                   // Mask all USB interrupts
572:                   U1IE = 0;                                
573:           
574:                   //Enable/set things like: pull ups, full/low-speed mode, 
575:                   //set the ping pong mode, and set internal transceiver
576:                   SetConfigurationOptions();
577:           
578:                   // Enable module & attach to bus
579:                   while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
580:           
581:                   //moved to the attached state
582:                   USBDeviceState = ATTACHED_STATE;
583:           
584:                   #ifdef  USB_SUPPORT_OTG
585:                       U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
586:                   #endif
587:               }
588:           	#endif  //#if defined(USB_POLLING)
589:           
590:               if(USBDeviceState == ATTACHED_STATE)
02C5  0023     MOVLB 0x3
02C6  0365     DECF USBDeviceState, W
02C7  1D03     BTFSS 0x183, 0x2
02C8  2AD5     GOTO 0x2D5
03AE  0023     MOVLB 0x3
591:               {
592:                   /*
593:                    * After enabling the USB module, it takes some time for the
594:                    * voltage on the D+ or D- line to rise high enough to get out
595:                    * of the SE0 condition. The USB Reset interrupt should not be
596:                    * unmasked until the SE0 condition is cleared. This helps
597:                    * prevent the firmware from misinterpreting this unique event
598:                    * as a USB bus reset from the USB host.
599:                    */
600:           
601:                   if(!USBSE0Event)
02C9  003D     MOVLB 0x1D
02CA  1A8E     BTFSC UCON, 0x5
02CB  2AD5     GOTO 0x2D5
03B2  003D     MOVLB 0x1D
03B3  1A8E     BTFSC UCON, 0x5
03B4  2BBE     GOTO 0x3BE
602:                   {
603:                       //We recently attached, make sure we are in a clean state
604:                       #if defined(__dsPIC33E__) || defined(_PIC24E__) || defined(__PIC32MM__)
605:                           U1IR = 0xFFEF;  //Preserve IDLEIF info, so we can detect suspend
606:                                           //during attach de-bounce interval
607:                       #else
608:                           USBClearInterruptRegister(U1IR);
02CC  0190     CLRF UIR
03B5  0190     CLRF UIR
609:                       #endif
610:           
611:                       #if defined(USB_POLLING)
612:                           U1IE=0;                        // Mask all USB interrupts
613:                       #endif
614:                       USBResetIE = 1;             // Unmask RESET interrupt
02CD  1412     BSF UIE, 0x0
03B6  1412     BSF UIE, 0x0
615:                       USBIdleIE = 1;             // Unmask IDLE interrupt
02CE  1612     BSF UIE, 0x4
03B7  1612     BSF UIE, 0x4
616:                       USBDeviceState = POWERED_STATE;
02CF  3002     MOVLW 0x2
02D0  0024     MOVLB 0x4
02D1  00D2     MOVWF 0x252
02D2  0852     MOVF 0x252, W
02D3  0023     MOVLB 0x3
02D4  00E5     MOVWF USBDeviceState
03B8  3002     MOVLW 0x2
03B9  0021     MOVLB 0x1
03BA  00A3     MOVWF 0xA3
03BB  0823     MOVF 0xA3, W
03BC  0023     MOVLB 0x3
03BD  00E5     MOVWF USBDeviceState
617:                   }
618:               }
619:           
620:               #ifdef  USB_SUPPORT_OTG
621:                   //If ID Pin Changed State
622:                   if (USBIDIF && USBIDIE)
623:                   {  
624:                       //Re-detect & Initialize
625:                       USBOTGInitialize();
626:           
627:                       USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
628:                   }
629:               #endif
630:           
631:               /*
632:                * Task A: Service USB Activity Interrupt
633:                */
634:               if(USBActivityIF && USBActivityIE)
02D5  003D     MOVLB 0x1D
02D6  1910     BTFSC UIR, 0x2
02D7  1D12     BTFSS UIE, 0x2
02D8  2AE2     GOTO 0x2E2
03BE  003D     MOVLB 0x1D
03BF  1910     BTFSC UIR, 0x2
03C0  1D12     BTFSS UIE, 0x2
03C1  2BCB     GOTO 0x3CB
635:               {
636:                   USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
02D9  30FB     MOVLW 0xFB
02DA  0024     MOVLB 0x4
02DB  00D2     MOVWF 0x252
02DC  0852     MOVF 0x252, W
02DD  003D     MOVLB 0x1D
02DE  0590     ANDWF UIR, F
03C2  30FB     MOVLW 0xFB
03C3  0021     MOVLB 0x1
03C4  00A3     MOVWF 0xA3
03C5  0823     MOVF 0xA3, W
03C6  003D     MOVLB 0x1D
03C7  0590     ANDWF UIR, F
637:                   #if defined(USB_SUPPORT_OTG)
638:                       U1OTGIR = 0x10;        
639:                   #else
640:                       USBWakeFromSuspend();
02DF  3191     MOVLP 0x11
02E0  2197     CALL 0x197
02E1  3182     MOVLP 0x2
03C8  3191     MOVLP 0x11
03C9  2177     CALL 0x177
03CA  3183     MOVLP 0x3
641:                   #endif
642:               }
643:           
644:               /*
645:                * Pointless to continue servicing if the device is in suspend mode.
646:                */
647:               if(USBSuspendControl==1)
02E2  003D     MOVLB 0x1D
02E3  1C8E     BTFSS UCON, 0x1
02E4  2AE8     GOTO 0x2E8
03CB  003D     MOVLB 0x1D
03CC  1C8E     BTFSS UCON, 0x1
03CD  2BD1     GOTO 0x3D1
648:               {
649:                   USBClearUSBInterrupt();
02E5  0020     MOVLB 0x0
02E6  1112     BCF PIR2, 0x2
03CE  0020     MOVLB 0x0
03CF  1112     BCF PIR2, 0x2
650:                   return;
02E7  0008     RETURN
03D0  0008     RETURN
651:               }
652:           
653:               /*
654:                * Task B: Service USB Bus Reset Interrupt.
655:                * When bus reset is received during suspend, ACTVIF will be set first,
656:                * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
657:                * This is why URSTIF is checked after ACTVIF.
658:                *
659:                * The USB reset flag is masked when the USB state is in
660:                * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
661:                * cause a USB reset event during these two states.
662:                */
663:               if(USBResetIF && USBResetIE)
02E8  1810     BTFSC 0x10, 0x0
02E9  1C12     BTFSS PIR2, 0x0
02EA  2AFC     GOTO 0x2FC
03D1  1810     BTFSC 0x10, 0x0
03D2  1C12     BTFSS PIR2, 0x0
03D3  2BE4     GOTO 0x3E4
664:               {
665:                   USBDeviceInit();
02EB  3185     MOVLP 0x5
02EC  2562     CALL 0x562
02ED  3182     MOVLP 0x2
03D4  3186     MOVLP 0x6
03D5  26CB     CALL 0x6CB
03D6  3183     MOVLP 0x3
666:           
667:                   //Re-enable the interrupts since the USBDeviceInit() function will
668:                   //  disable them.  This will do nothing in a polling setup
669:                   USBUnmaskInterrupts();
02EE  0021     MOVLB 0x1
02EF  1512     BSF PIE2, 0x2
03D7  0021     MOVLB 0x1
03D8  1512     BSF PIE2, 0x2
670:           
671:                   USBDeviceState = DEFAULT_STATE;
02F0  3004     MOVLW 0x4
02F1  0024     MOVLB 0x4
02F2  00D2     MOVWF 0x252
02F3  0852     MOVF 0x252, W
02F4  0023     MOVLB 0x3
02F5  00E5     MOVWF USBDeviceState
03D9  3004     MOVLW 0x4
03DA  00A3     MOVWF 0x1A3
03DB  0823     MOVF 0x1A3, W
03DC  0023     MOVLB 0x3
03DD  00E5     MOVWF USBDeviceState
672:           
673:                   #ifdef USB_SUPPORT_OTG
674:                        //Disable HNP
675:                        USBOTGDisableHnp();
676:           
677:                        //Deactivate HNP
678:                        USBOTGDeactivateHnp();
679:                   #endif
680:           
681:                   USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
02F6  30FE     MOVLW 0xFE
02F7  0024     MOVLB 0x4
02F8  00D2     MOVWF 0x252
02F9  0852     MOVF 0x252, W
02FA  003D     MOVLB 0x1D
02FB  0590     ANDWF UIR, F
03DE  30FE     MOVLW 0xFE
03DF  0021     MOVLB 0x1
03E0  00A3     MOVWF 0xA3
03E1  0823     MOVF 0xA3, W
03E2  003D     MOVLB 0x1D
03E3  0590     ANDWF UIR, F
682:               }
683:           
684:               /*
685:                * Task C: Service other USB interrupts
686:                */
687:               if(USBIdleIF && USBIdleIE)
02FC  1A10     BTFSC UIR, 0x4
02FD  1E12     BTFSS UIE, 0x4
02FE  2B02     GOTO 0x302
03E4  1A10     BTFSC UIR, 0x4
03E5  1E12     BTFSS UIE, 0x4
03E6  2BEA     GOTO 0x3EA
688:               { 
689:                   #ifdef  USB_SUPPORT_OTG 
690:                       //If Suspended, Try to switch to Host
691:                       USBOTGSelectRole(ROLE_HOST);
692:                       USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
693:                   #else
694:                       USBSuspend();
02FF  3191     MOVLP 0x11
0300  2138     CALL 0x138
0301  3182     MOVLP 0x2
03E7  3191     MOVLP 0x11
03E8  2119     CALL 0x119
03E9  3183     MOVLP 0x3
695:                   #endif
696:               }
697:           
698:               #if defined(__XC16__) || defined(__C30__) || defined(__XC32__)
699:                   //Check if a 1ms interval has elapsed.	
700:                   if(USBT1MSECIF)
701:                   {
702:                       USBClearInterruptFlag(USBT1MSECIFReg, USBT1MSECIFBitNum);
703:                       USBIncrement1msInternalTimers();
704:                   }
705:               #endif
706:           
707:               //Start-of-Frame Interrupt
708:               if(USBSOFIF)
0302  003D     MOVLB 0x1D
0303  1F10     BTFSS UIR, 0x6
0304  2B2C     GOTO 0x32C
03EA  003D     MOVLB 0x1D
03EB  1F10     BTFSS UIR, 0x6
03EC  2C14     GOTO 0x414
709:               {
710:                   //Call the user SOF event callback if enabled.
711:                   if(USBSOFIE)
0305  1F12     BTFSS UIE, 0x6
0306  2B17     GOTO 0x317
03ED  1F12     BTFSS UIE, 0x6
03EE  2BFF     GOTO 0x3FF
712:                   {
713:                       USB_SOF_HANDLER(EVENT_SOF,0,1);
0307  3073     MOVLW 0x73
0308  0021     MOVLB 0x1
0309  00B4     MOVWF event
030A  3000     MOVLW 0x0
030B  00B5     MOVWF 0xB5
030C  3000     MOVLW 0x0
030D  00B6     MOVWF pdata
030E  3000     MOVLW 0x0
030F  00B7     MOVWF numBytesRead
0310  3001     MOVLW 0x1
0311  00B8     MOVWF size
0312  3000     MOVLW 0x0
0313  00B9     MOVWF 0xB9
0314  3192     MOVLP 0x12
0315  2235     CALL 0x235
0316  3182     MOVLP 0x2
03EF  3073     MOVLW 0x73
03F0  0020     MOVLB 0x0
03F1  00E0     MOVWF __pcstackBANK0h
03F2  3000     MOVLW 0x0
03F3  00E1     MOVWF 0x61
03F4  3000     MOVLW 0x0
03F5  00E2     MOVWF pdata
03F6  3000     MOVLW 0x0
03F7  00E3     MOVWF 0x63
03F8  3001     MOVLW 0x1
03F9  00E4     MOVWF size
03FA  3000     MOVLW 0x0
03FB  00E5     MOVWF 0x65
03FC  3192     MOVLP 0x12
03FD  2205     CALL 0x205
03FE  3183     MOVLP 0x3
714:                   }    
715:                   USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
0317  30BF     MOVLW 0xBF
0318  0024     MOVLB 0x4
0319  00D2     MOVWF 0x252
031A  0852     MOVF 0x252, W
031B  003D     MOVLB 0x1D
031C  0590     ANDWF UIR, F
03FF  30BF     MOVLW 0xBF
0400  0021     MOVLB 0x1
0401  00A3     MOVWF 0xA3
0402  0823     MOVF 0xA3, W
0403  003D     MOVLB 0x1D
0404  0590     ANDWF UIR, F
716:           
717:                   #if defined(__XC8__) || defined(__C18__)
718:                       USBIncrement1msInternalTimers();
031D  3190     MOVLP 0x10
031E  20E0     CALL 0xE0
031F  3182     MOVLP 0x2
0405  3190     MOVLP 0x10
0406  2095     CALL 0x95
0407  3183     MOVLP 0x3
719:                   #endif
720:           
721:                   #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
722:                       //Supporting this feature requires a 1ms time base for keeping track of the timeout interval.
723:                       #if(USB_SPEED_OPTION == USB_LOW_SPEED)
724:                           #warning "Double click this message.  See inline code comments."
725:                           //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
726:                           //not strictly needed in all applications (ex: those that never call 
727:                           //USBDeferStatusStage() and don't use host to device (OUT) control
728:                           //transfers with data stage).  
729:                           //However, if this feature is enabled and used in a low speed application,
730:                           //it is required for the application code to periodically call the
731:                           //USBIncrement1msInternalTimers() function at a nominally 1ms rate.
732:                       #endif
733:                       
734:                       //Decrement our status stage counter.
735:                       if(USBStatusStageTimeoutCounter != 0u)
0320  0023     MOVLB 0x3
0321  085C     MOVF USBStatusStageTimeoutCounter, W
0322  1903     BTFSC 0x183, 0x2
0323  2B26     GOTO 0x326
0408  0023     MOVLB 0x3
0409  085C     MOVF USBStatusStageTimeoutCounter, W
040A  1903     BTFSC 0x183, 0x2
040B  2C0E     GOTO 0x40E
736:                       {
737:                           USBStatusStageTimeoutCounter--;
0324  3001     MOVLW 0x1
0325  02DC     SUBWF USBStatusStageTimeoutCounter, F
040C  3001     MOVLW 0x1
040D  02DC     SUBWF USBStatusStageTimeoutCounter, F
738:                       }
739:                       //Check if too much time has elapsed since progress was made in 
740:                       //processing the control transfer, without arming the status stage.  
741:                       //If so, auto-arm the status stage to ensure that the control 
742:                       //transfer can [eventually] complete, within the timing limits
743:                       //dictated by section 9.2.6 of the official USB 2.0 specifications.
744:                       if(USBStatusStageTimeoutCounter == 0)
0326  085C     MOVF USBStatusStageTimeoutCounter, W
0327  1D03     BTFSS 0x183, 0x2
0328  2B2C     GOTO 0x32C
040E  085C     MOVF USBStatusStageTimeoutCounter, W
040F  1D03     BTFSS 0x183, 0x2
0410  2C14     GOTO 0x414
745:                       {
746:                           USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
0329  318B     MOVLP 0xB
032A  231E     CALL 0x31E
032B  3182     MOVLP 0x2
0411  3189     MOVLP 0x9
0412  2153     CALL 0x153
0413  3183     MOVLP 0x3
747:                       } 
748:                   #endif
749:               }
750:           
751:               if(USBStallIF && USBStallIE)
032C  003D     MOVLB 0x1D
032D  1A90     BTFSC UIR, 0x5
032E  1E92     BTFSS UIE, 0x5
032F  2B33     GOTO 0x333
0414  003D     MOVLB 0x1D
0415  1A90     BTFSC UIR, 0x5
0416  1E92     BTFSS UIE, 0x5
0417  2C1B     GOTO 0x41B
752:               {
753:                   USBStallHandler();
0330  3191     MOVLP 0x11
0331  21DA     CALL 0x1DA
0332  3182     MOVLP 0x2
0418  3188     MOVLP 0x8
0419  2001     CALL 0x1
041A  3183     MOVLP 0x3
754:               }
755:           
756:               if(USBErrorIF && USBErrorIE)
0333  003D     MOVLB 0x1D
0334  1890     BTFSC UIR, 0x1
0335  1C92     BTFSS UIE, 0x1
0336  2B49     GOTO 0x349
041B  003D     MOVLB 0x1D
041C  1890     BTFSC UIR, 0x1
041D  1C92     BTFSS UIE, 0x1
041E  2C31     GOTO 0x431
757:               {
758:                   USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
0337  30FF     MOVLW 0xFF
0338  0021     MOVLB 0x1
0339  00B4     MOVWF event
033A  307F     MOVLW 0x7F
033B  00B5     MOVWF 0xB5
033C  3000     MOVLW 0x0
033D  00B6     MOVWF pdata
033E  3000     MOVLW 0x0
033F  00B7     MOVWF numBytesRead
0340  3001     MOVLW 0x1
0341  00B8     MOVWF size
0342  3000     MOVLW 0x0
0343  00B9     MOVWF 0xB9
0344  3192     MOVLP 0x12
0345  2235     CALL 0x235
0346  3182     MOVLP 0x2
041F  30FF     MOVLW 0xFF
0420  0020     MOVLB 0x0
0421  00E0     MOVWF __pcstackBANK0h
0422  307F     MOVLW 0x7F
0423  00E1     MOVWF 0x61
0424  3000     MOVLW 0x0
0425  00E2     MOVWF pdata
0426  3000     MOVLW 0x0
0427  00E3     MOVWF 0x63
0428  3001     MOVLW 0x1
0429  00E4     MOVWF size
042A  3000     MOVLW 0x0
042B  00E5     MOVWF 0x65
042C  3192     MOVLP 0x12
042D  2205     CALL 0x205
042E  3183     MOVLP 0x3
759:                   USBClearInterruptRegister(U1EIR);               // This clears UERRIF
0347  003D     MOVLB 0x1D
0348  0193     CLRF UEIR
042F  003D     MOVLB 0x1D
0430  0193     CLRF UEIR
760:           
761:                   //On PIC18, clearing the source of the error will automatically clear
762:                   //  the interrupt flag.  On other devices the interrupt flag must be 
763:                   //  manually cleared. 
764:                   #if defined(__C32__) || defined(__C30__) || defined __XC16__
765:                       USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
766:                   #endif
767:               }
768:           
769:               /*
770:                * Pointless to continue servicing if the host has not sent a bus reset.
771:                * Once bus reset is received, the device transitions into the DEFAULT
772:                * state and is ready for communication.
773:                */
774:               if(USBDeviceState < DEFAULT_STATE)
0349  3004     MOVLW 0x4
034A  0023     MOVLB 0x3
034B  0265     SUBWF USBDeviceState, W
034C  1803     BTFSC 0x183, 0x0
034D  2B51     GOTO 0x351
0431  3004     MOVLW 0x4
0432  0023     MOVLB 0x3
0433  0265     SUBWF USBDeviceState, W
0434  1803     BTFSC 0x183, 0x0
0435  2C39     GOTO 0x439
775:               {
776:                   USBClearUSBInterrupt();
034E  0020     MOVLB 0x0
034F  1112     BCF PIR2, 0x2
0436  0020     MOVLB 0x0
0437  1112     BCF PIR2, 0x2
777:                   return;
0350  0008     RETURN
0438  0008     RETURN
778:               }  
779:           
780:               /*
781:                * Task D: Servicing USB Transaction Complete Interrupt
782:                */
783:               if(USBTransactionCompleteIE)
0351  003D     MOVLB 0x1D
0352  1D92     BTFSS UIE, 0x3
0353  2BAB     GOTO 0x3AB
0439  003D     MOVLB 0x1D
043A  1D92     BTFSS UIE, 0x3
043B  2C93     GOTO 0x493
784:               {
785:                   for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth
0354  0023     MOVLB 0x3
0355  01EF     CLRF __pcstackBANK3
0356  3004     MOVLW 0x4
0357  026F     SUBWF __pcstackBANK3, W
0358  1803     BTFSC 0x183, 0x0
0359  2BAB     GOTO 0x3AB
03A1  3001     MOVLW 0x1
03A2  0024     MOVLB 0x4
03A3  00D2     MOVWF 0x252
03A4  0852     MOVF 0x252, W
03A5  0023     MOVLB 0x3
03A6  07EF     ADDWF __pcstackBANK3, F
03A7  3004     MOVLW 0x4
03A8  026F     SUBWF __pcstackBANK3, W
03A9  1C03     BTFSS 0x183, 0x0
03AA  2B5A     GOTO 0x35A
043C  0020     MOVLB 0x0
043D  01EF     CLRF USBDeviceTasks
043E  3004     MOVLW 0x4
043F  026F     SUBWF USBDeviceTasks, W
0440  1803     BTFSC STATUS, 0x0
0441  2C93     GOTO 0x493
0489  3001     MOVLW 0x1
048A  0021     MOVLB 0x1
048B  00A3     MOVWF 0xA3
048C  0823     MOVF 0xA3, W
048D  0020     MOVLB 0x0
048E  07EF     ADDWF USBDeviceTasks, F
048F  3004     MOVLW 0x4
0490  026F     SUBWF USBDeviceTasks, W
0491  1C03     BTFSS STATUS, 0x0
0492  2C42     GOTO 0x442
786:                   {						//utilization can be compromised, and the device won't be able to receive SETUP packets.
787:                       if(USBTransactionCompleteIF)
035A  003D     MOVLB 0x1D
035B  1D90     BTFSS UIR, 0x3
035C  2BAB     GOTO 0x3AB
0442  003D     MOVLB 0x1D
0443  1D90     BTFSS UIR, 0x3
0444  2C93     GOTO 0x493
788:                       {
789:                           //Save and extract USTAT register info.  Will use this info later.
790:                           USTATcopy.Val = U1STAT;
035D  080F     MOVF USTAT, W
035E  0024     MOVLB 0x4
035F  00D2     MOVWF 0x252
0360  0852     MOVF 0x252, W
0361  0023     MOVLB 0x3
0362  00ED     MOVWF USTATcopy
0445  080F     MOVF 0x18F, W
0446  0021     MOVLB 0x1
0447  00A3     MOVWF 0xA3
0448  0823     MOVF 0xA3, W
0449  0023     MOVLB 0x3
044A  00ED     MOVWF USTATcopy
791:                           endpoint_number = USBHALGetLastEndpoint(USTATcopy);
0363  0C6D     RRF USTATcopy, W
0364  0024     MOVLB 0x4
0365  00D2     MOVWF 0x252
0366  0CD2     RRF 0x252, F
0367  0C52     RRF 0x252, W
0368  390F     ANDLW 0xF
0369  00D3     MOVWF 0x253
036A  0853     MOVF 0x253, W
036B  0023     MOVLB 0x3
036C  00DE     MOVWF endpoint_number
044B  0C6D     RRF USTATcopy, W
044C  0021     MOVLB 0x1
044D  00A3     MOVWF 0xA3
044E  0CA3     RRF 0xA3, F
044F  0C23     RRF 0xA3, W
0450  390F     ANDLW 0xF
0451  00A4     MOVWF 0xA4
0452  0824     MOVF 0xA4, W
0453  0023     MOVLB 0x3
0454  00DE     MOVWF endpoint_number
792:           
793:                           USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
036D  30F7     MOVLW 0xF7
036E  0024     MOVLB 0x4
036F  00D2     MOVWF 0x252
0370  0852     MOVF 0x252, W
0371  003D     MOVLB 0x1D
0372  0590     ANDWF UIR, F
0455  30F7     MOVLW 0xF7
0456  0021     MOVLB 0x1
0457  00A3     MOVWF 0xA3
0458  0823     MOVF 0xA3, W
0459  003D     MOVLB 0x1D
045A  0590     ANDWF UIR, F
794:           
795:                           //Keep track of the hardware ping pong state for endpoints other
796:                           //than EP0, if ping pong buffering is enabled.
797:                           #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
798:                           if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
0373  0023     MOVLB 0x3
0374  196D     BTFSC USTATcopy, 0x2
0375  2B79     GOTO 0x379
045B  0023     MOVLB 0x3
045C  196D     BTFSC USTATcopy, 0x2
045D  2C61     GOTO 0x461
799:                           {
800:                               ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
0376  085E     MOVF endpoint_number, W
0377  3EC7     ADDLW 0xC7
0378  2B7C     GOTO 0x37C
045E  085E     MOVF endpoint_number, W
045F  3EC7     ADDLW 0xC7
0460  2C64     GOTO 0x464
801:                           }
802:                           else
803:                           {
804:                               ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
0379  0023     MOVLB 0x3
037A  085E     MOVF endpoint_number, W
037B  3ECA     ADDLW 0xCA
037C  0086     MOVWF 0x186
037D  3001     MOVLW 0x1
037E  0087     MOVWF 0x187
037F  0801     MOVF 0x181, W
0380  3901     ANDLW 0x1
0381  0024     MOVLB 0x4
0382  00D2     MOVWF 0x252
0383  3001     MOVLW 0x1
0384  06D2     XORWF 0x252, F
0385  0801     MOVF 0x201, W
0386  0652     XORWF 0x252, W
0387  39FE     ANDLW 0xFE
0388  0652     XORWF 0x252, W
0389  0081     MOVWF 0x201
0461  0023     MOVLB 0x3
0462  085E     MOVF endpoint_number, W
0463  3ECA     ADDLW 0xCA
0464  0086     MOVWF 0x186
0465  3001     MOVLW 0x1
0466  0087     MOVWF 0x187
0467  0801     MOVF 0x181, W
0468  3901     ANDLW 0x1
0469  0021     MOVLB 0x1
046A  00A3     MOVWF 0xA3
046B  3001     MOVLW 0x1
046C  06A3     XORWF 0xA3, F
046D  0801     MOVF 0x81, W
046E  0623     XORWF 0xA3, W
046F  39FE     ANDLW 0xFE
0470  0623     XORWF 0xA3, W
0471  0081     MOVWF 0x81
805:                           }
806:                           #endif
807:           
808:                           //USBCtrlEPService only services transactions over EP0.
809:                           //It ignores all other EP transactions.
810:                           if(endpoint_number == 0)
038A  0023     MOVLB 0x3
038B  085E     MOVF endpoint_number, W
038C  1D03     BTFSS 0x183, 0x2
038D  2B92     GOTO 0x392
0472  0023     MOVLB 0x3
0473  085E     MOVF endpoint_number, W
0474  1D03     BTFSS 0x183, 0x2
0475  2C7A     GOTO 0x47A
811:                           {
812:                               USBCtrlEPService();
038E  3196     MOVLP 0x16
038F  2628     CALL 0x628
0390  3182     MOVLP 0x2
0476  3195     MOVLP 0x15
0477  25CC     CALL 0x5CC
0478  3183     MOVLP 0x3
813:                           }
0391  2BA1     GOTO 0x3A1
0479  2C89     GOTO 0x489
814:                           else
815:                           {
816:                               USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (uint8_t*)&USTATcopy.Val, 0);
0392  3072     MOVLW 0x72
0393  0021     MOVLB 0x1
0394  00B4     MOVWF event
0395  3000     MOVLW 0x0
0396  00B5     MOVWF 0xB5
0397  30ED     MOVLW 0xED
0398  00B6     MOVWF pdata
0399  3001     MOVLW 0x1
039A  00B7     MOVWF numBytesRead
039B  3000     MOVLW 0x0
039C  00B8     MOVWF size
039D  00B9     MOVWF 0xB9
039E  3192     MOVLP 0x12
039F  2235     CALL 0x235
03A0  3182     MOVLP 0x2
047A  3072     MOVLW 0x72
047B  0020     MOVLB 0x0
047C  00E0     MOVWF __pcstackBANK0h
047D  3000     MOVLW 0x0
047E  00E1     MOVWF 0x61
047F  30ED     MOVLW 0xED
0480  00E2     MOVWF pdata
0481  3001     MOVLW 0x1
0482  00E3     MOVWF 0x63
0483  3000     MOVLW 0x0
0484  00E4     MOVWF size
0485  00E5     MOVWF 0x65
0486  3192     MOVLP 0x12
0487  2205     CALL 0x205
0488  3183     MOVLP 0x3
817:                           }
818:                       }//end if(USBTransactionCompleteIF)
819:                       else
820:                       {
821:                           break;	//USTAT FIFO must be empty.
822:                       }
823:                   }//end for()
824:               }//end if(USBTransactionCompleteIE)
825:           
826:               USBClearUSBInterrupt();
03AB  0020     MOVLB 0x0
03AC  1112     BCF PIR2, 0x2
0493  0020     MOVLB 0x0
0494  1112     BCF PIR2, 0x2
827:           }//end of USBDeviceTasks()
03AD  0008     RETURN
0495  0008     RETURN
828:           
829:           /*******************************************************************************
830:             Function:
831:                   void USBEnableEndpoint(uint8_t ep, uint8_t options)
832:               
833:             Summary:
834:               This function will enable the specified endpoint with the specified
835:               options
836:             Description:
837:               This function will enable the specified endpoint with the specified
838:               options.
839:               
840:               Typical Usage:
841:               <code>
842:               void USBCBInitEP(void)
843:               {
844:                   USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
845:                   USBMSDInit();
846:               }
847:               </code>
848:               
849:               In the above example endpoint number MSD_DATA_IN_EP is being configured
850:               for both IN and OUT traffic with handshaking enabled. Also since
851:               MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
852:               explicitly disable SETUP packets on this endpoint.
853:             Conditions:
854:               None
855:             Input:
856:               uint8_t ep -       the endpoint to be configured
857:               uint8_t options -  optional settings for the endpoint. The options should
858:                               be ORed together to form a single options string. The
859:                               available optional settings for the endpoint. The
860:                               options should be ORed together to form a single options
861:                               string. The available options are the following\:
862:                               * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
863:                                 NAK)
864:                               * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
865:                                 NAK)
866:                               * USB_OUT_ENABLED enables the out direction
867:                               * USB_OUT_DISABLED disables the out direction
868:                               * USB_IN_ENABLED enables the in direction
869:                               * USB_IN_DISABLED disables the in direction
870:                               * USB_ALLOW_SETUP enables control transfers
871:                               * USB_DISALLOW_SETUP disables control transfers
872:                               * USB_STALL_ENDPOINT STALLs this endpoint
873:             Return:
874:               None
875:             Remarks:
876:               None                                                                                                          
877:             *****************************************************************************/
878:           void USBEnableEndpoint(uint8_t ep, uint8_t options)
1157  00FC     MOVWF ep
11B7  0021     MOVLB 0x1
11B8  00B2     MOVWF i
879:           {
880:               unsigned char* p;
881:                   
882:               //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and 
883:               //starting DTS state in the BDT entry.
884:               if(options & USB_OUT_ENABLED)
1158  1D77     BTFSS 0xF7, 0x2
1159  295F     GOTO 0x15F
11B9  1D2D     BTFSS options, 0x2
11BA  29C0     GOTO 0x1C0
885:               {
886:                   USBConfigureEndpoint(ep, OUT_FROM_HOST);
115A  01F0     CLRF 0xF0
115B  087C     MOVF 0xFC, W
115C  3193     MOVLP 0x13
115D  2345     CALL 0x345
115E  3191     MOVLP 0x11
11BB  01A6     CLRF length
11BC  0832     MOVF i, W
11BD  3193     MOVLP 0x13
11BE  2387     CALL 0x387
11BF  3191     MOVLP 0x11
887:               }
888:               if(options & USB_IN_ENABLED)
115F  1CF7     BTFSS 0xF7, 0x1
1160  2966     GOTO 0x166
11C0  0021     MOVLB 0x1
11C1  1CAD     BTFSS options, 0x1
11C2  29C8     GOTO 0x1C8
889:               {
890:                   USBConfigureEndpoint(ep, IN_TO_HOST);
1161  01F0     CLRF 0xF0
1162  0AF0     INCF 0xF0, F
1163  087C     MOVF 0xFC, W
1164  3193     MOVLP 0x13
1165  2345     CALL 0x345
11C3  01A6     CLRF length
11C4  0AA6     INCF length, F
11C5  0832     MOVF i, W
11C6  3193     MOVLP 0x13
11C7  2387     CALL 0x387
891:               }
892:           
893:               //Update the relevant UEPx register to actually enable the endpoint with
894:               //the specified options (ex: handshaking enabled, control transfers allowed,
895:               //etc.)
896:               #if defined(__C32__)
897:                   p = (unsigned char*)(&U1EP0+(4*ep));
898:               #else
899:                   p = (unsigned char*)(&U1EP0+ep);
1166  087C     MOVF 0xFC, W
1167  3E98     ADDLW 0x98
1168  00F8     MOVWF 0xF8
1169  01F9     CLRF 0xF9
116A  300E     MOVLW 0xE
116B  3DF9     ADDWFC 0xF9, F
116C  0878     MOVF 0xF8, W
116D  00FA     MOVWF 0xFA
116E  0879     MOVF 0xF9, W
116F  00FB     MOVWF 0xFB
11C8  0021     MOVLB 0x1
11C9  0832     MOVF i, W
11CA  3E98     ADDLW 0x98
11CB  00AE     MOVWF ep
11CC  01AF     CLRF handle
11CD  300E     MOVLW 0xE
11CE  3DAF     ADDWFC handle, F
11CF  082E     MOVF ep, W
11D0  00B0     MOVWF p
11D1  082F     MOVF handle, W
11D2  00B1     MOVWF len
900:               #endif
901:               *p = options;
1170  087A     MOVF 0xFA, W
1171  0086     MOVWF 0x86
1172  087B     MOVF 0xFB, W
1173  0087     MOVWF 0x87
1174  0877     MOVF 0xF7, W
1175  0081     MOVWF 0x81
11D3  0830     MOVF p, W
11D4  0086     MOVWF 0x86
11D5  0831     MOVF len, W
11D6  0087     MOVWF 0x87
11D7  082D     MOVF options, W
11D8  0081     MOVWF 0x81
902:           }
1176  0008     RETURN
11D9  0008     RETURN
903:           
904:           
905:           /*************************************************************************
906:             Function:
907:               USB_HANDLE USBTransferOnePacket(uint8_t ep, uint8_t dir, uint8_t* data, uint8_t len)
908:               
909:             Summary:
910:               Transfers a single packet (one transaction) of data on the USB bus.
911:           
912:             Description:
913:               The USBTransferOnePacket() function prepares a USB endpoint
914:               so that it may send data to the host (an IN transaction), or 
915:               receive data from the host (an OUT transaction).  The 
916:               USBTransferOnePacket() function can be used both to receive	and 
917:               send data to the host.  This function is the primary API function 
918:               provided by the USB stack firmware for sending or receiving application 
919:               data over the USB port.  
920:           
921:               The USBTransferOnePacket() is intended for use with all application 
922:               endpoints.  It is not used for sending or receiving application data 
923:               through endpoint 0 by using control transfers.  Separate API 
924:               functions, such as USBEP0Receive(), USBEP0SendRAMPtr(), and
925:               USBEP0SendROMPtr() are provided for this purpose.
926:           
927:               The	USBTransferOnePacket() writes to the Buffer Descriptor Table (BDT)
928:               entry associated with an endpoint buffer, and sets the UOWN bit, which 
929:               prepares the USB hardware to allow the transaction to complete.  The 
930:               application firmware can use the USBHandleBusy() macro to check the 
931:               status of the transaction, to see if the data has been successfully 
932:               transmitted yet.
933:           
934:           
935:               Typical Usage
936:               <code>
937:               //make sure that the we are in the configured state
938:               if(USBGetDeviceState() == CONFIGURED_STATE)
939:               {
940:                   //make sure that the last transaction isn't busy by checking the handle
941:                   if(!USBHandleBusy(USBInHandle))
942:                   {
943:           	        //Write the new data that we wish to send to the host to the INPacket[] array
944:           	        INPacket[0] = USEFUL_APPLICATION_VALUE1;
945:           	        INPacket[1] = USEFUL_APPLICATION_VALUE2;
946:           	        //INPacket[2] = ... (fill in the rest of the packet data)
947:           	      
948:                       //Send the data contained in the INPacket[] array through endpoint "EP_NUM"
949:                       USBInHandle = USBTransferOnePacket(EP_NUM,IN_TO_HOST,(uint8_t*)&INPacket[0],sizeof(INPacket));
950:                   }
951:               }
952:               </code>
953:           
954:             Conditions:
955:               Before calling USBTransferOnePacket(), the following should be true.
956:               1.  The USB stack has already been initialized (USBDeviceInit() was called).
957:               2.  A transaction is not already pending on the specified endpoint.  This
958:                   is done by checking the previous request using the USBHandleBusy() 
959:                   macro (see the typical usage example).
960:               3.  The host has already sent a set configuration request and the 
961:                   enumeration process is complete.
962:                   This can be checked by verifying that the USBGetDeviceState() 
963:                   macro returns "CONFIGURED_STATE", prior to calling 
964:                   USBTransferOnePacket().
965:            					
966:             Input:
967:               uint8_t ep - The endpoint number that the data will be transmitted or
968:           	          received on
969:               uint8_t dir - The direction of the transfer
970:                          This value is either OUT_FROM_HOST or IN_TO_HOST
971:               uint8_t* data - For IN transactions: pointer to the RAM buffer containing
972:                            the data to be sent to the host.  For OUT transactions: pointer
973:                            to the RAM buffer that the received data should get written to.
974:              uint8_t len - Length of the data needing to be sent (for IN transactions).
975:                         For OUT transactions, the len parameter should normally be set
976:                         to the endpoint size specified in the endpoint descriptor.    
977:           
978:             Return Values:
979:               USB_HANDLE - handle to the transfer.  The handle is a pointer to 
980:                            the BDT entry associated with this transaction.  The
981:                            status of the transaction (ex: if it is complete or still
982:                            pending) can be checked using the USBHandleBusy() macro
983:                            and supplying the USB_HANDLE provided by
984:                            USBTransferOnePacket().
985:           
986:             Remarks:
987:               If calling the USBTransferOnePacket() function from within the USBCBInitEP()
988:               callback function, the set configuration is still being processed and the
989:               USBDeviceState may not be == CONFIGURED_STATE yet.  In this	special case, 
990:               the USBTransferOnePacket() may still be called, but make sure that the 
991:               endpoint has been enabled and initialized by the USBEnableEndpoint() 
992:               function first.  
993:               
994:             *************************************************************************/
995:           USB_HANDLE USBTransferOnePacket(uint8_t ep,uint8_t dir,uint8_t* data,uint8_t len)
0778  0021     MOVLB 0x1
0779  00AE     MOVWF ep
0C96  00F8     MOVWF 0xF8
996:           {
997:               volatile BDT_ENTRY* handle;
998:           
999:               //If the direction is IN
1000:              if(dir != 0)
077A  0826     MOVF length, W
077B  1903     BTFSC 0x83, 0x2
077C  2F86     GOTO 0x786
0C97  0870     MOVF 0xF0, W
0C98  1903     BTFSC 0x83, 0x2
0C99  2CA3     GOTO 0x4A3
1001:              {
1002:                  //point to the IN BDT of the specified endpoint
1003:                  handle = pBDTEntryIn[ep];
077D  352E     LSLF ep, W
077E  3EB7     ADDLW 0xB7
077F  0086     MOVWF 0x86
0780  3001     MOVLW 0x1
0781  0087     MOVWF 0x87
0782  3F40     MOVIW 0[FSR1]
0783  00AF     MOVWF handle
0784  3F41     MOVIW 1[FSR1]
0785  2F8E     GOTO 0x78E
0C9A  3578     LSLF 0xF8, W
0C9B  3EB7     ADDLW 0xB7
0C9C  0086     MOVWF 0x86
0C9D  3001     MOVLW 0x1
0C9E  0087     MOVWF 0x87
0C9F  3F40     MOVIW 0[FSR1]
0CA0  00F9     MOVWF 0xF9
0CA1  3F41     MOVIW 1[FSR1]
0CA2  2CAB     GOTO 0x4AB
1004:              }
1005:              else
1006:              {
1007:                  //else point to the OUT BDT of the specified endpoint
1008:                  handle = pBDTEntryOut[ep];
0786  352E     LSLF ep, W
0787  3EBD     ADDLW 0xBD
0788  0086     MOVWF 0x86
0789  3001     MOVLW 0x1
078A  0087     MOVWF 0x87
078B  3F40     MOVIW 0[FSR1]
078C  00AF     MOVWF handle
078D  3F41     MOVIW 1[FSR1]
078E  00B0     MOVWF p
0CA3  3578     LSLF 0xF8, W
0CA4  3EBD     ADDLW 0xBD
0CA5  0086     MOVWF 0x86
0CA6  3001     MOVLW 0x1
0CA7  0087     MOVWF 0x87
0CA8  3F40     MOVIW 0[FSR1]
0CA9  00F9     MOVWF 0xF9
0CAA  3F41     MOVIW 1[FSR1]
0CAB  00FA     MOVWF 0xFA
1009:              }
1010:              
1011:              //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
1012:              //pBDTEntryOut[ep]) is initialized before using it.
1013:              if(handle == 0)
078F  082F     MOVF handle, W
0790  0430     IORWF p, W
0791  1D03     BTFSS 0x83, 0x2
0792  2F96     GOTO 0x796
0CAC  0879     MOVF 0xF9, W
0CAD  047A     IORWF 0xFA, W
0CAE  1D03     BTFSS 0x83, 0x2
0CAF  2CB3     GOTO 0x4B3
1014:              {
1015:                  return 0;
0793  01A6     CLRF length
0794  01A7     CLRF p
0795  0008     RETURN
0CB0  01F0     CLRF 0xF0
0CB1  01F1     CLRF 0xF1
0CB2  0008     RETURN
1016:              }
1017:          
1018:              //Toggle the DTS bit if required
1019:              #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1020:                  handle->STAT.Val ^= _DTSMASK;
1021:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1022:                  if(ep != 0)
1023:                  {
1024:                      handle->STAT.Val ^= _DTSMASK;
1025:                  }
1026:              #endif
1027:          
1028:              //Set the data pointer, data length, and enable the endpoint
1029:              handle->ADR = ConvertToPhysicalAddress(data);
0796  30FF     MOVLW 0xFF
0797  0527     ANDWF p, W
0798  00AA     MOVWF i
0799  307F     MOVLW 0x7F
079A  0528     ANDWF data, W
079B  00AB     MOVWF EPNum
079C  082F     MOVF handle, W
079D  0086     MOVWF 0x86
079E  0830     MOVF p, W
079F  0087     MOVWF 0x87
07A0  3142     ADDFSR 1, 2
07A1  082A     MOVF i, W
07A2  3FC0     MOVWI 0[FSR1]
07A3  082B     MOVF EPNum, W
07A4  3FC1     MOVWI 1[FSR1]
0CB3  30FF     MOVLW 0xFF
0CB4  0571     ANDWF 0xF1, W
0CB5  00F4     MOVWF 0xF4
0CB6  307F     MOVLW 0x7F
0CB7  0572     ANDWF 0xF2, W
0CB8  00F5     MOVWF 0xF5
0CB9  0879     MOVF 0xF9, W
0CBA  0086     MOVWF 0x86
0CBB  087A     MOVF 0xFA, W
0CBC  0087     MOVWF 0x87
0CBD  3142     ADDFSR 1, 2
0CBE  0874     MOVF 0xF4, W
0CBF  3FC0     MOVWI 0[FSR1]
0CC0  0875     MOVF 0xF5, W
0CC1  3FC1     MOVWI 1[FSR1]
1030:              handle->CNT = len;
07A5  082F     MOVF handle, W
07A6  3E01     ADDLW 0x1
07A7  00AA     MOVWF i
07A8  3000     MOVLW 0x0
07A9  3D30     ADDWFC p, W
07AA  00AB     MOVWF EPNum
07AB  082A     MOVF i, W
07AC  0086     MOVWF 0x86
07AD  082B     MOVF EPNum, W
07AE  0087     MOVWF 0x87
07AF  0829     MOVF len, W
07B0  0081     MOVWF 0x81
0CC2  0879     MOVF 0xF9, W
0CC3  3E01     ADDLW 0x1
0CC4  00F4     MOVWF 0xF4
0CC5  3000     MOVLW 0x0
0CC6  3D7A     ADDWFC 0xFA, W
0CC7  00F5     MOVWF 0xF5
0CC8  0874     MOVF 0xF4, W
0CC9  0086     MOVWF 0x86
0CCA  0875     MOVF 0xF5, W
0CCB  0087     MOVWF 0x87
0CCC  0873     MOVF 0xF3, W
0CCD  0081     MOVWF 0x81
1031:              handle->STAT.Val &= _DTSMASK;
07B1  3040     MOVLW 0x40
07B2  00AA     MOVWF i
07B3  082F     MOVF handle, W
07B4  0086     MOVWF 0x86
07B5  0830     MOVF p, W
07B6  0087     MOVWF 0x87
07B7  082A     MOVF i, W
07B8  0581     ANDWF 0x81, F
0CCE  3040     MOVLW 0x40
0CCF  00F4     MOVWF 0xF4
0CD0  0879     MOVF 0xF9, W
0CD1  0086     MOVWF 0x86
0CD2  087A     MOVF 0xFA, W
0CD3  0087     MOVWF 0x87
0CD4  0874     MOVF 0xF4, W
0CD5  0581     ANDWF 0x81, F
1032:              handle->STAT.Val |= (_DTSEN & _DTS_CHECKING_ENABLED);
07B9  082F     MOVF handle, W
07BA  0086     MOVWF 0x86
07BB  0830     MOVF p, W
07BC  0087     MOVWF 0x87
07BD  1581     BSF 0x81, 0x3
0CD6  0879     MOVF 0xF9, W
0CD7  0086     MOVWF 0x86
0CD8  087A     MOVF 0xFA, W
0CD9  0087     MOVWF 0x87
0CDA  1581     BSF 0x81, 0x3
1033:              handle->STAT.Val |= _USIE;
07BE  082F     MOVF handle, W
07BF  0086     MOVWF 0x86
07C0  0830     MOVF p, W
07C1  0087     MOVWF 0x87
07C2  1781     BSF 0x81, 0x7
0CDB  0879     MOVF 0xF9, W
0CDC  0086     MOVWF 0x86
0CDD  087A     MOVF 0xFA, W
0CDE  0087     MOVWF 0x87
0CDF  1781     BSF 0x81, 0x7
1034:          
1035:              //Point to the next buffer for ping pong purposes.
1036:              if(dir != OUT_FROM_HOST)
07C3  0826     MOVF length, W
07C4  1903     BTFSC 0x83, 0x2
07C5  2FDF     GOTO 0x7DF
0CE0  0870     MOVF 0xF0, W
0CE1  1903     BTFSC 0x83, 0x2
0CE2  2CFC     GOTO 0x4FC
1037:              {
1038:                  //toggle over the to the next buffer for an IN endpoint
1039:                  pBDTEntryIn[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[ep]) ^ USB_NEXT_PING_PONG);
07C6  352E     LSLF ep, W
07C7  3EB7     ADDLW 0xB7
07C8  0086     MOVWF 0x86
07C9  3001     MOVLW 0x1
07CA  0087     MOVWF 0x87
07CB  3F40     MOVIW 0[FSR1]
07CC  00AA     MOVWF i
07CD  3F41     MOVIW 1[FSR1]
07CE  00AB     MOVWF EPNum
07CF  3004     MOVLW 0x4
07D0  062A     XORWF i, W
07D1  00AC     MOVWF handle
07D2  3000     MOVLW 0x0
07D3  062B     XORWF EPNum, W
07D4  00AD     MOVWF options
07D5  352E     LSLF ep, W
07D6  3EB7     ADDLW 0xB7
07D7  0086     MOVWF 0x86
07D8  3001     MOVLW 0x1
07D9  0087     MOVWF 0x87
07DA  082C     MOVF handle, W
07DB  3FC0     MOVWI 0[FSR1]
07DC  082D     MOVF options, W
07DD  3FC1     MOVWI 1[FSR1]
0CE3  3578     LSLF 0xF8, W
0CE4  3EB7     ADDLW 0xB7
0CE5  0086     MOVWF 0x86
0CE6  3001     MOVLW 0x1
0CE7  0087     MOVWF 0x87
0CE8  3F40     MOVIW 0[FSR1]
0CE9  00F4     MOVWF 0xF4
0CEA  3F41     MOVIW 1[FSR1]
0CEB  00F5     MOVWF 0xF5
0CEC  3004     MOVLW 0x4
0CED  0674     XORWF 0xF4, W
0CEE  00F6     MOVWF 0xF6
0CEF  3000     MOVLW 0x0
0CF0  0675     XORWF 0xF5, W
0CF1  00F7     MOVWF 0xF7
0CF2  3578     LSLF 0xF8, W
0CF3  3EB7     ADDLW 0xB7
0CF4  0086     MOVWF 0x86
0CF5  3001     MOVLW 0x1
0CF6  0087     MOVWF 0x87
0CF7  0876     MOVF 0xF6, W
0CF8  3FC0     MOVWI 0[FSR1]
0CF9  0877     MOVF 0xF7, W
0CFA  3FC1     MOVWI 1[FSR1]
1040:              }
07DE  2FF7     GOTO 0x7F7
0CFB  2D14     GOTO 0x514
1041:              else
1042:              {
1043:                  //toggle over the to the next buffer for an OUT endpoint
1044:                  pBDTEntryOut[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryOut[ep]) ^ USB_NEXT_PING_PONG);
07DF  352E     LSLF ep, W
07E0  3EBD     ADDLW 0xBD
07E1  0086     MOVWF 0x86
07E2  3001     MOVLW 0x1
07E3  0087     MOVWF 0x87
07E4  3F40     MOVIW 0[FSR1]
07E5  00AA     MOVWF i
07E6  3F41     MOVIW 1[FSR1]
07E7  00AB     MOVWF EPNum
07E8  3004     MOVLW 0x4
07E9  062A     XORWF i, W
07EA  00AC     MOVWF handle
07EB  3000     MOVLW 0x0
07EC  062B     XORWF EPNum, W
07ED  00AD     MOVWF options
07EE  352E     LSLF ep, W
07EF  3EBD     ADDLW 0xBD
07F0  0086     MOVWF 0x86
07F1  3001     MOVLW 0x1
07F2  0087     MOVWF 0x87
07F3  082C     MOVF handle, W
07F4  3FC0     MOVWI 0[FSR1]
07F5  082D     MOVF options, W
07F6  3FC1     MOVWI 1[FSR1]
0CFC  3578     LSLF 0xF8, W
0CFD  3EBD     ADDLW 0xBD
0CFE  0086     MOVWF 0x86
0CFF  3001     MOVLW 0x1
0D00  0087     MOVWF 0x87
0D01  3F40     MOVIW 0[FSR1]
0D02  00F4     MOVWF 0xF4
0D03  3F41     MOVIW 1[FSR1]
0D04  00F5     MOVWF 0xF5
0D05  3004     MOVLW 0x4
0D06  0674     XORWF 0xF4, W
0D07  00F6     MOVWF 0xF6
0D08  3000     MOVLW 0x0
0D09  0675     XORWF 0xF5, W
0D0A  00F7     MOVWF 0xF7
0D0B  3578     LSLF 0xF8, W
0D0C  3EBD     ADDLW 0xBD
0D0D  0086     MOVWF 0x86
0D0E  3001     MOVLW 0x1
0D0F  0087     MOVWF 0x87
0D10  0876     MOVF 0xF6, W
0D11  3FC0     MOVWI 0[FSR1]
0D12  0877     MOVF 0xF7, W
0D13  3FC1     MOVWI 1[FSR1]
1045:              }
1046:              return (USB_HANDLE)handle;
07F7  0830     MOVF p, W
0D14  087A     MOVF 0xFA, W
0D15  00F1     MOVWF 0xF1
0D16  0879     MOVF 0xF9, W
0D17  00F0     MOVWF 0xF0
0D18  0008     RETURN
1047:          }
1048:          
1049:          
1050:          /********************************************************************
1051:              Function:
1052:                  void USBStallEndpoint(uint8_t ep, uint8_t dir)
1053:                  
1054:              Summary:
1055:                   Configures the specified endpoint to send STALL to the host, the next
1056:                   time the host tries to access the endpoint.
1057:              
1058:              PreCondition:
1059:                  None
1060:                  
1061:              Parameters:
1062:                  uint8_t ep - The endpoint number that should be configured to send STALL.
1063:                  uint8_t dir - The direction of the endpoint to STALL, either
1064:                             IN_TO_HOST or OUT_FROM_HOST.
1065:                  
1066:              Return Values:
1067:                  None
1068:                  
1069:              Remarks:
1070:                  None
1071:          
1072:           *******************************************************************/
1073:          void USBStallEndpoint(uint8_t ep, uint8_t dir)
1074:          {
1075:              BDT_ENTRY *p;
1076:          
1077:              if(ep == 0)
1078:              {
1079:                  //For control endpoints (ex: EP0), we need to STALL both IN and OUT
1080:                  //endpoints.  EP0 OUT must also be prepared to receive the next SETUP 
1081:                  //packet that will arrive.
1082:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1083:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1084:                  pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
1085:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1086:                  pBDTEntryIn[0]->STAT.Val = _BSTALL; 
1087:                  pBDTEntryIn[0]->STAT.Val |= _USIE;
1088:                         
1089:              }
1090:              else
1091:              {
1092:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
1093:                  p->STAT.Val |= _BSTALL;
1094:                  p->STAT.Val |= _USIE;
1095:              
1096:                  //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1097:                  //then stall that entry as well
1098:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1099:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
1100:                  p->STAT.Val |= _BSTALL;
1101:                  p->STAT.Val |= _USIE;
1102:                  #endif
1103:              }
1104:          }
1105:          
1106:          /**************************************************************************
1107:              Function:
1108:                  void USBCancelIO(uint8_t endpoint)
1109:              
1110:              Description:
1111:                  This function cancels the transfers pending on the specified endpoint.
1112:                  This function can only be used after a SETUP packet is received and 
1113:                  before that setup packet is handled.  This is the time period in which
1114:                  the EVENT_EP0_REQUEST is thrown, before the event handler function
1115:                  returns to the stack.
1116:          
1117:              Precondition:
1118:            
1119:              Parameters:
1120:                  uint8_t endpoint - the endpoint number you wish to cancel the transfers for
1121:               
1122:              Return Values:
1123:                  None
1124:                  
1125:              Remarks:
1126:                  None
1127:                                                                    
1128:            **************************************************************************/
1129:          void USBCancelIO(uint8_t endpoint)
1130:          {
1131:              if(USBPacketDisable == 1)
1132:              {
1133:              	//The PKTDIS bit is currently set right now.  It is therefore "safe"
1134:              	//to mess with the BDT right now.
1135:              	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
1136:              	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
1137:              	
1138:              	//Need to do additional handling if ping-pong buffering is being used
1139:                  #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
1140:                  //Point to the next buffer for ping pong purposes.  UOWN getting cleared
1141:                  //(either due to SIE clearing it after a transaction, or the firmware
1142:                  //clearing it) makes hardware ping pong pointer advance.
1143:                  pBDTEntryIn[endpoint] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[endpoint]) ^ USB_NEXT_PING_PONG);
1144:                  
1145:              	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
1146:              	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
1147:                  #endif
1148:              }
1149:          }
1150:          
1151:          /**************************************************************************
1152:              Function:
1153:                  void USBDeviceDetach(void)
1154:             
1155:              Summary:
1156:                  This function configures the USB module to "soft detach" itself from
1157:                  the USB host.
1158:                  
1159:              Description:
1160:                  This function configures the USB module to perform a "soft detach"
1161:                  operation, by disabling the D+ (or D-) ~1.5k pull up resistor, which
1162:                  lets the host know the device is present and attached.  This will make
1163:                  the host think that the device has been unplugged.  This is potentially
1164:                  useful, as it allows the USB device to force the host to re-enumerate
1165:                  the device (on the firmware has re-enabled the USB module/pull up, by
1166:                  calling USBDeviceAttach(), to "soft re-attach" to the host).
1167:                  
1168:              Precondition:
1169:                  Should only be called when USB_INTERRUPT is defined.  See remarks
1170:                  section if USB_POLLING mode option is being used (usb_device_config.h option).
1171:          
1172:                  Additionally, this function should only be called from the main() loop 
1173:                  context.  Do not call this function from within an interrupt handler, as 
1174:                  this function may modify global interrupt enable bits and settings.
1175:                  
1176:              Parameters:
1177:                  None
1178:               
1179:              Return Values:
1180:                  None
1181:                  
1182:              Remarks:
1183:                  If the application firmware calls USBDeviceDetach(), it is strongly
1184:                  recommended that the firmware wait at least >= 80ms before calling
1185:                  USBDeviceAttach().  If the firmware performs a soft detach, and then
1186:                  re-attaches too soon (ex: after a few micro seconds for instance), some
1187:                  hosts may interpret this as an unexpected "glitch" rather than as a
1188:                  physical removal/re-attachment of the USB device.  In this case the host
1189:                  may simply ignore the event without re-enumerating the device.  To 
1190:                  ensure that the host properly detects and processes the device soft
1191:                  detach/re-attach, it is recommended to make sure the device remains 
1192:                  detached long enough to mimic a real human controlled USB 
1193:                  unplug/re-attach event (ex: after calling USBDeviceDetach(), do not
1194:                  call USBDeviceAttach() for at least 80+ms, preferably longer.
1195:                  
1196:                  Neither the USBDeviceDetach() or USBDeviceAttach() functions are blocking
1197:                  or take long to execute.  It is the application firmwares 
1198:                  responsibility for adding the 80+ms delay, when using these API 
1199:                  functions.
1200:                  
1201:                  Note: The Windows plug and play event handler processing is fairly 
1202:                  slow, especially in certain versions of Windows, and for certain USB
1203:                  device classes.  It has been observed that some device classes need to
1204:                  provide even more USB detach dwell interval (before calling 
1205:                  USBDeviceAttach()), in order to work correctly after re-enumeration.
1206:                  If the USB device is a CDC class device, it is recommended to wait
1207:                  at least 1.5 seconds or longer, before soft re-attaching to the host,
1208:                  to provide the plug and play event handler enough time to finish 
1209:                  processing the removal event, before the re-attach occurs.
1210:                  
1211:                  If the application is using the USB_POLLING mode option, then the 
1212:                  USBDeviceDetach() and USBDeviceAttach() functions are not available.  
1213:                  In this mode, the USB stack relies on the "#define USE_USB_BUS_SENSE_IO" 
1214:                  and "#define USB_BUS_SENSE" options in the 
1215:                  HardwareProfile ?? [platform name].h file. 
1216:          
1217:                  When using the USB_POLLING mode option, and the 
1218:                  "#define USE_USB_BUS_SENSE_IO" definition has been commented out, then 
1219:                  the USB stack assumes that it should always enable the USB module at 
1220:                  pretty much all times.  Basically, anytime the application firmware 
1221:                  calls USBDeviceTasks(), the firmware will automatically enable the USB 
1222:                  module.  This mode would typically be selected if the application was 
1223:                  designed to be a purely bus powered device.  In this case, the 
1224:                  application is powered from the +5V VBUS supply from the USB port, so 
1225:                  it is correct and sensible in this type of application to power up and 
1226:                  turn on the USB module, at anytime that the microcontroller is 
1227:                  powered (which implies the USB cable is attached and the host is also 
1228:                  powered).
1229:          
1230:                  In a self powered application, the USB stack is designed with the 
1231:                  intention that the user will enable the "#define USE_USB_BUS_SENSE_IO" 
1232:                  option in the HardwareProfile ?? [platform name].h file.  When this 
1233:                  option is defined, then the USBDeviceTasks() function will automatically 
1234:                  check the I/O pin port value of the designated pin (based on the 
1235:                  #define USB_BUS_SENSE option in the HardwareProfile ?? [platform name].h 
1236:                  file), every time the application calls USBDeviceTasks().  If the 
1237:                  USBDeviceTasks() function is executed and finds that the pin defined by 
1238:                  the #define USB_BUS_SENSE is in a logic low state, then it will 
1239:                  automatically disable the USB module and tri-state the D+ and D- pins.  
1240:                  If however the USBDeviceTasks() function is executed and finds the pin 
1241:                  defined by the #define USB_BUS_SENSE is in a logic high state, then it 
1242:                  will automatically enable the USB module, if it has not already been 
1243:                  enabled.        
1244:                                                                    
1245:            **************************************************************************/
1246:          #if defined(USB_INTERRUPT)
1247:          void USBDeviceDetach(void)
1248:          {
1249:              //If the interrupt option is selected then the customer is required
1250:              //  to notify the stack when the device is attached or removed from the
1251:              //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
1252:          #ifdef USB_SUPPORT_OTG
1253:              if (USB_BUS_SENSE != 1)
1254:          #endif
1255:              {
1256:                   // Disable module & detach from bus
1257:                   U1CON = 0;             
1258:          
1259:                   // Mask all USB interrupts              
1260:                   U1IE = 0;          
1261:          
1262:                   //Move to the detached state                  
1263:                   USBDeviceState = DETACHED_STATE;
1264:          
1265:                   #ifdef  USB_SUPPORT_OTG    
1266:                       //Disable D+ Pull-up
1267:                       U1OTGCONbits.DPPULUP = 0;
1268:          
1269:                       //Disable HNP
1270:                       USBOTGDisableHnp();
1271:          
1272:                       //Deactivate HNP
1273:                       USBOTGDeactivateHnp();
1274:                       
1275:                       //If ID Pin Changed State
1276:                       if (USBIDIF && USBIDIE)
1277:                       {  
1278:                           //Re-detect & Initialize
1279:                            USBOTGInitialize();
1280:          
1281:                            //Clear ID Interrupt Flag
1282:                            USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
1283:                       }
1284:                   #endif
1285:          
1286:                   #if defined __C30__ || defined __XC16__
1287:                       //USBClearInterruptFlag(U1OTGIR, 3); 
1288:                   #endif
1289:                      //return so that we don't go through the rest of 
1290:                      //the state machine
1291:                    return;
1292:              }
1293:          
1294:          #ifdef USB_SUPPORT_OTG
1295:              //If Session Is Started Then
1296:             else
1297:             {
1298:                  //If SRP Is Ready
1299:                  if (USBOTGSRPIsReady())
1300:                  {   
1301:                      //Clear SRPReady
1302:                      USBOTGClearSRPReady();
1303:          
1304:                      //Clear SRP Timeout Flag
1305:                      USBOTGClearSRPTimeOutFlag();
1306:          
1307:                      //Indicate Session Started
1308:                      UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
1309:                  }
1310:              }
1311:          #endif
1312:          }
1313:          #endif  //#if defined(USB_INTERRUPT)
1314:          /**************************************************************************
1315:              Function:
1316:                  void USBDeviceAttach(void)
1317:              
1318:              Summary:
1319:                  Checks if VBUS is present, and that the USB module is not already 
1320:                  initialized, and if so, enables the USB module so as to signal device 
1321:                  attachment to the USB host.   
1322:          
1323:              Description:
1324:                  This function indicates to the USB host that the USB device has been
1325:                  attached to the bus.  This function needs to be called in order for the
1326:                  device to start to enumerate on the bus.
1327:                          
1328:              Precondition:
1329:                  Should only be called when USB_INTERRUPT is defined.  Also, should only 
1330:                  be called from the main() loop context.  Do not call USBDeviceAttach()
1331:                  from within an interrupt handler, as the USBDeviceAttach() function
1332:                  may modify global interrupt enable bits and settings.
1333:          
1334:                  For normal USB devices:
1335:                  Make sure that if the module was previously on, that it has been turned off 
1336:                  for a long time (ex: 100ms+) before calling this function to re-enable the module.
1337:                  If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
1338:                  pull up resistor, and then turns it back on very quickly, common hosts will sometimes 
1339:                  reject this event, since no human could ever unplug and re-attach a USB device in a 
1340:                  microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind 
1341:                  of glitch and ignore the event altogether.  
1342:              Parameters:
1343:                  None
1344:               
1345:              Return Values:
1346:                  None       
1347:              
1348:              Remarks: 
1349:          		See also the USBDeviceDetach() API function documentation.                                                 
1350:          ****************************************************************************/
1351:          #if defined(USB_INTERRUPT)
1352:          void USBDeviceAttach(void)
1353:          {
1354:              //if we are in the detached state
1355:              if(USBDeviceState == DETACHED_STATE)
10FC  0023     MOVLB 0x3
10FD  0865     MOVF USBDeviceState, W
10FE  1D03     BTFSS 0x183, 0x2
10FF  0008     RETURN
1356:              {
1357:                  if(USB_BUS_SENSE == 1)
1358:                  {
1359:              	    //Initialize registers to known states.
1360:                      U1CON = 0;          
1100  003D     MOVLB 0x1D
1101  018E     CLRF UCON
1361:              
1362:                      // Mask all USB interrupts
1363:                      U1IE = 0;                                
1102  0192     CLRF UIE
1364:              
1365:                      //Configure things like: pull ups, full/low-speed mode, 
1366:                      //set the ping pong mode, and set internal transceiver
1367:                      SetConfigurationOptions();
1103  3016     MOVLW 0x16
1104  0091     MOVWF UCFG
1105  309F     MOVLW 0x9F
1106  0097     MOVWF UEIE
1107  307B     MOVLW 0x7B
1108  0092     MOVWF UIE
1368:              
1369:                      USBEnableInterrupts();  //Modifies global interrupt settings
1109  0021     MOVLB 0x1
110A  1512     BSF PIE2, 0x2
110B  170B     BSF 0x8B, 0x6
110C  178B     BSF 0x8B, 0x7
1370:              
1371:                      // Enable module & attach to bus
1372:                      while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
110D  003D     MOVLB 0x1D
110E  198E     BTFSC UCON, 0x3
110F  2912     GOTO 0x112
1110  158E     BSF UCON, 0x3
1111  290D     GOTO 0x10D
1373:              
1374:                      //moved to the attached state
1375:                      USBDeviceState = ATTACHED_STATE;
1112  3001     MOVLW 0x1
1113  0021     MOVLB 0x1
1114  00A6     MOVWF length
1115  0826     MOVF length, W
1116  0023     MOVLB 0x3
1117  00E5     MOVWF USBDeviceState
1376:              
1377:                      #ifdef  USB_SUPPORT_OTG
1378:                          U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
1379:                      #endif
1380:                  }
1118  0008     RETURN
1381:              }
1382:          }
1383:          #endif  //#if defined(USB_INTERRUPT)
1384:          
1385:          
1386:          /*******************************************************************************
1387:            Function: void USBCtrlEPAllowStatusStage(void);
1388:          
1389:            Summary: This function prepares the proper endpoint 0 IN or endpoint 0 OUT
1390:                      (based on the controlTransferState) to allow the status stage packet
1391:                      of a control transfer to complete.  This function gets used
1392:                      internally by the USB stack itself, but it may also be called from
1393:                      the application firmware, IF the application firmware called
1394:                      the USBDeferStatusStage() function during the initial processing
1395:                      of the control transfer request.  In this case, the application
1396:                      must call the USBCtrlEPAllowStatusStage() once, after it has fully
1397:                      completed processing and handling the data stage portion of the
1398:                      request.
1399:          
1400:                      If the application firmware has no need for delaying control
1401:                      transfers, and therefore never calls USBDeferStatusStage(), then the
1402:                      application firmware should not call USBCtrlEPAllowStatusStage().
1403:          
1404:            Description:
1405:          
1406:            Conditions:
1407:              None
1408:          
1409:            Input:
1410:          
1411:            Return:
1412:          
1413:            Remarks:
1414:              None
1415:            *****************************************************************************/
1416:          void USBCtrlEPAllowStatusStage(void)
1417:          {
1418:              //Check and set two flags, prior to actually modifying any BDT entries.
1419:              //This double checking is necessary to make certain that 
1420:              //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once 
1421:              //in main loop context, while simultaneously getting an interrupt which 
1422:              //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1423:              if(USBStatusStageEnabledFlag1 == false)
0953  0023     MOVLB 0x3
0B1E  0023     MOVLB 0x3
0B1F  085A     MOVF USBStatusStageEnabledFlag1, W
0B20  1D03     BTFSS 0x183, 0x2
0B21  0008     RETURN
1424:              {
1425:                  USBStatusStageEnabledFlag1 = true;
0957  3001     MOVLW 0x1
0958  00F0     MOVWF 0x1F0
0959  0870     MOVF 0x1F0, W
095A  00DA     MOVWF USBStatusStageEnabledFlag1
0B22  3001     MOVLW 0x1
0B23  0021     MOVLB 0x1
0B24  00A6     MOVWF length
0B25  0826     MOVF length, W
0B26  0023     MOVLB 0x3
0B27  00DA     MOVWF USBStatusStageEnabledFlag1
1426:                  if(USBStatusStageEnabledFlag2 == false)
095B  0859     MOVF USBStatusStageEnabledFlag2, W
095C  1D03     BTFSS 0x183, 0x2
095D  0008     RETURN
0B28  0859     MOVF USBStatusStageEnabledFlag2, W
0B29  1D03     BTFSS 0x183, 0x2
0B2A  0008     RETURN
1427:                  {
1428:                      USBStatusStageEnabledFlag2 = true;
095E  3001     MOVLW 0x1
095F  00F0     MOVWF 0x1F0
0960  0870     MOVF 0x1F0, W
0961  00D9     MOVWF USBStatusStageEnabledFlag2
0B2B  3001     MOVLW 0x1
0B2C  0021     MOVLB 0x1
0B2D  00A6     MOVWF length
0B2E  0826     MOVF length, W
0B2F  0023     MOVLB 0x3
0B30  00D9     MOVWF USBStatusStageEnabledFlag2
1429:                  
1430:                      //Determine which endpoints (EP0 IN or OUT needs arming for the status
1431:                      //stage), based on the type of control transfer currently pending.
1432:                      if(controlTransferState == CTRL_TRF_RX)
0962  3002     MOVLW 0x2
0963  0662     XORWF controlTransferState, W
0964  1D03     BTFSS 0x183, 0x2
0965  2978     GOTO 0x178
0B31  3002     MOVLW 0x2
0B32  0662     XORWF controlTransferState, W
0B33  1D03     BTFSS 0x183, 0x2
0B34  2B47     GOTO 0x347
1433:                      {
1434:                          pBDTEntryIn[0]->CNT = 0;
0966  0837     MOVF pBDTEntryIn, W
0967  0086     MOVWF 0x186
0968  0838     MOVF 0x1B8, W
0969  0087     MOVWF 0x187
096A  3141     ADDFSR 1, 1
096B  0181     CLRF 0x181
0B35  0837     MOVF pBDTEntryIn, W
0B36  0086     MOVWF 0x186
0B37  0838     MOVF 0x1B8, W
0B38  0087     MOVWF 0x187
0B39  3141     ADDFSR 1, 1
0B3A  0181     CLRF 0x181
1435:                          pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);        
096C  0837     MOVF pBDTEntryIn, W
096D  0086     MOVWF 0x186
096E  0838     MOVF 0x1B8, W
096F  0087     MOVWF 0x187
0970  3048     MOVLW 0x48
0971  0081     MOVWF 0x181
0B3B  0837     MOVF pBDTEntryIn, W
0B3C  0086     MOVWF 0x186
0B3D  0838     MOVF 0x1B8, W
0B3E  0087     MOVWF 0x187
0B3F  3048     MOVLW 0x48
0B40  0081     MOVWF 0x181
1436:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
0972  0837     MOVF pBDTEntryIn, W
0973  0086     MOVWF 0x186
0974  0838     MOVF 0x1B8, W
0975  0087     MOVWF 0x187
0976  1781     BSF 0x181, 0x7
0B41  0837     MOVF pBDTEntryIn, W
0B42  0086     MOVWF 0x186
0B43  0838     MOVF 0x1B8, W
0B44  0087     MOVWF 0x187
0B45  1781     BSF 0x181, 0x7
1437:                      }
0977  0008     RETURN
0B46  0008     RETURN
1438:                      else if(controlTransferState == CTRL_TRF_TX)
0978  0362     DECF controlTransferState, W
0979  1D03     BTFSS 0x183, 0x2
097A  0008     RETURN
0B47  0362     DECF controlTransferState, W
0B48  1D03     BTFSS 0x183, 0x2
0B49  0008     RETURN
1439:                      {
1440:                          BothEP0OutUOWNsSet = false;	//Indicator flag used in USBCtrlTrfOutHandler()
097B  01DD     CLRF BothEP0OutUOWNsSet
0B4A  01DD     CLRF BothEP0OutUOWNsSet
1441:          
1442:                          //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1443:                          //next SETUP packet.
1444:                          #if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1445:                              pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
097C  3008     MOVLW 0x8
097D  00F0     MOVWF 0x1F0
097E  0A64     INCF pBDTEntryEP0OutCurrent, W
097F  0086     MOVWF 0x186
0980  0187     CLRF 0x187
0981  0870     MOVF 0x1F0, W
0982  0081     MOVWF 0x181
0B4B  3008     MOVLW 0x8
0B4C  0021     MOVLB 0x1
0B4D  00A6     MOVWF length
0B4E  0023     MOVLB 0x3
0B4F  0A64     INCF pBDTEntryEP0OutCurrent, W
0B50  0086     MOVWF 0x186
0B51  0187     CLRF 0x187
0B52  0021     MOVLB 0x1
0B53  0826     MOVF length, W
0B54  0081     MOVWF 0x81
1446:                              pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
0983  3050     MOVLW 0x50
0984  00F0     MOVWF 0xF0
0985  3000     MOVLW 0x0
0986  00F1     MOVWF 0xF1
0987  0864     MOVF 0xE4, W
0988  3E02     ADDLW 0x2
0989  0086     MOVWF 0x86
098A  0187     CLRF 0x87
098B  0870     MOVF 0xF0, W
098C  3FC0     MOVWI 0[FSR1]
098D  0871     MOVF 0xF1, W
098E  3FC1     MOVWI 1[FSR1]
0B55  3050     MOVLW 0x50
0B56  00A6     MOVWF length
0B57  3000     MOVLW 0x0
0B58  00A7     MOVWF p
0B59  0023     MOVLB 0x3
0B5A  0864     MOVF pBDTEntryEP0OutCurrent, W
0B5B  3E02     ADDLW 0x2
0B5C  0086     MOVWF 0x186
0B5D  0187     CLRF 0x187
0B5E  0021     MOVLB 0x1
0B5F  0826     MOVF length, W
0B60  3FC0     MOVWI 0[FSR1]
0B61  0827     MOVF p, W
0B62  3FC1     MOVWI 1[FSR1]
1447:                              pBDTEntryEP0OutCurrent->STAT.Val = _BSTALL; //Prepare endpoint to accept a SETUP transaction
098F  3004     MOVLW 0x4
0990  00F0     MOVWF 0xF0
0991  0864     MOVF 0xE4, W
0992  0086     MOVWF 0x86
0993  0187     CLRF 0x87
0994  0870     MOVF 0xF0, W
0995  0081     MOVWF 0x81
0B63  3004     MOVLW 0x4
0B64  00A6     MOVWF length
0B65  0023     MOVLB 0x3
0B66  0864     MOVF pBDTEntryEP0OutCurrent, W
0B67  0086     MOVWF 0x186
0B68  0187     CLRF 0x187
0B69  0021     MOVLB 0x1
0B6A  0826     MOVF length, W
0B6B  0081     MOVWF 0x81
1448:                              pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
0996  0864     MOVF 0xE4, W
0997  0086     MOVWF 0x86
0998  0187     CLRF 0x87
0999  1781     BSF 0x81, 0x7
0B6C  0023     MOVLB 0x3
0B6D  0864     MOVF pBDTEntryEP0OutCurrent, W
0B6E  0086     MOVWF 0x186
0B6F  0187     CLRF 0x187
0B70  1781     BSF 0x181, 0x7
1449:                              BothEP0OutUOWNsSet = true;	//Indicator flag used in USBCtrlTrfOutHandler()
099A  3001     MOVLW 0x1
099B  00F0     MOVWF 0x1F0
099C  0870     MOVF 0x1F0, W
099D  00DD     MOVWF BothEP0OutUOWNsSet
0B71  3001     MOVLW 0x1
0B72  0021     MOVLB 0x1
0B73  00A6     MOVWF length
0B74  0826     MOVF length, W
0B75  0023     MOVLB 0x3
0B76  00DD     MOVWF BothEP0OutUOWNsSet
1450:                          #endif
1451:          
1452:                          //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1453:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
099E  0021     MOVLB 0x1
099F  0848     MOVF pBDTEntryEP0OutNext, W
09A0  3E01     ADDLW 0x1
09A1  00F0     MOVWF 0xF0
09A2  3000     MOVLW 0x0
09A3  3D49     ADDWFC 0xC9, W
09A4  00F1     MOVWF 0xF1
09A5  0870     MOVF 0xF0, W
09A6  0086     MOVWF 0x86
09A7  0871     MOVF 0xF1, W
09A8  0087     MOVWF 0x87
09A9  3008     MOVLW 0x8
09AA  0081     MOVWF 0x81
0B77  0021     MOVLB 0x1
0B78  0848     MOVF pBDTEntryEP0OutNext, W
0B79  3E01     ADDLW 0x1
0B7A  00A6     MOVWF length
0B7B  3000     MOVLW 0x0
0B7C  3D49     ADDWFC 0xC9, W
0B7D  00A7     MOVWF p
0B7E  0826     MOVF length, W
0B7F  0086     MOVWF 0x86
0B80  0827     MOVF p, W
0B81  0087     MOVWF 0x87
0B82  3008     MOVLW 0x8
0B83  0081     MOVWF 0x81
1454:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
09AB  3050     MOVLW 0x50
09AC  00F0     MOVWF 0xF0
09AD  3000     MOVLW 0x0
09AE  00F1     MOVWF 0xF1
09AF  0848     MOVF pBDTEntryEP0OutNext, W
09B0  0086     MOVWF 0x86
09B1  0849     MOVF 0xC9, W
09B2  0087     MOVWF 0x87
09B3  3142     ADDFSR 1, 2
09B4  0870     MOVF 0xF0, W
09B5  3FC0     MOVWI 0[FSR1]
09B6  0871     MOVF 0xF1, W
09B7  3FC1     MOVWI 1[FSR1]
0B84  3050     MOVLW 0x50
0B85  00A6     MOVWF length
0B86  3000     MOVLW 0x0
0B87  00A7     MOVWF p
0B88  0848     MOVF pBDTEntryEP0OutNext, W
0B89  0086     MOVWF 0x86
0B8A  0849     MOVF 0xC9, W
0B8B  0087     MOVWF 0x87
0B8C  3142     ADDFSR 1, 2
0B8D  0826     MOVF length, W
0B8E  3FC0     MOVWI 0[FSR1]
0B8F  0827     MOVF p, W
0B90  3FC1     MOVWI 1[FSR1]
1455:                          pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
09B8  0848     MOVF pBDTEntryEP0OutNext, W
09B9  0086     MOVWF 0x86
09BA  0849     MOVF 0xC9, W
09BB  0087     MOVWF 0x87
09BC  3080     MOVLW 0x80
09BD  0081     MOVWF 0x81
0B91  0848     MOVF pBDTEntryEP0OutNext, W
0B92  0086     MOVWF 0x86
0B93  0849     MOVF 0xC9, W
0B94  0087     MOVWF 0x87
0B95  3080     MOVLW 0x80
0B96  0081     MOVWF 0x81
1456:                      }
1457:                  }    
09BE  0008     RETURN
0B97  0008     RETURN
1458:              }
1459:          }   
1460:          
1461:          
1462:          /*******************************************************************************
1463:            Function: void USBCtrlEPAllowDataStage(void);
1464:              
1465:            Summary: This function allows the data stage of either a host-to-device or
1466:                      device-to-host control transfer (with data stage) to complete.
1467:                      This function is meant to be used in conjunction with either the
1468:                      USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1469:                      does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1470:                      then the firmware does not need to manually call 
1471:                      USBCtrlEPAllowDataStage(), as the USB stack will call this function
1472:                      instead.
1473:               
1474:            Description:
1475:              
1476:            Conditions: A control transfer (with data stage) should already be pending, 
1477:                          if the firmware calls this function.  Additionally, the firmware
1478:                          should have called either USBDeferOUTDataStage() or 
1479:                          USBDeferINDataStage() at the start of the control transfer, if
1480:                          the firmware will be calling this function manually.
1481:          
1482:            Input:
1483:          
1484:            Return:
1485:          
1486:            Remarks: 
1487:            *****************************************************************************/
1488:          void USBCtrlEPAllowDataStage(void)
1489:          {
1490:              USBDeferINDataStagePackets = false;
1570  0023     MOVLB 0x3
16E0  0023     MOVLB 0x3
16E1  01D8     CLRF USBDeferINDataStagePackets
1491:              USBDeferOUTDataStagePackets = false;
1572  01D7     CLRF USBDeferOUTDataStagePackets
16E2  01D7     CLRF USBDeferOUTDataStagePackets
1492:          
1493:              if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
1573  3002     MOVLW 0x2
1574  0662     XORWF controlTransferState, W
1575  1D03     BTFSS 0x183, 0x2
1576  2D9D     GOTO 0x59D
16E3  3002     MOVLW 0x2
16E4  0662     XORWF controlTransferState, W
16E5  1D03     BTFSS 0x183, 0x2
16E6  2F0D     GOTO 0x70D
1494:              {
1495:                  //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1496:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1577  0021     MOVLB 0x1
1578  0848     MOVF pBDTEntryEP0OutNext, W
1579  3E01     ADDLW 0x1
157A  00F3     MOVWF 0xF3
157B  3000     MOVLW 0x0
157C  3D49     ADDWFC 0xC9, W
157D  00F4     MOVWF 0xF4
157E  0873     MOVF 0xF3, W
157F  0086     MOVWF 0x86
1580  0874     MOVF 0xF4, W
1581  0087     MOVWF 0x87
1582  3008     MOVLW 0x8
1583  0081     MOVWF 0x81
16E7  0021     MOVLB 0x1
16E8  0848     MOVF pBDTEntryEP0OutNext, W
16E9  3E01     ADDLW 0x1
16EA  00A9     MOVWF len
16EB  3000     MOVLW 0x0
16EC  3D49     ADDWFC 0xC9, W
16ED  00AA     MOVWF i
16EE  0829     MOVF len, W
16EF  0086     MOVWF 0x86
16F0  082A     MOVF i, W
16F1  0087     MOVWF 0x87
16F2  3008     MOVLW 0x8
16F3  0081     MOVWF 0x81
1497:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
1584  3058     MOVLW 0x58
1585  00F3     MOVWF 0xF3
1586  3000     MOVLW 0x0
1587  00F4     MOVWF 0xF4
1588  0848     MOVF pBDTEntryEP0OutNext, W
1589  0086     MOVWF 0x86
158A  0849     MOVF 0xC9, W
158B  0087     MOVWF 0x87
158C  3142     ADDFSR 1, 2
158D  0873     MOVF 0xF3, W
158E  3FC0     MOVWI 0[FSR1]
158F  0874     MOVF 0xF4, W
1590  3FC1     MOVWI 1[FSR1]
16F4  3058     MOVLW 0x58
16F5  00A9     MOVWF len
16F6  3000     MOVLW 0x0
16F7  00AA     MOVWF i
16F8  0848     MOVF pBDTEntryEP0OutNext, W
16F9  0086     MOVWF 0x86
16FA  0849     MOVF 0xC9, W
16FB  0087     MOVWF 0x87
16FC  3142     ADDFSR 1, 2
16FD  0829     MOVF len, W
16FE  3FC0     MOVWI 0[FSR1]
16FF  082A     MOVF i, W
1700  3FC1     MOVWI 1[FSR1]
1498:                  pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
1591  0848     MOVF pBDTEntryEP0OutNext, W
1592  0086     MOVWF 0x86
1593  0849     MOVF 0xC9, W
1594  0087     MOVWF 0x87
1595  3048     MOVLW 0x48
1596  0081     MOVWF 0x81
1701  0848     MOVF pBDTEntryEP0OutNext, W
1702  0086     MOVWF 0x86
1703  0849     MOVF 0xC9, W
1704  0087     MOVWF 0x87
1705  3048     MOVLW 0x48
1706  0081     MOVWF 0x81
1499:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1597  0848     MOVF pBDTEntryEP0OutNext, W
1598  0086     MOVWF 0x86
1599  0849     MOVF 0xC9, W
159A  0087     MOVWF 0x87
159B  1781     BSF 0x81, 0x7
1707  0848     MOVF pBDTEntryEP0OutNext, W
1708  0086     MOVWF 0x86
1709  0849     MOVF 0xC9, W
170A  0087     MOVWF 0x87
170B  1781     BSF 0x81, 0x7
1500:              }   
159C  0008     RETURN
170C  0008     RETURN
1501:              else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
1502:              {
1503:                  //Error check the data stage byte count.  Make sure the user specified
1504:                  //value was no greater than the number of bytes the host requested.
1505:          		if(SetupPkt.wLength < inPipes[0].wCount.Val)
159D  0021     MOVLB 0x1
159E  0847     MOVF 0xC7, W
159F  0020     MOVLB 0x0
15A0  0257     SUBWF 0x57, W
15A1  1D03     BTFSS STATUS, 0x2
15A2  2DA7     GOTO 0x5A7
15A3  0021     MOVLB 0x1
15A4  0846     MOVF 0xC6, W
15A5  0020     MOVLB 0x0
15A6  0256     SUBWF 0x56, W
15A7  1803     BTFSC STATUS, 0x0
15A8  2DB0     GOTO 0x5B0
170D  0021     MOVLB 0x1
170E  0847     MOVF 0xC7, W
170F  0020     MOVLB 0x0
1710  0257     SUBWF 0x57, W
1711  1D03     BTFSS STATUS, 0x2
1712  2F17     GOTO 0x717
1713  0021     MOVLB 0x1
1714  0846     MOVF 0xC6, W
1715  0020     MOVLB 0x0
1716  0256     SUBWF 0x56, W
1717  1803     BTFSC STATUS, 0x0
1718  2F20     GOTO 0x720
1506:          		{
1507:          			inPipes[0].wCount.Val = SetupPkt.wLength;
15A9  0857     MOVF 0x57, W
15AA  0021     MOVLB 0x1
15AB  00C7     MOVWF 0xC7
15AC  0020     MOVLB 0x0
15AD  0856     MOVF 0x56, W
15AE  0021     MOVLB 0x1
15AF  00C6     MOVWF 0xC6
1719  0857     MOVF 0xD7, W
171A  0021     MOVLB 0x1
171B  00C7     MOVWF 0xC7
171C  0020     MOVLB 0x0
171D  0856     MOVF 0x56, W
171E  0021     MOVLB 0x1
171F  00C6     MOVWF 0xC6
1508:          		}
1509:          		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
15B0  318A     MOVLP 0xA
15B1  2230     CALL 0x230
1720  318A     MOVLP 0xA
1721  22A4     CALL 0x2A4
1510:          		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1511:          
1512:          	    //Cnt should have been initialized by responsible request owner (ex: by
1513:          	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1514:          		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
15B2  3058     MOVLW 0x58
15B3  00F3     MOVWF 0xF3
15B4  3000     MOVLW 0x0
15B5  00F4     MOVWF 0xF4
15B6  0023     MOVLB 0x3
15B7  0837     MOVF pBDTEntryIn, W
15B8  0086     MOVWF 0x186
15B9  0838     MOVF 0x1B8, W
15BA  0087     MOVWF 0x187
15BB  3142     ADDFSR 1, 2
15BC  0873     MOVF 0x1F3, W
15BD  3FC0     MOVWI 0[FSR1]
15BE  0874     MOVF 0x1F4, W
15BF  3FC1     MOVWI 1[FSR1]
1722  3058     MOVLW 0x58
1723  0021     MOVLB 0x1
1724  00A9     MOVWF len
1725  3000     MOVLW 0x0
1726  00AA     MOVWF i
1727  0023     MOVLB 0x3
1728  0837     MOVF pBDTEntryIn, W
1729  0086     MOVWF 0x186
172A  0838     MOVF 0x1B8, W
172B  0087     MOVWF 0x187
172C  3142     ADDFSR 1, 2
172D  0021     MOVLB 0x1
172E  0829     MOVF len, W
172F  3FC0     MOVWI 0[FSR1]
1730  082A     MOVF i, W
1731  3FC1     MOVWI 1[FSR1]
1515:          		pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
15C0  0837     MOVF numBytesRead, W
15C1  0086     MOVWF 0x86
15C2  0838     MOVF size, W
15C3  0087     MOVWF 0x87
15C4  3048     MOVLW 0x48
15C5  0081     MOVWF 0x81
1732  0023     MOVLB 0x3
1733  0837     MOVF pBDTEntryIn, W
1734  0086     MOVWF 0x186
1735  0838     MOVF 0x1B8, W
1736  0087     MOVWF 0x187
1737  3048     MOVLW 0x48
1738  0081     MOVWF 0x181
1516:                  pBDTEntryIn[0]->STAT.Val |= _USIE;
15C6  0837     MOVF pBDTEntryIn, W
15C7  0086     MOVWF 0x186
15C8  0838     MOVF 0x1B8, W
15C9  0087     MOVWF 0x187
15CA  1781     BSF 0x181, 0x7
15CB  0008     RETURN
1739  0837     MOVF pBDTEntryIn, W
173A  0086     MOVWF 0x186
173B  0838     MOVF 0x1B8, W
173C  0087     MOVWF 0x187
173D  1781     BSF 0x181, 0x7
173E  0008     RETURN
1517:              }     
1518:          }    
1519:          
1520:          
1521:          /******************************************************************************/
1522:          /** Internal Functions *********************************************************/
1523:          /******************************************************************************/
1524:          
1525:          /********************************************************************
1526:           * Function:        void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
1527:           *
1528:           * PreCondition:    None
1529:           *
1530:           * Input:           uint8_t EPNum - the endpoint to be configured
1531:           *                  uint8_t direction - the direction to be configured
1532:           *                                   (either OUT_FROM_HOST or IN_TO_HOST)
1533:           *
1534:           * Output:          None
1535:           *
1536:           * Side Effects:    None
1537:           *
1538:           * Overview:        This function will configure the specified 
1539:           *                  endpoint
1540:           *
1541:           * Note:            None
1542:           *******************************************************************/
1543:          static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
1345  00F5     MOVWF 0x1F5
1387  0021     MOVLB 0x1
1388  00AB     MOVWF EPNum
1544:          {
1545:              volatile BDT_ENTRY* handle;
1546:          
1547:              //Compute a pointer to the even BDT entry corresponding to the
1548:              //EPNum and direction values passed to this function.
1549:              handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
1346  3020     MOVLW 0x20
1347  00F1     MOVWF 0xF1
1348  0871     MOVF 0xF1, W
1349  00F6     MOVWF 0xF6
1389  3020     MOVLW 0x20
138A  00A7     MOVWF p
138B  0827     MOVF p, W
138C  00AC     MOVWF handle
1550:              handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
134A  0870     MOVF 0xF0, W
134B  00F1     MOVWF 0xF1
134C  3001     MOVLW 0x1
134D  35F1     LSLF 0xF1, F
134E  0B89     DECFSZ 0x89, F
134F  2B4D     GOTO 0x34D
1350  0875     MOVF 0xF5, W
1351  00F2     MOVWF 0xF2
1352  3001     MOVLW 0x1
1353  35F2     LSLF 0xF2, F
1354  3EFF     ADDLW 0xFF
1355  1D03     BTFSS 0x83, 0x2
1356  2B53     GOTO 0x353
1357  3572     LSLF 0xF2, W
1358  0771     ADDWF 0xF1, W
1359  00F3     MOVWF 0xF3
135A  3001     MOVLW 0x1
135B  35F3     LSLF 0xF3, F
135C  3EFF     ADDLW 0xFF
135D  1D03     BTFSS 0x83, 0x2
135E  2B5B     GOTO 0x35B
135F  3573     LSLF 0xF3, W
1360  00F4     MOVWF 0xF4
1361  0874     MOVF 0xF4, W
1362  07F6     ADDWF 0xF6, F
138D  0826     MOVF length, W
138E  00A7     MOVWF p
138F  3001     MOVLW 0x1
1390  35A7     LSLF p, F
1391  0B89     DECFSZ 0x89, F
1392  2B90     GOTO 0x390
1393  082B     MOVF EPNum, W
1394  00A8     MOVWF data
1395  3001     MOVLW 0x1
1396  35A8     LSLF data, F
1397  3EFF     ADDLW 0xFF
1398  1D03     BTFSS 0x83, 0x2
1399  2B96     GOTO 0x396
139A  3528     LSLF data, W
139B  0727     ADDWF p, W
139C  00A9     MOVWF len
139D  3001     MOVLW 0x1
139E  35A9     LSLF len, F
139F  3EFF     ADDLW 0xFF
13A0  1D03     BTFSS 0x83, 0x2
13A1  2B9E     GOTO 0x39E
13A2  3529     LSLF len, W
13A3  00AA     MOVWF i
13A4  082A     MOVF i, W
13A5  07AC     ADDWF handle, F
1551:              
1552:              handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler() 
1363  0876     MOVF 0xF6, W
1364  0086     MOVWF 0x86
1365  0187     CLRF 0x87
1366  1381     BCF 0x81, 0x7
13A6  082C     MOVF handle, W
13A7  0086     MOVWF 0x86
13A8  0187     CLRF 0x87
13A9  1381     BCF 0x81, 0x7
1553:              //already cleared the entire BDT table
1554:          
1555:              //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
1556:              //for USBTransferOnePacket() API calls.
1557:              if(direction == OUT_FROM_HOST)
1367  0870     MOVF 0xF0, W
1368  1D03     BTFSS 0x83, 0x2
1369  2B74     GOTO 0x374
13AA  0826     MOVF length, W
13AB  1D03     BTFSS 0x83, 0x2
13AC  2BB7     GOTO 0x3B7
1558:              {
1559:                  pBDTEntryOut[EPNum] = handle;
136A  3575     LSLF 0xF5, W
136B  3EBD     ADDLW 0xBD
136C  0086     MOVWF 0x86
136D  3001     MOVLW 0x1
136E  0087     MOVWF 0x87
136F  0876     MOVF 0xF6, W
1370  3FC0     MOVWI 0[FSR1]
1371  3000     MOVLW 0x0
1372  3FC1     MOVWI 1[FSR1]
13AD  352B     LSLF EPNum, W
13AE  3EBD     ADDLW 0xBD
13AF  0086     MOVWF 0x86
13B0  3001     MOVLW 0x1
13B1  0087     MOVWF 0x87
13B2  082C     MOVF handle, W
13B3  3FC0     MOVWI 0[FSR1]
13B4  3000     MOVLW 0x0
13B5  3FC1     MOVWI 1[FSR1]
1560:              }
1373  2B7D     GOTO 0x37D
13B6  2BC0     GOTO 0x3C0
1561:              else
1562:              {
1563:                  pBDTEntryIn[EPNum] = handle;
1374  3575     LSLF 0xF5, W
1375  3EB7     ADDLW 0xB7
1376  0086     MOVWF 0x86
1377  3001     MOVLW 0x1
1378  0087     MOVWF 0x87
1379  0876     MOVF 0xF6, W
137A  3FC0     MOVWI 0[FSR1]
137B  3000     MOVLW 0x0
137C  3FC1     MOVWI 1[FSR1]
13B7  352B     LSLF EPNum, W
13B8  3EB7     ADDLW 0xB7
13B9  0086     MOVWF 0x86
13BA  3001     MOVLW 0x1
13BB  0087     MOVWF 0x87
13BC  082C     MOVF handle, W
13BD  3FC0     MOVWI 0[FSR1]
13BE  3000     MOVLW 0x0
13BF  3FC1     MOVWI 1[FSR1]
1564:              }
1565:          
1566:              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1567:                  handle->STAT.DTS = 0;
137D  0876     MOVF 0xF6, W
137E  0086     MOVWF 0x86
137F  0187     CLRF 0x87
1380  1301     BCF 0x81, 0x6
13C0  082C     MOVF handle, W
13C1  0086     MOVWF 0x86
13C2  0187     CLRF 0x87
13C3  1301     BCF 0x81, 0x6
1568:                  (handle+1)->STAT.DTS = 1;
1381  0876     MOVF 0xF6, W
1382  3E04     ADDLW 0x4
1383  0086     MOVWF 0x86
1384  0187     CLRF 0x87
1385  1701     BSF 0x81, 0x6
13C4  082C     MOVF handle, W
13C5  3E04     ADDLW 0x4
13C6  0086     MOVWF 0x86
13C7  0187     CLRF 0x87
13C8  1701     BSF 0x81, 0x6
1569:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1570:                  //Set DTS to one because the first thing we will do
1571:                  //when transmitting is toggle the bit
1572:                  handle->STAT.DTS = 1;
1573:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1574:                  if(EPNum != 0)
1575:                  {
1576:                      handle->STAT.DTS = 1;
1577:                  }
1578:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)    
1579:                  if(EPNum != 0)
1580:                  {
1581:                      handle->STAT.DTS = 0;
1582:                      (handle+1)->STAT.DTS = 1;
1583:                  }
1584:              #endif
1585:          }
1386  0008     RETURN
13C9  0008     RETURN
1586:          
1587:          
1588:          /******************************************************************************
1589:           * Function:        void USBCtrlEPServiceComplete(void)
1590:           *
1591:           * PreCondition:    None
1592:           *
1593:           * Input:           None
1594:           *
1595:           * Output:          None
1596:           *
1597:           * Side Effects:    None
1598:           *
1599:           * Overview:        This routine wrap up the remaining tasks in servicing
1600:           *                  a Setup Request. Its main task is to set the endpoint
1601:           *                  controls appropriately for a given situation. See code
1602:           *                  below.
1603:           *                  There are three main scenarios:
1604:           *                  a) There was no handler for the Request, in this case
1605:           *                     a STALL should be sent out.
1606:           *                  b) The host has requested a read control transfer,
1607:           *                     endpoints are required to be setup in a specific way.
1608:           *                  c) The host has requested a write control transfer, or
1609:           *                     a control data stage is not required, endpoints are
1610:           *                     required to be setup in a specific way.
1611:           *
1612:           *                  Packet processing is resumed by clearing PKTDIS bit.
1613:           *
1614:           * Note:            None
1615:           *****************************************************************************/
1616:          static void USBCtrlEPServiceComplete(void)
1617:          {
1618:              /*
1619:               * PKTDIS bit is set when a Setup Transaction is received.
1620:               * Clear to resume packet processing.
1621:               */
1622:              USBPacketDisable = 0;
0E37  003D     MOVLB 0x1D
0EC8  003D     MOVLB 0x1D
0EC9  120E     BCF UCON, 0x4
1623:          
1624:          	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1625:          	//control transfer is currently in progress.  We need to know the type of control
1626:          	//transfer that is currently pending, in order to know how to properly arm the 
1627:          	//EP0 IN and EP0 OUT endpoints.
1628:              if(inPipes[0].info.bits.busy == 0)
0E39  0021     MOVLB 0x1
0E3A  1BC5     BTFSC 0xC5, 0x7
0E3B  2E7E     GOTO 0x67E
0ECA  0021     MOVLB 0x1
0ECB  1BC5     BTFSC 0xC5, 0x7
0ECC  2F11     GOTO 0x711
1629:              {
1630:                  if(outPipes[0].info.bits.busy == 1)
0E3C  0023     MOVLB 0x3
0E3D  1FB2     BTFSS 0x1B2, 0x7
0E3E  2E4C     GOTO 0x64C
0ECD  0023     MOVLB 0x3
0ECE  1FB2     BTFSS 0x1B2, 0x7
0ECF  2EDF     GOTO 0x6DF
1631:                  {
1632:                      controlTransferState = CTRL_TRF_RX;
0E3F  3002     MOVLW 0x2
0E40  00F5     MOVWF 0x1F5
0E41  0875     MOVF 0x1F5, W
0E42  00E2     MOVWF controlTransferState
0ED0  3002     MOVLW 0x2
0ED1  0021     MOVLB 0x1
0ED2  00AB     MOVWF EPNum
0ED3  082B     MOVF EPNum, W
0ED4  0023     MOVLB 0x3
0ED5  00E2     MOVWF controlTransferState
1633:                      /*
1634:                       * Control Write:
1635:                       * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1636:                       */
1637:          
1638:                      //1. Prepare OUT EP to receive data, unless a USB class request handler
1639:                      //   function decided to defer the data stage (ex: because the intended
1640:                      //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
1641:                      //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
1642:                      //   once it is ready to begin receiving the data.
1643:                      if(USBDeferOUTDataStagePackets == false)
0E43  0857     MOVF USBDeferOUTDataStagePackets, W
0E44  1D03     BTFSS 0x183, 0x2
0E45  2E48     GOTO 0x648
0ED6  0857     MOVF USBDeferOUTDataStagePackets, W
0ED7  1D03     BTFSS 0x183, 0x2
0ED8  2EDB     GOTO 0x6DB
1644:                      {
1645:                          USBCtrlEPAllowDataStage();
0E46  3195     MOVLP 0x15
0E47  2570     CALL 0x570
0ED9  3196     MOVLP 0x16
0EDA  26E0     CALL 0x6E0
1646:                      }
1647:                      
1648:                      //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage() 
1649:                      //after all of the OUT data has been received and consumed, or if a timeout occurs.
1650:                      USBStatusStageEnabledFlag2 = false;
0E48  0023     MOVLB 0x3
0E49  01D9     CLRF USBStatusStageEnabledFlag2
0EDB  0023     MOVLB 0x3
0EDC  01D9     CLRF USBStatusStageEnabledFlag2
1651:                      USBStatusStageEnabledFlag1 = false;
0E4A  01DA     CLRF USBStatusStageEnabledFlag1
0EDD  01DA     CLRF USBStatusStageEnabledFlag1
1652:                  }
0E4B  0008     RETURN
0EDE  0008     RETURN
1653:                  else
1654:                  {
1655:                      /*
1656:                       * If no one knows how to service this request then stall.
1657:                       * Must also prepare EP0 to receive the next SETUP transaction.
1658:                       */
1659:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0E4C  0021     MOVLB 0x1
0E4D  0848     MOVF pBDTEntryEP0OutNext, W
0E4E  3E01     ADDLW 0x1
0E4F  00F5     MOVWF 0xF5
0E50  3000     MOVLW 0x0
0E51  3D49     ADDWFC 0xC9, W
0E52  00F6     MOVWF 0xF6
0E53  0875     MOVF 0xF5, W
0E54  0086     MOVWF 0x86
0E55  0876     MOVF 0xF6, W
0E56  0087     MOVWF 0x87
0E57  3008     MOVLW 0x8
0E58  0081     MOVWF 0x81
0EDF  0021     MOVLB 0x1
0EE0  0848     MOVF pBDTEntryEP0OutNext, W
0EE1  3E01     ADDLW 0x1
0EE2  00AB     MOVWF EPNum
0EE3  3000     MOVLW 0x0
0EE4  3D49     ADDWFC 0xC9, W
0EE5  00AC     MOVWF handle
0EE6  082B     MOVF EPNum, W
0EE7  0086     MOVWF 0x86
0EE8  082C     MOVF handle, W
0EE9  0087     MOVWF 0x87
0EEA  3008     MOVLW 0x8
0EEB  0081     MOVWF 0x81
1660:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0E59  3050     MOVLW 0x50
0E5A  00F5     MOVWF 0xF5
0E5B  3000     MOVLW 0x0
0E5C  00F6     MOVWF 0xF6
0E5D  0848     MOVF pBDTEntryEP0OutNext, W
0E5E  0086     MOVWF 0x86
0E5F  0849     MOVF 0xC9, W
0E60  0087     MOVWF 0x87
0E61  3142     ADDFSR 1, 2
0E62  0875     MOVF 0xF5, W
0E63  3FC0     MOVWI 0[FSR1]
0E64  0876     MOVF 0xF6, W
0E65  3FC1     MOVWI 1[FSR1]
0EEC  3050     MOVLW 0x50
0EED  00AB     MOVWF EPNum
0EEE  3000     MOVLW 0x0
0EEF  00AC     MOVWF handle
0EF0  0848     MOVF pBDTEntryEP0OutNext, W
0EF1  0086     MOVWF 0x86
0EF2  0849     MOVF 0xC9, W
0EF3  0087     MOVWF 0x87
0EF4  3142     ADDFSR 1, 2
0EF5  082B     MOVF EPNum, W
0EF6  3FC0     MOVWI 0[FSR1]
0EF7  082C     MOVF handle, W
0EF8  3FC1     MOVWI 1[FSR1]
1661:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
0E66  0848     MOVF pBDTEntryEP0OutNext, W
0E67  0086     MOVWF 0x86
0E68  0849     MOVF 0xC9, W
0E69  0087     MOVWF 0x87
0E6A  300C     MOVLW 0xC
0E6B  0081     MOVWF 0x81
0EF9  0848     MOVF pBDTEntryEP0OutNext, W
0EFA  0086     MOVWF 0x86
0EFB  0849     MOVF 0xC9, W
0EFC  0087     MOVWF 0x87
0EFD  300C     MOVLW 0xC
0EFE  0081     MOVWF 0x81
1662:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0E6C  0848     MOVF pBDTEntryEP0OutNext, W
0E6D  0086     MOVWF 0x86
0E6E  0849     MOVF 0xC9, W
0E6F  0087     MOVWF 0x87
0E70  1781     BSF 0x81, 0x7
0EFF  0848     MOVF pBDTEntryEP0OutNext, W
0F00  0086     MOVWF 0x86
0F01  0849     MOVF 0xC9, W
0F02  0087     MOVWF 0x87
0F03  1781     BSF 0x81, 0x7
1663:                      pBDTEntryIn[0]->STAT.Val = _BSTALL;
0E71  0023     MOVLB 0x3
0E72  0837     MOVF pBDTEntryIn, W
0E73  0086     MOVWF 0x186
0E74  0838     MOVF 0x1B8, W
0E75  0087     MOVWF 0x187
0E76  3004     MOVLW 0x4
0E77  0081     MOVWF 0x181
0F04  0023     MOVLB 0x3
0F05  0837     MOVF pBDTEntryIn, W
0F06  0086     MOVWF 0x186
0F07  0838     MOVF 0x1B8, W
0F08  0087     MOVWF 0x187
0F09  3004     MOVLW 0x4
0F0A  0081     MOVWF 0x181
1664:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
0E78  0837     MOVF pBDTEntryIn, W
0E79  0086     MOVWF 0x186
0E7A  0838     MOVF 0x1B8, W
0E7B  0087     MOVWF 0x187
0E7C  1781     BSF 0x181, 0x7
0F0B  0837     MOVF pBDTEntryIn, W
0F0C  0086     MOVWF 0x186
0F0D  0838     MOVF 0x1B8, W
0F0E  0087     MOVWF 0x187
0F0F  1781     BSF 0x181, 0x7
1665:                  }
1666:              }
0E7D  0008     RETURN
0F10  0008     RETURN
1667:              else    // A module has claimed ownership of the control transfer session.
1668:              {
1669:          		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
0E7E  0020     MOVLB 0x0
0E7F  1FD0     BTFSS SetupPkt, 0x7
0E80  2E95     GOTO 0x695
0F11  0020     MOVLB 0x0
0F12  1FD0     BTFSS SetupPkt, 0x7
0F13  2F29     GOTO 0x729
1670:          		{
1671:          			controlTransferState = CTRL_TRF_TX;
0E81  3001     MOVLW 0x1
0E82  00F5     MOVWF EPNum
0E83  0875     MOVF EPNum, W
0E84  0023     MOVLB 0x3
0E85  00E2     MOVWF controlTransferState
0F14  3001     MOVLW 0x1
0F15  0021     MOVLB 0x1
0F16  00AB     MOVWF EPNum
0F17  082B     MOVF EPNum, W
0F18  0023     MOVLB 0x3
0F19  00E2     MOVWF controlTransferState
1672:          			/*
1673:          			 * Control Read:
1674:          			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1675:          			 *
1676:          			 * 1. Prepare IN EP to transfer data to the host.  If however the data
1677:          			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
1678:          			 *    some slow/currently unavailable resource, such as an external I2C EEPconst),
1679:          			 *    Then the class request handler responsible should call the USBDeferDataStage()
1680:          			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
1681:          			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
1682:          			 *    is ready to begin sending the data, it should then call the 
1683:          			 *    USBCtrlEPAllowDataStage() function to start the data stage.
1684:          			 */
1685:          			if(USBDeferINDataStagePackets == false)
0E86  0858     MOVF USBDeferINDataStagePackets, W
0E87  1D03     BTFSS 0x183, 0x2
0E88  2E8C     GOTO 0x68C
0F1A  0858     MOVF USBDeferINDataStagePackets, W
0F1B  1D03     BTFSS 0x183, 0x2
0F1C  2F20     GOTO 0x720
1686:                      {
1687:                          USBCtrlEPAllowDataStage();
0E89  3195     MOVLP 0x15
0E8A  2570     CALL 0x570
0E8B  318E     MOVLP 0xE
0F1D  3196     MOVLP 0x16
0F1E  26E0     CALL 0x6E0
0F1F  318E     MOVLP 0xE
1688:          			}
1689:          
1690:                      // 2. (Optionally) allow the status stage now, to prepare for early termination.
1691:                      //    Note: If a class request handler decided to set USBDeferStatusStagePacket == true,
1692:                      //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
1693:                      //    is ready.  If the class request handler does this, it needs to be careful to
1694:                      //    be written so that it can handle the early termination scenario.
1695:                      //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
1696:                      //    1.  The desired total number of bytes were sent to the host.
1697:                      //    2.  The number of bytes that the host originally requested (in the SETUP packet that 
1698:                      //        started the control transfer) has been reached.
1699:                      //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless 
1700:                      //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
1701:                      //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
1702:                      //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_device_config.h
1703:                      //        option can take care of this for you.
1704:                      //    Note: For this type of control transfer, there is normally no harm in simply arming the
1705:                      //    status stage packet right now, even if the IN data is not ready yet.  This allows for
1706:                      //    immediate early termination, without adding unnecessary delay.  Therefore, it is generally not
1707:                      //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this 
1708:                      //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
1709:                      //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
1710:                      USBStatusStageEnabledFlag2 = false;
0E8C  0023     MOVLB 0x3
0E8D  01D9     CLRF USBStatusStageEnabledFlag2
0F20  0023     MOVLB 0x3
0F21  01D9     CLRF USBStatusStageEnabledFlag2
1711:                      USBStatusStageEnabledFlag1 = false;
0E8E  01DA     CLRF USBStatusStageEnabledFlag1
0F22  01DA     CLRF USBStatusStageEnabledFlag1
1712:                      if(USBDeferStatusStagePacket == false)
0E8F  085B     MOVF USBDeferStatusStagePacket, W
0E90  1D03     BTFSS 0x183, 0x2
0E91  0008     RETURN
0F23  085B     MOVF USBDeferStatusStagePacket, W
0F24  1D03     BTFSS 0x183, 0x2
0F25  0008     RETURN
1713:                      {
1714:                          USBCtrlEPAllowStatusStage();
0E92  3189     MOVLP 0x9
0E93  2153     CALL 0x153
0F26  318B     MOVLP 0xB
0F27  231E     CALL 0x31E
1715:                      } 
1716:          		}
0E94  0008     RETURN
0F28  0008     RETURN
1717:          		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
1718:          		{
1719:          			//This situation occurs for special types of control transfers,
1720:          			//such as that which occurs when the host sends a SET_ADDRESS
1721:          			//control transfer.  Ex:
1722:          			//
1723:          			//<SETUP[0]><IN[1]> | <SETUP[0]>
1724:          				
1725:          			//Although the data direction is HOST_TO_DEVICE, there is no data stage
1726:          			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
1727:          			//an IN status stage.
1728:          
1729:          			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
0E95  3002     MOVLW 0x2
0E96  00F5     MOVWF 0x1F5
0E97  0875     MOVF 0x1F5, W
0E98  0023     MOVLB 0x3
0E99  00E2     MOVWF controlTransferState
0F29  3002     MOVLW 0x2
0F2A  0021     MOVLB 0x1
0F2B  00AB     MOVWF EPNum
0F2C  082B     MOVF EPNum, W
0F2D  0023     MOVLB 0x3
0F2E  00E2     MOVWF controlTransferState
1730:          			
1731:          			//1. Prepare OUT EP to receive the next SETUP packet.
1732:          			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0E9A  0021     MOVLB 0x1
0E9B  0848     MOVF pBDTEntryEP0OutNext, W
0E9C  3E01     ADDLW 0x1
0E9D  00F5     MOVWF 0xF5
0E9E  3000     MOVLW 0x0
0E9F  3D49     ADDWFC 0xC9, W
0EA0  00F6     MOVWF 0xF6
0EA1  0875     MOVF 0xF5, W
0EA2  0086     MOVWF 0x86
0EA3  0876     MOVF 0xF6, W
0EA4  0087     MOVWF 0x87
0EA5  3008     MOVLW 0x8
0EA6  0081     MOVWF 0x81
0F2F  0021     MOVLB 0x1
0F30  0848     MOVF pBDTEntryEP0OutNext, W
0F31  3E01     ADDLW 0x1
0F32  00AB     MOVWF EPNum
0F33  3000     MOVLW 0x0
0F34  3D49     ADDWFC 0xC9, W
0F35  00AC     MOVWF handle
0F36  082B     MOVF EPNum, W
0F37  0086     MOVWF 0x86
0F38  082C     MOVF handle, W
0F39  0087     MOVWF 0x87
0F3A  3008     MOVLW 0x8
0F3B  0081     MOVWF 0x81
1733:          			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0EA7  3050     MOVLW 0x50
0EA8  00F5     MOVWF 0xF5
0EA9  3000     MOVLW 0x0
0EAA  00F6     MOVWF 0xF6
0EAB  0848     MOVF pBDTEntryEP0OutNext, W
0EAC  0086     MOVWF 0x86
0EAD  0849     MOVF 0xC9, W
0EAE  0087     MOVWF 0x87
0EAF  3142     ADDFSR 1, 2
0EB0  0875     MOVF 0xF5, W
0EB1  3FC0     MOVWI 0[FSR1]
0EB2  0876     MOVF 0xF6, W
0EB3  3FC1     MOVWI 1[FSR1]
0F3C  3050     MOVLW 0x50
0F3D  00AB     MOVWF EPNum
0F3E  3000     MOVLW 0x0
0F3F  00AC     MOVWF handle
0F40  0848     MOVF pBDTEntryEP0OutNext, W
0F41  0086     MOVWF 0x86
0F42  0849     MOVF 0xC9, W
0F43  0087     MOVWF 0x87
0F44  3142     ADDFSR 1, 2
0F45  082B     MOVF EPNum, W
0F46  3FC0     MOVWI 0[FSR1]
0F47  082C     MOVF handle, W
0F48  3FC1     MOVWI 1[FSR1]
1734:          			pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
0EB4  0848     MOVF pBDTEntryEP0OutNext, W
0EB5  0086     MOVWF 0x86
0EB6  0849     MOVF 0xC9, W
0EB7  0087     MOVWF 0x87
0EB8  3004     MOVLW 0x4
0EB9  0081     MOVWF 0x81
0F49  0848     MOVF pBDTEntryEP0OutNext, W
0F4A  0086     MOVWF 0x86
0F4B  0849     MOVF 0xC9, W
0F4C  0087     MOVWF 0x87
0F4D  3004     MOVLW 0x4
0F4E  0081     MOVWF 0x81
1735:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0EBA  0848     MOVF pBDTEntryEP0OutNext, W
0EBB  0086     MOVWF 0x86
0EBC  0849     MOVF 0xC9, W
0EBD  0087     MOVWF 0x87
0EBE  1781     BSF 0x81, 0x7
0F4F  0848     MOVF pBDTEntryEP0OutNext, W
0F50  0086     MOVWF 0x86
0F51  0849     MOVF 0xC9, W
0F52  0087     MOVWF 0x87
0F53  1781     BSF 0x81, 0x7
1736:          				
1737:          			//2. Prepare for IN status stage of the control transfer
1738:                      USBStatusStageEnabledFlag2 = false;
0EBF  0023     MOVLB 0x3
0EC0  01D9     CLRF USBStatusStageEnabledFlag2
0F54  0023     MOVLB 0x3
0F55  01D9     CLRF USBStatusStageEnabledFlag2
1739:                      USBStatusStageEnabledFlag1 = false;
0EC1  01DA     CLRF USBStatusStageEnabledFlag1
0F56  01DA     CLRF USBStatusStageEnabledFlag1
1740:          			if(USBDeferStatusStagePacket == false)
0EC2  085B     MOVF USBDeferStatusStagePacket, W
0EC3  1D03     BTFSS 0x183, 0x2
0EC4  0008     RETURN
0F57  085B     MOVF USBDeferStatusStagePacket, W
0F58  1D03     BTFSS 0x183, 0x2
0F59  0008     RETURN
1741:                      {
1742:                          USBCtrlEPAllowStatusStage();
0EC5  3189     MOVLP 0x9
0EC6  2153     CALL 0x153
0F5A  318B     MOVLP 0xB
0F5B  231E     CALL 0x31E
1743:                      } 
1744:          		}
0EC7  0008     RETURN
0F5C  0008     RETURN
1745:          
1746:              }//end if(ctrl_trf_session_owner == MUID_NULL)
1747:          
1748:          }//end USBCtrlEPServiceComplete
1749:          
1750:          
1751:          /******************************************************************************
1752:           * Function:        void USBCtrlTrfTxService(void)
1753:           *
1754:           * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1755:           *
1756:           * Input:           None
1757:           *
1758:           * Output:          None
1759:           *
1760:           * Side Effects:    None
1761:           *
1762:           * Overview:        This routine is used for device to host control transfers 
1763:           *					(IN transactions).  This function takes care of managing a
1764:           *                  transfer over multiple USB transactions.
1765:           *					This routine should be called from only two places.
1766:           *                  One from USBCtrlEPServiceComplete() and one from
1767:           *                  USBCtrlTrfInHandler().
1768:           *
1769:           * Note:            
1770:           *****************************************************************************/
1771:          static void USBCtrlTrfTxService(void)
1772:          {
1773:              uint8_t byteToSend;
1774:          
1775:              //Figure out how many bytes of data to send in the next IN transaction.
1776:              //Assume a full size packet, unless otherwise determined below.
1777:              byteToSend = USB_EP0_BUFF_SIZE;         
0A30  3008     MOVLW 0x8
0AA4  3008     MOVLW 0x8
0AA5  0021     MOVLB 0x1
0AA6  00A6     MOVWF length
0AA7  0826     MOVF length, W
0AA8  00A8     MOVWF data
1778:              if(inPipes[0].wCount.Val < (uint8_t)USB_EP0_BUFF_SIZE)
0A34  3000     MOVLW 0x0
0A35  0021     MOVLB 0x1
0A36  0247     SUBWF 0xC7, W
0A37  3008     MOVLW 0x8
0A38  1903     BTFSC 0x83, 0x2
0A39  0246     SUBWF 0xC6, W
0A3A  1803     BTFSC 0x83, 0x0
0A3B  2A4D     GOTO 0x24D
0AA9  3000     MOVLW 0x0
0AAA  0247     SUBWF 0xC7, W
0AAB  3008     MOVLW 0x8
0AAC  1903     BTFSC 0x83, 0x2
0AAD  0246     SUBWF 0xC6, W
0AAE  1803     BTFSC 0x83, 0x0
0AAF  2AC3     GOTO 0x2C3
1779:              {
1780:                  byteToSend = inPipes[0].wCount.Val;
0A3C  0846     MOVF 0xC6, W
0A3D  00F0     MOVWF 0xF0
0A3E  0870     MOVF 0xF0, W
0A3F  00F2     MOVWF 0xF2
0AB0  0846     MOVF 0xC6, W
0AB1  00A6     MOVWF length
0AB2  0826     MOVF length, W
0AB3  00A8     MOVWF data
1781:          
1782:                  //Keep track of whether or not we have sent a "short packet" yet.
1783:                  //This is useful so that later on, we can configure EP0 IN to STALL,
1784:                  //after we have sent all of the intended data.  This makes sure the
1785:                  //hardware STALLs if the host erroneously tries to send more IN token 
1786:                  //packets, requesting more data than intended in the control transfer.
1787:                  if(shortPacketStatus == SHORT_PKT_NOT_USED)
0A40  0023     MOVLB 0x3
0A41  0863     MOVF shortPacketStatus, W
0A42  1D03     BTFSS 0x183, 0x2
0A43  2A46     GOTO 0x246
0AB4  0023     MOVLB 0x3
0AB5  0863     MOVF shortPacketStatus, W
0AB6  1D03     BTFSS 0x183, 0x2
0AB7  2ABA     GOTO 0x2BA
1788:                  {
1789:                      shortPacketStatus = SHORT_PKT_PENDING;
0A44  3001     MOVLW 0x1
0A45  2A4A     GOTO 0x24A
0AB8  3001     MOVLW 0x1
0AB9  2ABE     GOTO 0x2BE
1790:                  }
1791:                  else if(shortPacketStatus == SHORT_PKT_PENDING)
0A46  0363     DECF shortPacketStatus, W
0A47  1D03     BTFSS 0x183, 0x2
0A48  2A4D     GOTO 0x24D
0ABA  0363     DECF shortPacketStatus, W
0ABB  1D03     BTFSS 0x183, 0x2
0ABC  2AC3     GOTO 0x2C3
1792:                  {
1793:                      shortPacketStatus = SHORT_PKT_SENT;
0A49  3002     MOVLW 0x2
0A4A  00F0     MOVWF 0x1F0
0A4B  0870     MOVF 0x1F0, W
0A4C  00E3     MOVWF shortPacketStatus
0ABD  3002     MOVLW 0x2
0ABE  0021     MOVLB 0x1
0ABF  00A6     MOVWF length
0AC0  0826     MOVF length, W
0AC1  0023     MOVLB 0x3
0AC2  00E3     MOVWF shortPacketStatus
1794:                  }
1795:              }
1796:          
1797:              //Keep track of how many bytes remain to be sent in the transfer, by
1798:              //subtracting the number of bytes about to be sent from the total.
1799:              inPipes[0].wCount.Val -= byteToSend;
0A4D  0872     MOVF 0x1F2, W
0A4E  00F0     MOVWF 0x1F0
0A4F  01F1     CLRF 0x1F1
0A50  0870     MOVF 0x1F0, W
0A51  0021     MOVLB 0x1
0A52  02C6     SUBWF 0xC6, F
0A53  0871     MOVF 0xF1, W
0A54  3BC7     SUBWFB 0xC7, F
0AC3  0021     MOVLB 0x1
0AC4  0828     MOVF data, W
0AC5  00A6     MOVWF length
0AC6  01A7     CLRF p
0AC7  0826     MOVF length, W
0AC8  02C6     SUBWF 0xC6, F
0AC9  0827     MOVF p, W
0ACA  3BC7     SUBWFB 0xC7, F
1800:              
1801:              //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
1802:              //Note: Control endpoints may never have a max packet size of > 64 bytes.
1803:              //Therefore, the BC8 and BC9 bits should always be maintained clear.
1804:              pBDTEntryIn[0]->CNT = byteToSend;
0A55  0023     MOVLB 0x3
0A56  0837     MOVF pBDTEntryIn, W
0A57  3E01     ADDLW 0x1
0A58  00F0     MOVWF 0x1F0
0A59  3000     MOVLW 0x0
0A5A  3D38     ADDWFC 0x1B8, W
0A5B  00F1     MOVWF 0x1F1
0A5C  0870     MOVF 0x1F0, W
0A5D  0086     MOVWF 0x186
0A5E  0871     MOVF 0x1F1, W
0A5F  0087     MOVWF 0x187
0A60  0872     MOVF 0x1F2, W
0A61  0081     MOVWF 0x181
0ACB  0023     MOVLB 0x3
0ACC  0837     MOVF pBDTEntryIn, W
0ACD  3E01     ADDLW 0x1
0ACE  0021     MOVLB 0x1
0ACF  00A6     MOVWF length
0AD0  3000     MOVLW 0x0
0AD1  0023     MOVLB 0x3
0AD2  3D38     ADDWFC 0x1B8, W
0AD3  0021     MOVLB 0x1
0AD4  00A7     MOVWF p
0AD5  0826     MOVF length, W
0AD6  0086     MOVWF 0x86
0AD7  0827     MOVF p, W
0AD8  0087     MOVWF 0x87
0AD9  0828     MOVF data, W
0ADA  0081     MOVWF 0x81
1805:          
1806:              //Now copy the data from the source location, to the CtrlTrfData[] buffer,
1807:              //which we will send to the host.
1808:              pDst = (USB_VOLATILE uint8_t*)CtrlTrfData;                // Set destination pointer
0A62  3058     MOVLW 0x58
0A63  00F0     MOVWF 0xF0
0A64  0870     MOVF 0xF0, W
0A65  00E1     MOVWF 0xE1
0ADB  3058     MOVLW 0x58
0ADC  00A6     MOVWF length
0ADD  0826     MOVF length, W
0ADE  0023     MOVLB 0x3
0ADF  00E1     MOVWF pDst
1809:              if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
0A66  0021     MOVLB 0x1
0A67  1C45     BTFSS 0xC5, 0x0
0A68  2A83     GOTO 0x283
0A69  2AA0     GOTO 0x2A0
0AE0  0021     MOVLB 0x1
0AE1  1C45     BTFSS 0xC5, 0x0
0AE2  2AFD     GOTO 0x2FD
0AE3  2B1A     GOTO 0x31A
1810:              {
1811:                  while(byteToSend)
0A83  0872     MOVF 0xF2, W
0A84  1903     BTFSC 0x83, 0x2
0A85  0008     RETURN
0A86  2A6A     GOTO 0x26A
0AFD  0828     MOVF data, W
0AFE  1903     BTFSC 0x83, 0x2
0AFF  0008     RETURN
0B00  2AE4     GOTO 0x2E4
1812:                  {
1813:                      *pDst++ = *inPipes[0].pSrc.bRom++;
0A6A  0021     MOVLB 0x1
0A6B  0843     MOVF inPipes, W
0A6C  0084     MOVWF 0x84
0A6D  0844     MOVF 0xC4, W
0A6E  0085     MOVWF 0x85
0A6F  0800     MOVF 0x80, W
0A70  00F0     MOVWF 0xF0
0A71  0023     MOVLB 0x3
0A72  0861     MOVF pDst, W
0A73  0086     MOVWF 0x186
0A74  0187     CLRF 0x187
0A75  0870     MOVF 0x1F0, W
0A76  0081     MOVWF 0x181
0A77  3001     MOVLW 0x1
0A78  0021     MOVLB 0x1
0A79  07C3     ADDWF inPipes, F
0A7A  3000     MOVLW 0x0
0A7B  3DC4     ADDWFC 0xC4, F
0A7C  3001     MOVLW 0x1
0A7D  00F0     MOVWF 0xF0
0A7E  0870     MOVF 0xF0, W
0A7F  0023     MOVLB 0x3
0A80  07E1     ADDWF pDst, F
0AE4  0843     MOVF USB1msTickCount, W
0AE5  0084     MOVWF 0x184
0AE6  0844     MOVF 0x1C4, W
0AE7  0085     MOVWF 0x185
0AE8  0800     MOVF 0x180, W
0AE9  00A6     MOVWF 0x1A6
0AEA  0023     MOVLB 0x3
0AEB  0861     MOVF pDst, W
0AEC  0086     MOVWF 0x186
0AED  0187     CLRF 0x187
0AEE  0021     MOVLB 0x1
0AEF  0826     MOVF length, W
0AF0  0081     MOVWF 0x81
0AF1  3001     MOVLW 0x1
0AF2  07C3     ADDWF inPipes, F
0AF3  3000     MOVLW 0x0
0AF4  3DC4     ADDWFC 0xC4, F
0AF5  3001     MOVLW 0x1
0AF6  00A6     MOVWF length
0AF7  0826     MOVF length, W
0AF8  0023     MOVLB 0x3
0AF9  07E1     ADDWF pDst, F
1814:                      byteToSend--;
0A81  3001     MOVLW 0x1
0A82  02F2     SUBWF 0x1F2, F
0AFA  3001     MOVLW 0x1
0AFB  0021     MOVLB 0x1
0AFC  02A8     SUBWF data, F
1815:                  }//end while(byte_to_send.Val)
1816:              }
1817:              else  // RAM
1818:              {
1819:                  while(byteToSend)
0AA0  0872     MOVF 0xF2, W
0AA1  1903     BTFSC 0x83, 0x2
0AA2  0008     RETURN
0AA3  2A87     GOTO 0x287
0B1A  0828     MOVF data, W
0B1B  1903     BTFSC 0x83, 0x2
0B1C  0008     RETURN
0B1D  2B01     GOTO 0x301
1820:                  {
1821:                      *pDst++ = *inPipes[0].pSrc.bRam++;
0A87  0021     MOVLB 0x1
0A88  0843     MOVF inPipes, W
0A89  0084     MOVWF 0x84
0A8A  0844     MOVF 0xC4, W
0A8B  0085     MOVWF 0x85
0A8C  0800     MOVF 0x80, W
0A8D  00F0     MOVWF 0xF0
0A8E  0023     MOVLB 0x3
0A8F  0861     MOVF pDst, W
0A90  0086     MOVWF 0x186
0A91  0187     CLRF 0x187
0A92  0870     MOVF 0x1F0, W
0A93  0081     MOVWF 0x181
0A94  3001     MOVLW 0x1
0A95  0021     MOVLB 0x1
0A96  07C3     ADDWF inPipes, F
0A97  3000     MOVLW 0x0
0A98  3DC4     ADDWFC 0xC4, F
0A99  3001     MOVLW 0x1
0A9A  00F0     MOVWF 0xF0
0A9B  0870     MOVF 0xF0, W
0A9C  0023     MOVLB 0x3
0A9D  07E1     ADDWF pDst, F
0B01  0843     MOVF USB1msTickCount, W
0B02  0084     MOVWF 0x184
0B03  0844     MOVF 0x1C4, W
0B04  0085     MOVWF 0x185
0B05  0800     MOVF 0x180, W
0B06  00A6     MOVWF 0x1A6
0B07  0023     MOVLB 0x3
0B08  0861     MOVF pDst, W
0B09  0086     MOVWF 0x186
0B0A  0187     CLRF 0x187
0B0B  0021     MOVLB 0x1
0B0C  0826     MOVF length, W
0B0D  0081     MOVWF 0x81
0B0E  3001     MOVLW 0x1
0B0F  07C3     ADDWF inPipes, F
0B10  3000     MOVLW 0x0
0B11  3DC4     ADDWFC 0xC4, F
0B12  3001     MOVLW 0x1
0B13  00A6     MOVWF length
0B14  0826     MOVF length, W
0B15  0023     MOVLB 0x3
0B16  07E1     ADDWF pDst, F
1822:                      byteToSend--;
0A9E  3001     MOVLW 0x1
0A9F  02F2     SUBWF 0x1F2, F
0B17  3001     MOVLW 0x1
0B18  0021     MOVLB 0x1
0B19  02A8     SUBWF data, F
0B1A  0828     MOVF data, W
0B1B  1903     BTFSC 0x83, 0x2
0B1C  0008     RETURN
0B1D  2B01     GOTO 0x301
1823:                  }//end while(byte_to_send.Val)
1824:              }//end if(usb_stat.ctrl_trf_mem == _const)
1825:          }//end USBCtrlTrfTxService
1826:          
1827:          /******************************************************************************
1828:           * Function:        void USBCtrlTrfRxService(void)
1829:           *
1830:           * PreCondition:    pDst and wCount are setup properly.
1831:           *                  pSrc is always &CtrlTrfData
1832:           *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
1833:           *                  wCount should be set to 0 at the start of each control
1834:           *                  transfer.
1835:           *
1836:           * Input:           None
1837:           *
1838:           * Output:          None
1839:           *
1840:           * Side Effects:    None
1841:           *
1842:           * Overview:        This routine is used for host to device control transfers
1843:           *					(uses OUT transactions).  This function receives the data that arrives
1844:           *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
1845:           *					buffer.  Once the host has sent all the data it was intending
1846:           *					to send, this function will call the appropriate outPipes[0].pFunc()
1847:           *					handler (unless it is NULL), so that it can be used by the
1848:           *					intended target firmware.
1849:           *
1850:           * Note:            None
1851:           *****************************************************************************/
1852:          static void USBCtrlTrfRxService(void)
1853:          {
1854:              uint8_t byteToRead;
1855:              uint8_t i;
1856:          
1857:              //Load byteToRead with the number of bytes the host just sent us in the 
1858:              //last OUT transaction.
1859:              byteToRead = pBDTEntryEP0OutCurrent->CNT;   
0619  0023     MOVLB 0x3
061A  0864     MOVF pBDTEntryEP0OutCurrent, W
061B  0086     MOVWF 0x186
061C  0187     CLRF 0x187
061D  3F41     MOVIW 1[FSR1]
061E  0021     MOVLB 0x1
061F  00AB     MOVWF EPNum
0F5D  0023     MOVLB 0x3
1860:          
1861:              //Update the "outPipes[0].wCount.Val", which keeps track of the total number
1862:              //of remaining bytes expected to be received from the host, in the control
1863:              //transfer.  First check to see if the host sent us more bytes than the
1864:              //application firmware was expecting to receive.
1865:              if(byteToRead > outPipes[0].wCount.Val)
0620  082B     MOVF 0x1AB, W
0621  00A8     MOVWF 0x1A8
0622  01A9     CLRF 0x1A9
0623  0829     MOVF 0x1A9, W
0624  0023     MOVLB 0x3
0625  0234     SUBWF 0x1B4, W
0626  1D03     BTFSS 0x183, 0x2
0627  2E2C     GOTO 0x62C
0628  0021     MOVLB 0x1
0629  0828     MOVF data, W
062A  0023     MOVLB 0x3
062B  0233     SUBWF 0x1B3, W
062C  1803     BTFSC 0x183, 0x0
062D  2E33     GOTO 0x633
0F63  0875     MOVF 0x1F5, W
0F64  00F2     MOVWF 0x1F2
0F65  01F3     CLRF 0x1F3
0F66  0873     MOVF 0x1F3, W
0F67  0234     SUBWF 0x1B4, W
0F68  1D03     BTFSS 0x183, 0x2
0F69  2F6C     GOTO 0x76C
0F6A  0872     MOVF 0x1F2, W
0F6B  0233     SUBWF 0x1B3, W
0F6C  1803     BTFSC 0x183, 0x0
0F6D  2F72     GOTO 0x772
1866:              {
1867:                  byteToRead = outPipes[0].wCount.Val;
062E  0833     MOVF 0x1B3, W
062F  0021     MOVLB 0x1
0630  00A8     MOVWF data
0631  0828     MOVF data, W
0632  00AB     MOVWF EPNum
0F6E  0833     MOVF byte_to_send, W
0F6F  00F2     MOVWF 0xF2
0F70  0872     MOVF 0xF2, W
0F71  00F5     MOVWF 0xF5
1868:              }	
1869:              //Reduce the number of remaining bytes by the number we just received.
1870:              outPipes[0].wCount.Val -= byteToRead;
0633  0021     MOVLB 0x1
0634  082B     MOVF EPNum, W
0635  00A8     MOVWF data
0636  01A9     CLRF len
0637  0828     MOVF data, W
0638  0023     MOVLB 0x3
0639  02B3     SUBWF 0x1B3, F
063A  0021     MOVLB 0x1
063B  0829     MOVF len, W
063C  0023     MOVLB 0x3
063D  3BB4     SUBWFB 0x1B4, F
0F72  0875     MOVF 0x1F5, W
0F73  00F2     MOVWF 0x1F2
0F74  01F3     CLRF 0x1F3
0F75  0872     MOVF 0x1F2, W
0F76  02B3     SUBWF 0x1B3, F
0F77  0873     MOVF 0x1F3, W
0F78  3BB4     SUBWFB 0x1B4, F
1871:          
1872:              //Copy the OUT DATAx packet bytes that we just received from the host,
1873:              //into the user application buffer space.
1874:              for(i=0;i<byteToRead;i++)
063E  0021     MOVLB 0x1
063F  01AA     CLRF i
0640  082B     MOVF EPNum, W
0641  022A     SUBWF i, W
0642  1803     BTFSC 0x83, 0x0
0643  2E5D     GOTO 0x65D
0657  3001     MOVLW 0x1
0658  0021     MOVLB 0x1
0659  00A8     MOVWF data
065A  0828     MOVF data, W
065B  07AA     ADDWF i, F
065C  2E40     GOTO 0x640
0F79  01F4     CLRF 0xF4
0F7A  0875     MOVF 0xF5, W
0F7B  0274     SUBWF 0xF4, W
0F7C  1803     BTFSC 0x83, 0x0
0F7D  2F93     GOTO 0x793
0F8E  3001     MOVLW 0x1
0F8F  00F2     MOVWF 0xF2
0F90  0872     MOVF 0xF2, W
0F91  07F4     ADDWF 0xF4, F
0F92  2F7A     GOTO 0x77A
1875:              {
1876:                  *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
0644  082A     MOVF i, W
0645  3E58     ADDLW 0x58
0646  0086     MOVWF 0x86
0647  0187     CLRF 0x87
0648  0801     MOVF 0x81, W
0649  00A8     MOVWF data
064A  0023     MOVLB 0x3
064B  0830     MOVF outPipes, W
064C  0086     MOVWF 0x186
064D  3002     MOVLW 0x2
064E  0087     MOVWF 0x187
064F  0021     MOVLB 0x1
0650  0828     MOVF data, W
0651  0081     MOVWF 0x81
0652  3001     MOVLW 0x1
0653  00A8     MOVWF data
0654  0828     MOVF data, W
0655  0023     MOVLB 0x3
0656  07B0     ADDWF outPipes, F
0F7E  0874     MOVF 0x1F4, W
0F7F  3E58     ADDLW 0x58
0F80  0086     MOVWF 0x186
0F81  0187     CLRF 0x187
0F82  0801     MOVF 0x181, W
0F83  00F2     MOVWF 0x1F2
0F84  0830     MOVF outPipes, W
0F85  0086     MOVWF 0x186
0F86  3002     MOVLW 0x2
0F87  0087     MOVWF 0x187
0F88  0872     MOVF 0x1F2, W
0F89  0081     MOVWF 0x181
0F8A  3001     MOVLW 0x1
0F8B  00F2     MOVWF 0x1F2
0F8C  0872     MOVF 0x1F2, W
0F8D  07B0     ADDWF outPipes, F
1877:              }//end while(byteToRead.Val)
1878:          
1879:              //If there is more data to receive, prepare EP0 OUT so that it can receive 
1880:          	//the next packet in the sequence.
1881:              if(outPipes[0].wCount.Val > 0)
065D  0023     MOVLB 0x3
065E  0833     MOVF 0x1B3, W
065F  0434     IORWF 0x1B4, W
0660  1903     BTFSC 0x183, 0x2
0661  2E9C     GOTO 0x69C
0F93  0833     MOVF 0x1B3, W
0F94  0434     IORWF 0x1B4, W
0F95  1903     BTFSC 0x183, 0x2
0F96  2FD1     GOTO 0x7D1
1882:              {
1883:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0662  0021     MOVLB 0x1
0663  0848     MOVF pBDTEntryEP0OutNext, W
0664  3E01     ADDLW 0x1
0665  00A8     MOVWF data
0666  3000     MOVLW 0x0
0667  3D49     ADDWFC 0xC9, W
0668  00A9     MOVWF len
0669  0828     MOVF data, W
066A  0086     MOVWF 0x86
066B  0829     MOVF len, W
066C  0087     MOVWF 0x87
066D  3008     MOVLW 0x8
066E  0081     MOVWF 0x81
0F97  0021     MOVLB 0x1
0F98  0848     MOVF pBDTEntryEP0OutNext, W
0F99  3E01     ADDLW 0x1
0F9A  00F2     MOVWF 0xF2
0F9B  3000     MOVLW 0x0
0F9C  3D49     ADDWFC 0xC9, W
0F9D  00F3     MOVWF 0xF3
0F9E  0872     MOVF 0xF2, W
0F9F  0086     MOVWF 0x86
0FA0  0873     MOVF 0xF3, W
0FA1  0087     MOVWF 0x87
0FA2  3008     MOVLW 0x8
0FA3  0081     MOVWF 0x81
1884:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
066F  3058     MOVLW 0x58
0670  00A8     MOVWF data
0671  3000     MOVLW 0x0
0672  00A9     MOVWF len
0673  0848     MOVF pBDTEntryEP0OutNext, W
0674  0086     MOVWF 0x86
0675  0849     MOVF 0xC9, W
0676  0087     MOVWF 0x87
0677  3142     ADDFSR 1, 2
0678  0828     MOVF data, W
0679  3FC0     MOVWI 0[FSR1]
067A  0829     MOVF len, W
067B  3FC1     MOVWI 1[FSR1]
0FA4  3058     MOVLW 0x58
0FA5  00F2     MOVWF 0xF2
0FA6  3000     MOVLW 0x0
0FA7  00F3     MOVWF 0xF3
0FA8  0848     MOVF pBDTEntryEP0OutNext, W
0FA9  0086     MOVWF 0x86
0FAA  0849     MOVF 0xC9, W
0FAB  0087     MOVWF 0x87
0FAC  3142     ADDFSR 1, 2
0FAD  0872     MOVF 0xF2, W
0FAE  3FC0     MOVWI 0[FSR1]
0FAF  0873     MOVF 0xF3, W
0FB0  3FC1     MOVWI 1[FSR1]
1885:                  if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
067C  0023     MOVLB 0x3
067D  0864     MOVF pBDTEntryEP0OutCurrent, W
067E  0086     MOVWF 0x186
067F  0187     CLRF 0x187
0680  1B01     BTFSC 0x181, 0x6
0681  2E8F     GOTO 0x68F
0FB1  0023     MOVLB 0x3
0FB2  0864     MOVF pBDTEntryEP0OutCurrent, W
0FB3  0086     MOVWF 0x186
0FB4  0187     CLRF 0x187
0FB5  1B01     BTFSC 0x181, 0x6
0FB6  2FC4     GOTO 0x7C4
1886:                  {
1887:                      pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0682  0021     MOVLB 0x1
0683  0848     MOVF pBDTEntryEP0OutNext, W
0684  0086     MOVWF 0x86
0685  0849     MOVF 0xC9, W
0686  0087     MOVWF 0x87
0687  3048     MOVLW 0x48
0688  0081     MOVWF 0x81
0FB7  0021     MOVLB 0x1
0FB8  0848     MOVF pBDTEntryEP0OutNext, W
0FB9  0086     MOVWF 0x86
0FBA  0849     MOVF 0xC9, W
0FBB  0087     MOVWF 0x87
0FBC  3048     MOVLW 0x48
0FBD  0081     MOVWF 0x81
1888:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0689  0848     MOVF pBDTEntryEP0OutNext, W
068A  0086     MOVWF 0x86
068B  0849     MOVF 0xC9, W
068C  0087     MOVWF 0x87
068D  1781     BSF 0x81, 0x7
0FBE  0848     MOVF pBDTEntryEP0OutNext, W
0FBF  0086     MOVWF 0x86
0FC0  0849     MOVF 0xC9, W
0FC1  0087     MOVWF 0x87
0FC2  1781     BSF 0x81, 0x7
1889:                  }
068E  0008     RETURN
0FC3  0008     RETURN
1890:                  else
1891:                  {
1892:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
068F  0021     MOVLB 0x1
0690  0848     MOVF pBDTEntryEP0OutNext, W
0691  0086     MOVWF 0x86
0692  0849     MOVF 0xC9, W
0693  0087     MOVWF 0x87
0694  3008     MOVLW 0x8
0695  0081     MOVWF 0x81
0FC4  0021     MOVLB 0x1
0FC5  0848     MOVF pBDTEntryEP0OutNext, W
0FC6  0086     MOVWF 0x86
0FC7  0849     MOVF 0xC9, W
0FC8  0087     MOVWF 0x87
0FC9  3008     MOVLW 0x8
0FCA  0081     MOVWF 0x81
1893:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0696  0848     MOVF pBDTEntryEP0OutNext, W
0697  0086     MOVWF 0x86
0698  0849     MOVF 0xC9, W
0699  0087     MOVWF 0x87
069A  1781     BSF 0x81, 0x7
0FCB  0848     MOVF pBDTEntryEP0OutNext, W
0FCC  0086     MOVWF 0x86
0FCD  0849     MOVF 0xC9, W
0FCE  0087     MOVWF 0x87
0FCF  1781     BSF 0x81, 0x7
1894:                  }
1895:              }
069B  0008     RETURN
0FD0  0008     RETURN
1896:              else
1897:              {
1898:          	    //We have received all OUT packets that we were expecting to
1899:          	    //receive for the control transfer.  Prepare EP0 OUT to receive
1900:          		//the next SETUP transaction that may arrive.
1901:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
069C  0021     MOVLB 0x1
069D  0848     MOVF pBDTEntryEP0OutNext, W
069E  3E01     ADDLW 0x1
069F  00A8     MOVWF data
06A0  3000     MOVLW 0x0
06A1  3D49     ADDWFC 0xC9, W
06A2  00A9     MOVWF len
06A3  0828     MOVF data, W
06A4  0086     MOVWF 0x86
06A5  0829     MOVF len, W
06A6  0087     MOVWF 0x87
06A7  3008     MOVLW 0x8
06A8  0081     MOVWF 0x81
0FD1  0021     MOVLB 0x1
0FD2  0848     MOVF pBDTEntryEP0OutNext, W
0FD3  3E01     ADDLW 0x1
0FD4  00F2     MOVWF 0xF2
0FD5  3000     MOVLW 0x0
0FD6  3D49     ADDWFC 0xC9, W
0FD7  00F3     MOVWF 0xF3
0FD8  0872     MOVF 0xF2, W
0FD9  0086     MOVWF 0x86
0FDA  0873     MOVF 0xF3, W
0FDB  0087     MOVWF 0x87
0FDC  3008     MOVLW 0x8
0FDD  0081     MOVWF 0x81
1902:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
06A9  3050     MOVLW 0x50
06AA  00A8     MOVWF data
06AB  3000     MOVLW 0x0
06AC  00A9     MOVWF len
06AD  0848     MOVF pBDTEntryEP0OutNext, W
06AE  0086     MOVWF 0x86
06AF  0849     MOVF 0xC9, W
06B0  0087     MOVWF 0x87
06B1  3142     ADDFSR 1, 2
06B2  0828     MOVF data, W
06B3  3FC0     MOVWI 0[FSR1]
06B4  0829     MOVF len, W
06B5  3FC1     MOVWI 1[FSR1]
0FDE  3050     MOVLW 0x50
0FDF  00F2     MOVWF 0xF2
0FE0  3000     MOVLW 0x0
0FE1  00F3     MOVWF 0xF3
0FE2  0848     MOVF pBDTEntryEP0OutNext, W
0FE3  0086     MOVWF 0x86
0FE4  0849     MOVF 0xC9, W
0FE5  0087     MOVWF 0x87
0FE6  3142     ADDFSR 1, 2
0FE7  0872     MOVF 0xF2, W
0FE8  3FC0     MOVWI 0[FSR1]
0FE9  0873     MOVF 0xF3, W
0FEA  3FC1     MOVWI 1[FSR1]
1903:                  //Configure EP0 OUT to receive the next SETUP transaction for any future
1904:                  //control transfers.  However, set BSTALL in case the host tries to send
1905:                  //more data than it claims it was going to send.
1906:                  pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
06B6  0848     MOVF pBDTEntryEP0OutNext, W
06B7  0086     MOVWF 0x86
06B8  0849     MOVF 0xC9, W
06B9  0087     MOVWF 0x87
06BA  3004     MOVLW 0x4
06BB  0081     MOVWF 0x81
0FEB  0848     MOVF pBDTEntryEP0OutNext, W
0FEC  0086     MOVWF 0x86
0FED  0849     MOVF 0xC9, W
0FEE  0087     MOVWF 0x87
0FEF  3004     MOVLW 0x4
0FF0  0081     MOVWF 0x81
1907:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
06BC  0848     MOVF pBDTEntryEP0OutNext, W
06BD  0086     MOVWF 0x86
06BE  0849     MOVF 0xC9, W
06BF  0087     MOVWF 0x87
06C0  1781     BSF 0x81, 0x7
0FF1  0848     MOVF pBDTEntryEP0OutNext, W
0FF2  0086     MOVWF 0x86
0FF3  0849     MOVF 0xC9, W
0FF4  0087     MOVWF 0x87
0FF5  1781     BSF 0x81, 0x7
1908:          
1909:          		//All data bytes for the host to device control write (OUT) have now been
1910:          		//received successfully.
1911:          		//Go ahead and call the user specified callback function, to use/consume
1912:          		//the control transfer data (ex: if the "void (*function)" parameter 
1913:          		//was non-NULL when USBEP0Receive() was called).
1914:                  if(outPipes[0].pFunc != NULL)
06C1  0023     MOVLB 0x3
06C2  0835     MOVF 0x1B5, W
06C3  0836     MOVF 0x1B6, W
0FF6  0023     MOVLB 0x3
0FF7  0835     MOVF 0x1B5, W
0FF8  0836     MOVF 0x1B6, W
1915:                  {
1916:                      #if defined(__XC8)
1917:                          //Special pragmas to suppress an expected/harmless warning
1918:                          //message when building with the XC8 compiler
1919:                          #pragma warning push
1920:                          #pragma warning disable 1088
1921:                          outPipes[0].pFunc();    //Call the user's callback function
1922:                          #pragma warning pop
1923:                      #else
1924:                          outPipes[0].pFunc();    //Call the user's callback function
1925:                      #endif
1926:                  }
1927:                  outPipes[0].info.bits.busy = 0;    
06C4  13B2     BCF 0x1B2, 0x7
0FF9  13B2     BCF 0x1B2, 0x7
1928:          
1929:                  //Ready to arm status stage IN transaction now, if the application
1930:                  //firmware has completed processing the request.  If it is still busy
1931:                  //and needs more time to finish handling the request, then the user
1932:                  //callback (the one called by the outPipes[0].pFunc();) should set the
1933:                  //USBDeferStatusStagePacket to true (by calling USBDeferStatusStage()).  In
1934:                  //this case, it is the application's firmware responsibility to call 
1935:                  //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
1936:                  //Note: The application firmware must process the request and call
1937:                  //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
1938:                  //means either 50ms, 500ms, or 5 seconds, depending on the type of
1939:                  //control transfer.  See the USB 2.0 specification section 9.2.6 for
1940:                  //more details.
1941:                  if(USBDeferStatusStagePacket == false)
06C5  085B     MOVF USBDeferStatusStagePacket, W
06C6  1D03     BTFSS 0x183, 0x2
06C7  0008     RETURN
0FFA  085B     MOVF USBDeferStatusStagePacket, W
0FFB  1D03     BTFSS 0x183, 0x2
0FFC  0008     RETURN
1942:                  {
1943:                      USBCtrlEPAllowStatusStage();
06C8  318B     MOVLP 0xB
06C9  231E     CALL 0x31E
0FFD  3189     MOVLP 0x9
0FFE  2153     CALL 0x153
1944:                  }            
06CA  0008     RETURN
0FFF  0008     RETURN
1945:              }    
1946:          
1947:          }//end USBCtrlTrfRxService
1948:          
1949:          
1950:          /********************************************************************
1951:           * Function:        void USBStdSetCfgHandler(void)
1952:           *
1953:           * PreCondition:    None
1954:           *
1955:           * Input:           None
1956:           *
1957:           * Output:          None
1958:           *
1959:           * Side Effects:    None
1960:           *
1961:           * Overview:        This routine first disables all endpoints by
1962:           *                  clearing UEP registers. It then configures
1963:           *                  (initializes) endpoints by calling the callback
1964:           *                  function USBCBInitEP().
1965:           *
1966:           * Note:            None
1967:           *******************************************************************/
1968:          static void USBStdSetCfgHandler(void)
1969:          {
1970:              uint8_t i;
1971:          
1972:              // This will generate a zero length packet
1973:              inPipes[0].info.bits.busy = 1;            
0D19  0021     MOVLB 0x1
0DA8  0021     MOVLB 0x1
0DA9  17C5     BSF 0xC5, 0x7
1974:          
1975:              //Clear all of the endpoint control registers
1976:              DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
0D1B  300E     MOVLW 0xE
0D1C  0020     MOVLB 0x0
0D1D  00E8     MOVWF USBStdFeatureReqHandler
0D1E  3099     MOVLW 0x99
0D1F  00E7     MOVWF USBStdSetCfgHandler
0D20  01E9     CLRF USBStdSetCfgHandler
0D21  3002     MOVLW 0x2
0D22  0269     SUBWF USBStdSetCfgHandler, W
0D23  1803     BTFSC STATUS, 0x0
0D24  2D36     GOTO 0x536
0D25  0867     MOVF USBStdSetCfgHandler, W
0D26  0086     MOVWF FSR1
0D27  0868     MOVF USBStdFeatureReqHandler, W
0D28  0087     MOVWF FSR1H
0D29  0181     CLRF INDF1
0D2A  3001     MOVLW 0x1
0D2B  07E7     ADDWF USBStdSetCfgHandler, F
0D2C  3000     MOVLW 0x0
0D2D  3DE8     ADDWFC USBStdFeatureReqHandler, F
0D2E  3001     MOVLW 0x1
0D2F  00E6     MOVWF 0x66
0D30  0866     MOVF 0x66, W
0D31  07E9     ADDWF USBStdSetCfgHandler, F
0D32  3002     MOVLW 0x2
0D33  0269     SUBWF USBStdSetCfgHandler, W
0D34  1C03     BTFSS STATUS, 0x0
0D35  2D25     GOTO 0x525
0DAA  300E     MOVLW 0xE
0DAB  00BC     MOVWF 0x3C
0DAC  3099     MOVLW 0x99
0DAD  00BB     MOVWF 0x3B
0DAE  01BD     CLRF 0x3D
0DAF  3002     MOVLW 0x2
0DB0  023D     SUBWF 0x3D, W
0DB1  1803     BTFSC STATUS, 0x0
0DB2  2DC4     GOTO 0x5C4
0DB3  083B     MOVF 0x3B, W
0DB4  0086     MOVWF FSR1
0DB5  083C     MOVF 0x3C, W
0DB6  0087     MOVWF FSR1H
0DB7  0181     CLRF INDF1
0DB8  3001     MOVLW 0x1
0DB9  07BB     ADDWF 0x3B, F
0DBA  3000     MOVLW 0x0
0DBB  3DBC     ADDWFC 0x3C, F
0DBC  3001     MOVLW 0x1
0DBD  00BA     MOVWF 0x3A
0DBE  083A     MOVF 0x3A, W
0DBF  07BD     ADDWF 0x3D, F
0DC0  3002     MOVLW 0x2
0DC1  023D     SUBWF 0x3D, W
0DC2  1C03     BTFSS STATUS, 0x0
0DC3  2DB3     GOTO 0x5B3
1977:          
1978:              //Clear all of the BDT entries
1979:              memset((void*)&BDT[0], 0x00, sizeof(BDT));
0D36  3020     MOVLW 0x20
0D37  00F0     MOVWF __pcstackCOMMON
0D38  3000     MOVLW 0x0
0D39  00F1     MOVWF USBDeviceInit
0D3A  3000     MOVLW 0x0
0D3B  00F2     MOVWF USBCtrlTrfTxService
0D3C  00F3     MOVWF USBDeviceInit
0D3D  3030     MOVLW 0x30
0D3E  00F4     MOVWF USBDeviceInit
0D3F  3000     MOVLW 0x0
0D40  00F5     MOVWF EPNum
0D41  3190     MOVLP 0x10
0D42  207D     CALL 0x7D
0D43  318D     MOVLP 0xD
0DC4  3020     MOVLW 0x20
0DC5  00A6     MOVWF 0x26
0DC6  3000     MOVLW 0x0
0DC7  00A7     MOVWF 0x27
0DC8  3000     MOVLW 0x0
0DC9  00A8     MOVWF 0x28
0DCA  00A9     MOVWF 0x29
0DCB  3030     MOVLW 0x30
0DCC  00AA     MOVWF 0x2A
0DCD  3000     MOVLW 0x0
0DCE  00AB     MOVWF 0x2B
0DCF  3190     MOVLP 0x10
0DD0  20AD     CALL 0xAD
0DD1  318D     MOVLP 0xD
1980:          
1981:              // Assert reset request to all of the Ping Pong buffer pointers
1982:              USBPingPongBufferReset = 1;                                   
0D44  003D     MOVLB 0x1D
0D45  170E     BSF UCON, 0x6
0DD2  003D     MOVLB 0x1D
0DD3  170E     BSF UCON, 0x6
1983:          
1984:          	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
1985:          	//the EVEN buffer being the next one that will be used), since we are also 
1986:          	//doing a hardware ping pong pointer reset above.
1987:          	for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
0D46  0020     MOVLB 0x0
0D47  01EA     CLRF USBStdSetCfgHandler
0D48  3003     MOVLW 0x3
0D49  026A     SUBWF USBStdSetCfgHandler, W
0D4A  1803     BTFSC STATUS, 0x0
0D4B  2D60     GOTO 0x560
0D58  3001     MOVLW 0x1
0D59  00E6     MOVWF 0x66
0D5A  0866     MOVF 0x66, W
0D5B  07EA     ADDWF USBStdSetCfgHandler, F
0D5C  3003     MOVLW 0x3
0D5D  026A     SUBWF USBStdSetCfgHandler, W
0D5E  1C03     BTFSS STATUS, 0x0
0D5F  2D4C     GOTO 0x54C
0DD4  0021     MOVLB 0x1
0DD5  01BE     CLRF i
0DD6  3003     MOVLW 0x3
0DD7  023E     SUBWF i, W
0DD8  1803     BTFSC 0x83, 0x0
0DD9  2DEE     GOTO 0x5EE
0DE6  3001     MOVLW 0x1
0DE7  00BA     MOVWF 0xBA
0DE8  083A     MOVF 0xBA, W
0DE9  07BE     ADDWF i, F
0DEA  3003     MOVLW 0x3
0DEB  023E     SUBWF i, W
0DEC  1C03     BTFSS 0x83, 0x0
0DED  2DDA     GOTO 0x5DA
1988:          	{
1989:          		ep_data_in[i].Val = 0u;
0D4C  086A     MOVF 0xEA, W
0D4D  3ECA     ADDLW 0xCA
0D4E  0086     MOVWF 0x86
0D4F  3001     MOVLW 0x1
0D50  0087     MOVWF 0x87
0D51  0181     CLRF 0x81
0DDA  083E     MOVF i, W
0DDB  3ECA     ADDLW 0xCA
0DDC  0086     MOVWF 0x86
0DDD  3001     MOVLW 0x1
0DDE  0087     MOVWF 0x87
0DDF  0181     CLRF 0x81
1990:                  ep_data_out[i].Val = 0u;
0D52  086A     MOVF 0xEA, W
0D53  3EC7     ADDLW 0xC7
0D54  0086     MOVWF 0x86
0D55  3001     MOVLW 0x1
0D56  0087     MOVWF 0x87
0D57  0181     CLRF 0x81
0DE0  083E     MOVF i, W
0DE1  3EC7     ADDLW 0xC7
0DE2  0086     MOVWF 0x86
0DE3  3001     MOVLW 0x1
0DE4  0087     MOVWF 0x87
0DE5  0181     CLRF 0x81
1991:          	}
1992:          
1993:              //clear the alternate interface settings
1994:              memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
0D60  30EB     MOVLW 0xEB
0D61  00F0     MOVWF 0xF0
0D62  3001     MOVLW 0x1
0D63  00F1     MOVWF 0xF1
0D64  3000     MOVLW 0x0
0D65  00F2     MOVWF 0xF2
0D66  00F3     MOVWF 0xF3
0D67  3002     MOVLW 0x2
0D68  00F4     MOVWF 0xF4
0D69  3000     MOVLW 0x0
0D6A  00F5     MOVWF 0xF5
0D6B  3190     MOVLP 0x10
0D6C  207D     CALL 0x7D
0D6D  318D     MOVLP 0xD
0DEE  30EB     MOVLW 0xEB
0DEF  00A6     MOVWF length
0DF0  3001     MOVLW 0x1
0DF1  00A7     MOVWF p
0DF2  3000     MOVLW 0x0
0DF3  00A8     MOVWF data
0DF4  00A9     MOVWF len
0DF5  3002     MOVLW 0x2
0DF6  00AA     MOVWF i
0DF7  3000     MOVLW 0x0
0DF8  00AB     MOVWF EPNum
0DF9  3190     MOVLP 0x10
0DFA  20AD     CALL 0xAD
0DFB  318D     MOVLP 0xD
1995:          
1996:              //Stop trying to reset ping pong buffer pointers
1997:              USBPingPongBufferReset = 0;
0D6E  003D     MOVLB 0x1D
0D6F  130E     BCF UCON, 0x6
0DFC  003D     MOVLB 0x1D
0DFD  130E     BCF UCON, 0x6
1998:          
1999:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0D70  3028     MOVLW 0x28
0D71  0023     MOVLB 0x3
0D72  00B7     MOVWF pBDTEntryIn
0D73  3000     MOVLW 0x0
0D74  00B8     MOVWF 0x1B8
0DFE  3028     MOVLW 0x28
0DFF  0023     MOVLB 0x3
0E00  00B7     MOVWF pBDTEntryIn
0E01  3000     MOVLW 0x0
0E02  00B8     MOVWF 0x1B8
2000:          
2001:          	//Set the next out to the current out packet
2002:              pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
0D75  3020     MOVLW 0x20
0D76  0020     MOVLB 0x0
0D77  00E6     MOVWF 0x66
0D78  0866     MOVF 0x66, W
0D79  0023     MOVLB 0x3
0D7A  00E4     MOVWF pBDTEntryEP0OutCurrent
0E03  3020     MOVLW 0x20
0E04  0021     MOVLB 0x1
0E05  00BA     MOVWF 0xBA
0E06  083A     MOVF 0xBA, W
0E07  0023     MOVLB 0x3
0E08  00E4     MOVWF pBDTEntryEP0OutCurrent
2003:              pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
0D7B  0864     MOVF pBDTEntryEP0OutCurrent, W
0D7C  0021     MOVLB 0x1
0D7D  00C8     MOVWF pBDTEntryEP0OutNext
0D7E  39FF     ANDLW 0xFF
0D7F  1D03     BTFSS 0x83, 0x2
0D80  3000     MOVLW 0x0
0D81  00C9     MOVWF 0xC9
0E09  0864     MOVF 0xE4, W
0E0A  0021     MOVLB 0x1
0E0B  00C8     MOVWF pBDTEntryEP0OutNext
0E0C  39FF     ANDLW 0xFF
0E0D  1D03     BTFSS 0x83, 0x2
0E0E  3000     MOVLW 0x0
0E0F  00C9     MOVWF 0xC9
2004:          
2005:              //set the current configuration
2006:              USBActiveConfiguration = SetupPkt.bConfigurationValue;
0D82  0020     MOVLB 0x0
0D83  0852     MOVF 0x52, W
0D84  00E6     MOVWF 0x66
0D85  0866     MOVF 0x66, W
0D86  0023     MOVLB 0x3
0D87  00EE     MOVWF USBActiveConfiguration
0E10  0020     MOVLB 0x0
0E11  0852     MOVF 0x52, W
0E12  0021     MOVLB 0x1
0E13  00BA     MOVWF 0xBA
0E14  083A     MOVF 0xBA, W
0E15  0023     MOVLB 0x3
0E16  00EE     MOVWF USBActiveConfiguration
2007:          
2008:              //if the configuration value == 0
2009:              if(USBActiveConfiguration == 0)
0D88  086E     MOVF USBActiveConfiguration, W
0D89  1D03     BTFSS 0x183, 0x2
0D8A  2D92     GOTO 0x592
0E17  086E     MOVF USBActiveConfiguration, W
0E18  1D03     BTFSS 0x183, 0x2
0E19  2E21     GOTO 0x621
2010:              {
2011:                  //Go back to the addressed state
2012:                  USBDeviceState = ADDRESS_STATE;
0D8B  3010     MOVLW 0x10
0D8C  0020     MOVLB 0x0
0D8D  00E6     MOVWF 0x66
0D8E  0866     MOVF 0x66, W
0D8F  0023     MOVLB 0x3
0D90  00E5     MOVWF USBDeviceState
0E1A  3010     MOVLW 0x10
0E1B  0021     MOVLB 0x1
0E1C  00BA     MOVWF 0xBA
0E1D  083A     MOVF 0xBA, W
0E1E  0023     MOVLB 0x3
0E1F  00E5     MOVWF USBDeviceState
2013:              }
0D91  0008     RETURN
0E20  0008     RETURN
2014:              else
2015:              {
2016:                  //initialize the required endpoints
2017:                  USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
0D92  3000     MOVLW 0x0
0D93  0020     MOVLB 0x0
0D94  00E1     MOVWF 0x61
0D95  3001     MOVLW 0x1
0D96  00E0     MOVWF __pcstackBANK0h
0D97  30EE     MOVLW 0xEE
0D98  00E2     MOVWF pdata
0D99  3001     MOVLW 0x1
0D9A  00E3     MOVWF 0x63
0D9B  3001     MOVLW 0x1
0D9C  00E4     MOVWF size
0D9D  3000     MOVLW 0x0
0D9E  00E5     MOVWF 0x65
0D9F  3192     MOVLP 0x12
0DA0  2205     CALL 0x205
0E21  3000     MOVLW 0x0
0E22  0021     MOVLB 0x1
0E23  00B5     MOVWF 0xB5
0E24  3001     MOVLW 0x1
0E25  00B4     MOVWF event
0E26  30EE     MOVLW 0xEE
0E27  00B6     MOVWF pdata
0E28  3001     MOVLW 0x1
0E29  00B7     MOVWF numBytesRead
0E2A  3001     MOVLW 0x1
0E2B  00B8     MOVWF size
0E2C  3000     MOVLW 0x0
0E2D  00B9     MOVWF 0xB9
0E2E  3192     MOVLP 0x12
0E2F  2235     CALL 0x235
2018:          
2019:                  //Otherwise go to the configured state.  Update the state variable last,
2020:                  //after performing all of the set configuration related initialization
2021:                  //tasks.
2022:                  USBDeviceState = CONFIGURED_STATE;		
0DA1  3020     MOVLW 0x20
0DA2  0020     MOVLB 0x0
0DA3  00E6     MOVWF 0x66
0DA4  0866     MOVF 0x66, W
0DA5  0023     MOVLB 0x3
0DA6  00E5     MOVWF USBDeviceState
0DA7  0008     RETURN
0E30  3020     MOVLW 0x20
0E31  0021     MOVLB 0x1
0E32  00BA     MOVWF 0xBA
0E33  083A     MOVF 0xBA, W
0E34  0023     MOVLB 0x3
0E35  00E5     MOVWF USBDeviceState
0E36  0008     RETURN
2023:              }//end if(SetupPkt.bConfigurationValue == 0)
2024:          }//end USBStdSetCfgHandler
2025:          
2026:          
2027:          /********************************************************************
2028:           * Function:        void USBStdGetDscHandler(void)
2029:           *
2030:           * PreCondition:    None
2031:           *
2032:           * Input:           None
2033:           *
2034:           * Output:          None
2035:           *
2036:           * Side Effects:    None
2037:           *
2038:           * Overview:        This routine handles the standard GET_DESCRIPTOR
2039:           *                  request.
2040:           *
2041:           * Note:            None
2042:           *******************************************************************/
2043:          static void USBStdGetDscHandler(void)
2044:          {
2045:              if(SetupPkt.bmRequestType == 0x80)
0B98  3080     MOVLW 0x80
0C17  3080     MOVLW 0x80
0C18  0020     MOVLB 0x0
0C19  0650     XORWF SetupPkt, W
0C1A  1D03     BTFSS STATUS, 0x2
0C1B  0008     RETURN
2046:              {
2047:                  inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
0B9D  30C0     MOVLW 0xC0
0B9E  00F0     MOVWF __pcstackCOMMON
0B9F  0870     MOVF __pcstackCOMMON, W
0BA0  0021     MOVLB 0x1
0BA1  00C5     MOVWF 0xC5
0C1C  30C0     MOVLW 0xC0
0C1D  0021     MOVLB 0x1
0C1E  00A6     MOVWF length
0C1F  0826     MOVF length, W
0C20  00C5     MOVWF 0xC5
2048:          
2049:                  switch(SetupPkt.bDescriptorType)
0BA2  2C0A     GOTO 0x40A
0C0A  0020     MOVLB 0x0
0C0B  0853     MOVF 0x53, W
0C0C  3A01     XORLW 0x1
0C0D  1903     BTFSC STATUS, 0x2
0C0E  2BA3     GOTO 0x3A3
0C0F  3A03     XORLW 0x3
0C10  1903     BTFSC STATUS, 0x2
0C11  2BAD     GOTO 0x3AD
0C12  3A01     XORLW 0x1
0C13  1903     BTFSC STATUS, 0x2
0C14  2BE3     GOTO 0x3E3
0C15  2C07     GOTO 0x407
0C21  2C89     GOTO 0x489
0C89  0020     MOVLB 0x0
0C8A  0853     MOVF 0x53, W
0C8B  3A01     XORLW 0x1
0C8C  1903     BTFSC STATUS, 0x2
0C8D  2C22     GOTO 0x422
0C8E  3A03     XORLW 0x3
0C8F  1903     BTFSC STATUS, 0x2
0C90  2C2C     GOTO 0x42C
0C91  3A01     XORLW 0x1
0C92  1903     BTFSC STATUS, 0x2
0C93  2C62     GOTO 0x462
0C94  2C86     GOTO 0x486
2050:                  {
2051:                      case USB_DESCRIPTOR_DEVICE:
2052:                          #if !defined(USB_USER_DEVICE_DESCRIPTOR)
2053:                              inPipes[0].pSrc.bRom = (const uint8_t*)&device_dsc;
2054:                          #else
2055:                              inPipes[0].pSrc.bRom = (const uint8_t*)USB_USER_DEVICE_DESCRIPTOR;
0BA3  3091     MOVLW 0x91
0BA4  0021     MOVLB 0x1
0BA5  00C3     MOVWF inPipes
0BA6  3098     MOVLW 0x98
0BA7  00C4     MOVWF 0xC4
0C22  3091     MOVLW 0x91
0C23  0021     MOVLB 0x1
0C24  00C3     MOVWF inPipes
0C25  3098     MOVLW 0x98
0C26  00C4     MOVWF 0xC4
2056:                          #endif
2057:                          inPipes[0].wCount.Val = sizeof(device_dsc);
0BA8  3000     MOVLW 0x0
0BA9  00C7     MOVWF 0xC7
0BAA  3012     MOVLW 0x12
0BAB  00C6     MOVWF 0xC6
0C27  3000     MOVLW 0x0
0C28  00C7     MOVWF 0xC7
0C29  3012     MOVLW 0x12
0C2A  00C6     MOVWF 0xC6
2058:                          break;
0BAC  0008     RETURN
0C2B  0008     RETURN
2059:                      case USB_DESCRIPTOR_CONFIGURATION:
2060:                          //First perform error case check, to make sure the host is requesting a 
2061:                          //legal descriptor index.  If the request index is illegal, don't do 
2062:                          //anything (so that the default STALL response will be sent).
2063:                          if(SetupPkt.bDscIndex < USB_MAX_NUM_CONFIG_DSC)
0BAD  0020     MOVLB 0x0
0BAE  0852     MOVF 0x52, W
0BAF  1D03     BTFSS STATUS, 0x2
0BB0  2BE0     GOTO 0x3E0
0C2C  0020     MOVLB 0x0
0C2D  0852     MOVF 0x52, W
0C2E  1D03     BTFSS STATUS, 0x2
0C2F  2C5F     GOTO 0x45F
2064:                          {
2065:                              #if !defined(USB_USER_CONFIG_DESCRIPTOR)
2066:                                  inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
2067:                              #else
2068:                                  inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
0BB1  0852     MOVF 0x52, W
0BB2  00F0     MOVWF __pcstackCOMMON
0BB3  01F1     CLRF USBDeviceInit
0BB4  35F0     LSLF __pcstackCOMMON, F
0BB5  0DF1     RLF USBDeviceInit, F
0BB6  30AD     MOVLW 0xAD
0BB7  0770     ADDWF __pcstackCOMMON, W
0BB8  0084     MOVWF FSR0
0BB9  3098     MOVLW 0x98
0BBA  3D71     ADDWFC USBDeviceInit, W
0BBB  0085     MOVWF FSR0H
0BBC  3F00     MOVIW 0[FSR0]
0BBD  0021     MOVLB 0x1
0BBE  00C3     MOVWF inPipes
0BBF  3F01     MOVIW 1[FSR0]
0BC0  00C4     MOVWF 0xC4
0C30  0852     MOVF 0xD2, W
0C31  0021     MOVLB 0x1
0C32  00A6     MOVWF length
0C33  01A7     CLRF p
0C34  35A6     LSLF length, F
0C35  0DA7     RLF p, F
0C36  30AD     MOVLW 0xAD
0C37  0726     ADDWF length, W
0C38  0084     MOVWF 0x84
0C39  3098     MOVLW 0x98
0C3A  3D27     ADDWFC p, W
0C3B  0085     MOVWF 0x85
0C3C  3F00     MOVIW 0[FSR0]
0C3D  00C3     MOVWF inPipes
0C3E  3F01     MOVIW 1[FSR0]
0C3F  00C4     MOVWF 0xC4
2069:                              #endif
2070:          
2071:                              //This must be loaded using byte addressing.  The source pointer
2072:                              //  may not be word aligned for the 16 or 32 bit machines resulting
2073:                              //  in an address error on the dereference.
2074:                              inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
0BC1  0844     MOVF 0xC4, W
0BC2  00F1     MOVWF 0xF1
0BC3  0843     MOVF inPipes, W
0BC4  00F0     MOVWF 0xF0
0BC5  3002     MOVLW 0x2
0BC6  0770     ADDWF 0xF0, W
0BC7  0084     MOVWF 0x84
0BC8  0871     MOVF 0xF1, W
0BC9  1803     BTFSC 0x83, 0x0
0BCA  0A71     INCF 0xF1, W
0BCB  0085     MOVWF 0x85
0BCC  0800     MOVF 0x80, W
0BCD  00F2     MOVWF 0xF2
0BCE  0872     MOVF 0xF2, W
0BCF  00C6     MOVWF 0xC6
0C40  0844     MOVF 0xC4, W
0C41  00A7     MOVWF p
0C42  0843     MOVF inPipes, W
0C43  00A6     MOVWF length
0C44  3002     MOVLW 0x2
0C45  0726     ADDWF length, W
0C46  0084     MOVWF 0x84
0C47  0827     MOVF p, W
0C48  1803     BTFSC 0x83, 0x0
0C49  0A27     INCF p, W
0C4A  0085     MOVWF 0x85
0C4B  0800     MOVF 0x80, W
0C4C  00A8     MOVWF data
0C4D  0828     MOVF data, W
0C4E  00C6     MOVWF 0xC6
2075:                              inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
0BD0  0844     MOVF 0xC4, W
0BD1  00F1     MOVWF 0xF1
0BD2  0843     MOVF inPipes, W
0BD3  00F0     MOVWF 0xF0
0BD4  3003     MOVLW 0x3
0BD5  0770     ADDWF 0xF0, W
0BD6  0084     MOVWF 0x84
0BD7  0871     MOVF 0xF1, W
0BD8  1803     BTFSC 0x83, 0x0
0BD9  0A71     INCF 0xF1, W
0BDA  0085     MOVWF 0x85
0BDB  0800     MOVF 0x80, W
0BDC  00F2     MOVWF 0xF2
0BDD  0872     MOVF 0xF2, W
0BDE  00C7     MOVWF 0xC7
0C4F  0844     MOVF 0xC4, W
0C50  00A7     MOVWF p
0C51  0843     MOVF inPipes, W
0C52  00A6     MOVWF length
0C53  3003     MOVLW 0x3
0C54  0726     ADDWF length, W
0C55  0084     MOVWF 0x84
0C56  0827     MOVF p, W
0C57  1803     BTFSC 0x83, 0x0
0C58  0A27     INCF p, W
0C59  0085     MOVWF 0x85
0C5A  0800     MOVF 0x80, W
0C5B  00A8     MOVWF data
0C5C  0828     MOVF data, W
0C5D  00C7     MOVWF 0xC7
2076:                          }
0BDF  0008     RETURN
0C5E  0008     RETURN
2077:          				else
2078:          				{
2079:          					inPipes[0].info.Val = 0;
0BE0  0021     MOVLB 0x1
0BE1  01C5     CLRF 0xC5
0C5F  0021     MOVLB 0x1
0C60  01C5     CLRF 0xC5
2080:          				}
2081:                          break;
0BE2  0008     RETURN
0C61  0008     RETURN
2082:                      case USB_DESCRIPTOR_STRING:
2083:                          //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
2084:                          //  later it is now mandatory.  This should be defined in usb_device_config.h and should
2085:                          //  indicate the number of string descriptors.
2086:                          if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
0BE3  3003     MOVLW 0x3
0BE4  0020     MOVLB 0x0
0BE5  0252     SUBWF 0x52, W
0BE6  1803     BTFSC STATUS, 0x0
0BE7  2C04     GOTO 0x404
0C62  3003     MOVLW 0x3
0C63  0020     MOVLB 0x0
0C64  0252     SUBWF 0x52, W
0C65  1803     BTFSC STATUS, 0x0
0C66  2C83     GOTO 0x483
2087:                          {
2088:                              //Get a pointer to the String descriptor requested
2089:                              inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
0BE8  0852     MOVF 0x52, W
0BE9  00F0     MOVWF __pcstackCOMMON
0BEA  01F1     CLRF USBDeviceInit
0BEB  35F0     LSLF __pcstackCOMMON, F
0BEC  0DF1     RLF USBDeviceInit, F
0BED  30A3     MOVLW 0xA3
0BEE  0770     ADDWF __pcstackCOMMON, W
0BEF  0084     MOVWF FSR0
0BF0  3098     MOVLW 0x98
0BF1  3D71     ADDWFC USBDeviceInit, W
0BF2  0085     MOVWF FSR0H
0BF3  3F00     MOVIW 0[FSR0]
0BF4  0021     MOVLB 0x1
0BF5  00C3     MOVWF inPipes
0BF6  3F01     MOVIW 1[FSR0]
0BF7  00C4     MOVWF 0xC4
0C67  0852     MOVF 0xD2, W
0C68  0021     MOVLB 0x1
0C69  00A6     MOVWF length
0C6A  01A7     CLRF p
0C6B  35A6     LSLF length, F
0C6C  0DA7     RLF p, F
0C6D  30A3     MOVLW 0xA3
0C6E  0726     ADDWF length, W
0C6F  0084     MOVWF 0x84
0C70  3098     MOVLW 0x98
0C71  3D27     ADDWFC p, W
0C72  0085     MOVWF 0x85
0C73  3F00     MOVIW 0[FSR0]
0C74  00C3     MOVWF inPipes
0C75  3F01     MOVIW 1[FSR0]
0C76  00C4     MOVWF 0xC4
2090:                              // Set data count
2091:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
0BF8  0843     MOVF inPipes, W
0BF9  0084     MOVWF 0x84
0BFA  0844     MOVF 0xC4, W
0BFB  0085     MOVWF 0x85
0BFC  0800     MOVF 0x80, W
0BFD  00F0     MOVWF 0xF0
0BFE  01F1     CLRF 0xF1
0BFF  0870     MOVF 0xF0, W
0C00  00C6     MOVWF 0xC6
0C01  0871     MOVF 0xF1, W
0C02  00C7     MOVWF 0xC7
0C77  0843     MOVF inPipes, W
0C78  0084     MOVWF 0x84
0C79  0844     MOVF 0xC4, W
0C7A  0085     MOVWF 0x85
0C7B  0800     MOVF 0x80, W
0C7C  00A6     MOVWF length
0C7D  01A7     CLRF p
0C7E  0826     MOVF length, W
0C7F  00C6     MOVWF 0xC6
0C80  0827     MOVF p, W
0C81  00C7     MOVWF 0xC7
2092:                          }
0C03  0008     RETURN
0C82  0008     RETURN
2093:                          #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
2094:                          else if(SetupPkt.bDscIndex == MICROSOFT_OS_DESCRIPTOR_INDEX)
2095:                          {
2096:                              //Get a pointer to the special MS OS string descriptor requested
2097:                              inPipes[0].pSrc.bRom = (const uint8_t*)&MSOSDescriptor;
2098:                              // Set data count
2099:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
2100:                          }    
2101:                          #endif
2102:                          else
2103:                          {
2104:                              inPipes[0].info.Val = 0;
0C04  0021     MOVLB 0x1
0C05  01C5     CLRF 0xC5
0C83  0021     MOVLB 0x1
0C84  01C5     CLRF 0xC5
2105:                          }
2106:                          break;
0C06  0008     RETURN
0C85  0008     RETURN
2107:                      default:
2108:                          inPipes[0].info.Val = 0;
0C07  0021     MOVLB 0x1
0C08  01C5     CLRF 0xC5
0C86  0021     MOVLB 0x1
0C87  01C5     CLRF 0xC5
2109:                          break;
2110:                  }//end switch
0C09  0008     RETURN
0C16  0008     RETURN
0C88  0008     RETURN
0C95  0008     RETURN
2111:              }//end if
2112:          }//end USBStdGetDscHandler
2113:          
2114:          /********************************************************************
2115:           * Function:        void USBStdGetStatusHandler(void)
2116:           *
2117:           * PreCondition:    None
2118:           *
2119:           * Input:           None
2120:           *
2121:           * Output:          None
2122:           *
2123:           * Side Effects:    None
2124:           *
2125:           * Overview:        This routine handles the standard GET_STATUS request
2126:           *
2127:           * Note:            None
2128:           *******************************************************************/
2129:          static void USBStdGetStatusHandler(void)
2130:          {
2131:              CtrlTrfData[0] = 0;                 // Initialize content
146D  0020     MOVLB 0x0
1517  0020     MOVLB 0x0
1518  01D8     CLRF CtrlTrfData
2132:              CtrlTrfData[1] = 0;
146F  01D9     CLRF 0x59
1519  01D9     CLRF 0x59
2133:          
2134:              switch(SetupPkt.Recipient)
1470  2CA9     GOTO 0x4A9
14A9  0850     MOVF SetupPkt, W
14AA  391F     ANDLW 0x1F
14AB  3A00     XORLW 0x0
14AC  1903     BTFSC STATUS, 0x2
14AD  2C71     GOTO 0x471
14AE  3A01     XORLW 0x1
14AF  1903     BTFSC STATUS, 0x2
14B0  2C7A     GOTO 0x47A
14B1  3A03     XORLW 0x3
14B2  1903     BTFSC STATUS, 0x2
14B3  2C7D     GOTO 0x47D
14B4  2CB5     GOTO 0x4B5
151A  2D57     GOTO 0x557
1557  0850     MOVF SetupPkt, W
1558  391F     ANDLW 0x1F
1559  3A00     XORLW 0x0
155A  1903     BTFSC STATUS, 0x2
155B  2D1B     GOTO 0x51B
155C  3A01     XORLW 0x1
155D  1903     BTFSC STATUS, 0x2
155E  2D24     GOTO 0x524
155F  3A03     XORLW 0x3
1560  1903     BTFSC STATUS, 0x2
1561  2D27     GOTO 0x527
1562  2D63     GOTO 0x563
2135:              {
2136:                  case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
2137:                      inPipes[0].info.bits.busy = 1;
1471  0021     MOVLB 0x1
1472  17C5     BSF 0xC5, 0x7
151B  0021     MOVLB 0x1
151C  17C5     BSF 0xC5, 0x7
2138:                      /*
2139:                       * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
2140:                       *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
2141:                       */
2142:                      if(self_power == 1) // self_power is defined in HardwareProfile.h
2143:                      {
2144:                          CtrlTrfData[0]|=0x01;
2145:                      }
2146:          
2147:                      if(RemoteWakeup == true)
1473  0023     MOVLB 0x3
1474  0360     DECF RemoteWakeup, W
1475  1D03     BTFSS 0x183, 0x2
1476  2CB5     GOTO 0x4B5
151D  0023     MOVLB 0x3
151E  0360     DECF RemoteWakeup, W
151F  1D03     BTFSS 0x183, 0x2
1520  2D63     GOTO 0x563
2148:                      {
2149:                          CtrlTrfData[0]|=0x02;
1477  0020     MOVLB 0x0
1478  14D8     BSF CtrlTrfData, 0x1
1521  0020     MOVLB 0x0
1522  14D8     BSF CtrlTrfData, 0x1
2150:                      }
2151:                      break;
1479  2CB5     GOTO 0x4B5
1523  2D63     GOTO 0x563
2152:                  case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
2153:                      inPipes[0].info.bits.busy = 1;     // No data to update
147A  0021     MOVLB 0x1
147B  17C5     BSF 0xC5, 0x7
1524  0021     MOVLB 0x1
1525  17C5     BSF 0xC5, 0x7
2154:                      break;
147C  2CB5     GOTO 0x4B5
1526  2D63     GOTO 0x563
2155:                  case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
2156:                      inPipes[0].info.bits.busy = 1;
147D  0021     MOVLB 0x1
147E  17C5     BSF 0xC5, 0x7
1527  0021     MOVLB 0x1
1528  17C5     BSF 0xC5, 0x7
2157:                      /*
2158:                       * [0]: bit0: Halt Status [0] Not Halted [1] Halted
2159:                       */
2160:                      {
2161:                          BDT_ENTRY *p;
2162:          
2163:                          if(SetupPkt.EPDir == 0)
147F  0020     MOVLB 0x0
1480  1BD4     BTFSC 0x54, 0x7
1481  2C8D     GOTO 0x48D
1529  0020     MOVLB 0x0
152A  1BD4     BTFSC 0x54, 0x7
152B  2D38     GOTO 0x538
2164:                          {
2165:                              p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
1482  0854     MOVF 0x54, W
1483  390F     ANDLW 0xF
1484  0709     ADDWF WREG, W
1485  3EBD     ADDLW 0xBD
1486  0086     MOVWF FSR1
1487  3001     MOVLW 0x1
1488  0087     MOVWF FSR1H
1489  3F40     MOVIW 0[FSR1]
148A  00F1     MOVWF USBDeviceInit
148B  3F41     MOVIW 1[FSR1]
148C  2C97     GOTO 0x497
152C  0854     MOVF 0x54, W
152D  390F     ANDLW 0xF
152E  0709     ADDWF WREG, W
152F  3EBD     ADDLW 0xBD
1530  0086     MOVWF FSR1
1531  3001     MOVLW 0x1
1532  0087     MOVWF FSR1H
1533  3F40     MOVIW 0[FSR1]
1534  0021     MOVLB 0x1
1535  00A7     MOVWF p
1536  3F41     MOVIW 1[FSR1]
1537  2D44     GOTO 0x544
2166:                          }
2167:                          else
2168:                          {
2169:                              p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
148D  0854     MOVF 0xD4, W
148E  390F     ANDLW 0xF
148F  0709     ADDWF 0x89, W
1490  3EB7     ADDLW 0xB7
1491  0086     MOVWF 0x86
1492  3001     MOVLW 0x1
1493  0087     MOVWF 0x87
1494  3F40     MOVIW 0[FSR1]
1495  00F1     MOVWF 0xF1
1496  3F41     MOVIW 1[FSR1]
1497  00F2     MOVWF 0xF2
1538  0020     MOVLB 0x0
1539  0854     MOVF 0x54, W
153A  390F     ANDLW 0xF
153B  0709     ADDWF WREG, W
153C  3EB7     ADDLW 0xB7
153D  0086     MOVWF FSR1
153E  3001     MOVLW 0x1
153F  0087     MOVWF FSR1H
1540  3F40     MOVIW 0[FSR1]
1541  0021     MOVLB 0x1
1542  00A7     MOVWF p
1543  3F41     MOVIW 1[FSR1]
1544  00A8     MOVWF data
2170:                          }
2171:          
2172:                          if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
1498  0871     MOVF 0xF1, W
1499  0086     MOVWF 0x86
149A  0872     MOVF 0xF2, W
149B  0087     MOVWF 0x87
149C  1F81     BTFSS 0x81, 0x7
149D  2CB5     GOTO 0x4B5
149E  0871     MOVF 0xF1, W
149F  0086     MOVWF 0x86
14A0  0872     MOVF 0xF2, W
14A1  0087     MOVWF 0x87
14A2  1D01     BTFSS 0x81, 0x2
14A3  2CB5     GOTO 0x4B5
1545  0827     MOVF p, W
1546  0086     MOVWF 0x86
1547  0828     MOVF data, W
1548  0087     MOVWF 0x87
1549  1F81     BTFSS 0x81, 0x7
154A  2D63     GOTO 0x563
154B  0827     MOVF p, W
154C  0086     MOVWF 0x86
154D  0828     MOVF data, W
154E  0087     MOVWF 0x87
154F  1D01     BTFSS 0x81, 0x2
1550  2D63     GOTO 0x563
2173:                              CtrlTrfData[0]=0x01;    // Set bit0
14A4  3001     MOVLW 0x1
14A5  00F0     MOVWF 0xF0
14A6  0870     MOVF 0xF0, W
14A7  00D8     MOVWF 0xD8
1551  3001     MOVLW 0x1
1552  00A6     MOVWF length
1553  0826     MOVF length, W
1554  0020     MOVLB 0x0
1555  00D8     MOVWF CtrlTrfData
2174:                          break;
2175:                      }
2176:              }//end switch
14A8  2CB5     GOTO 0x4B5
1556  2D63     GOTO 0x563
2177:          
2178:              if(inPipes[0].info.bits.busy == 1)
14B5  0021     MOVLB 0x1
14B6  1FC5     BTFSS 0xC5, 0x7
14B7  0008     RETURN
1563  0021     MOVLB 0x1
1564  1FC5     BTFSS 0xC5, 0x7
1565  0008     RETURN
2179:              {
2180:                  inPipes[0].pSrc.bRam = (uint8_t*)&CtrlTrfData;        // Set Source
14B8  3058     MOVLW 0x58
14B9  00C3     MOVWF inPipes
14BA  3000     MOVLW 0x0
14BB  00C4     MOVWF 0xC4
1566  3058     MOVLW 0x58
1567  00C3     MOVWF inPipes
1568  3000     MOVLW 0x0
1569  00C4     MOVWF 0xC4
2181:                  inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;      // Set memory type
14BC  1445     BSF 0xC5, 0x0
156A  1445     BSF 0xC5, 0x0
2182:                  inPipes[0].wCount.v[0] = 2;                           // Set data count
14BD  3002     MOVLW 0x2
156B  3002     MOVLW 0x2
156C  00A6     MOVWF length
156D  0826     MOVF length, W
156E  00C6     MOVWF 0xC6
156F  0008     RETURN
2183:              }//end if(...)
2184:          }//end USBStdGetStatusHandler
2185:          
2186:          /********************************************************************
2187:           * Function:        void USBStallHandler(void)
2188:           *
2189:           * PreCondition:    None
2190:           *
2191:           * Input:           None
2192:           *
2193:           * Output:          None
2194:           *
2195:           * Side Effects:    
2196:           *
2197:           * Overview:        This function handles the event of a STALL 
2198:           *                  occurring on the bus
2199:           *
2200:           * Note:            None
2201:           *******************************************************************/
2202:          static void USBStallHandler(void)
2203:          {
2204:              /*
2205:               * Does not really have to do anything here,
2206:               * even for the control endpoint.
2207:               * All BDs of Endpoint 0 are owned by SIE right now,
2208:               * but once a Setup Transaction is received, the ownership
2209:               * for EP0_OUT will be returned to CPU.
2210:               * When the Setup Transaction is serviced, the ownership
2211:               * for EP0_IN will then be forced back to CPU by firmware.
2212:               */
2213:          
2214:              if(U1EP0bits.EPSTALL == 1)
0801  003D     MOVLB 0x1D
11DA  003D     MOVLB 0x1D
11DB  1C18     BTFSS UEP0, 0x0
11DC  29FE     GOTO 0x1FE
2215:              {
2216:                  // UOWN - if 0, owned by CPU, if 1, owned by SIE
2217:                  if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
0804  0023     MOVLB 0x3
0805  0864     MOVF pBDTEntryEP0OutCurrent, W
0806  0086     MOVWF 0x186
0807  0187     CLRF 0x187
0808  3080     MOVLW 0x80
0809  0601     XORWF 0x181, W
080A  1D03     BTFSS 0x183, 0x2
080B  281F     GOTO 0x1F
080C  0837     MOVF pBDTEntryIn, W
080D  0086     MOVWF 0x186
080E  0838     MOVF 0x1B8, W
080F  0087     MOVWF 0x187
0810  3084     MOVLW 0x84
0811  0601     XORWF 0x181, W
0812  1D03     BTFSS 0x183, 0x2
0813  281F     GOTO 0x1F
11DD  0023     MOVLB 0x3
11DE  0864     MOVF pBDTEntryEP0OutCurrent, W
11DF  0086     MOVWF 0x186
11E0  0187     CLRF 0x187
11E1  3080     MOVLW 0x80
11E2  0601     XORWF 0x181, W
11E3  1D03     BTFSS 0x183, 0x2
11E4  29FC     GOTO 0x1FC
11E5  0837     MOVF pBDTEntryIn, W
11E6  0086     MOVWF 0x186
11E7  0838     MOVF 0x1B8, W
11E8  0087     MOVWF 0x187
11E9  3084     MOVLW 0x84
11EA  0601     XORWF 0x181, W
11EB  1D03     BTFSS 0x183, 0x2
11EC  29FC     GOTO 0x1FC
2218:                  {
2219:                      // Set ep0Bo to stall also
2220:                      pBDTEntryEP0OutCurrent->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
0814  300C     MOVLW 0xC
0815  00F0     MOVWF 0x1F0
0816  0864     MOVF pBDTEntryEP0OutCurrent, W
0817  0086     MOVWF 0x186
0818  0187     CLRF 0x187
0819  0870     MOVF 0x1F0, W
081A  0081     MOVWF 0x181
11ED  300C     MOVLW 0xC
11EE  0021     MOVLB 0x1
11EF  00A6     MOVWF length
11F0  0023     MOVLB 0x3
11F1  0864     MOVF pBDTEntryEP0OutCurrent, W
11F2  0086     MOVWF 0x186
11F3  0187     CLRF 0x187
11F4  0021     MOVLB 0x1
11F5  0826     MOVF length, W
11F6  0081     MOVWF 0x81
2221:                      pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
081B  0864     MOVF 0xE4, W
081C  0086     MOVWF 0x86
081D  0187     CLRF 0x87
081E  1781     BSF 0x81, 0x7
11F7  0023     MOVLB 0x3
11F8  0864     MOVF pBDTEntryEP0OutCurrent, W
11F9  0086     MOVWF 0x186
11FA  0187     CLRF 0x187
11FB  1781     BSF 0x181, 0x7
2222:                  }//end if
2223:                  U1EP0bits.EPSTALL = 0;               // Clear stall status
081F  003D     MOVLB 0x1D
0820  1018     BCF UEP0, 0x0
11FC  003D     MOVLB 0x1D
11FD  1018     BCF UEP0, 0x0
2224:              }//end if
2225:          
2226:              USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
0821  30DF     MOVLW 0xDF
0822  00F0     MOVWF 0xEF0
0823  0870     MOVF 0xEF0, W
0824  0590     ANDWF UIR, F
11FE  30DF     MOVLW 0xDF
11FF  0021     MOVLB 0x1
1200  00A6     MOVWF length
1201  0826     MOVF length, W
1202  003D     MOVLB 0x1D
1203  0590     ANDWF UIR, F
2227:          }
0825  0008     RETURN
1204  0008     RETURN
2228:          
2229:          /********************************************************************
2230:           * Function:        void USBSuspend(void)
2231:           *
2232:           * PreCondition:    None
2233:           *
2234:           * Input:           None
2235:           *
2236:           * Output:          None
2237:           *
2238:           * Side Effects:    
2239:           *
2240:           * Overview:        This function handles if the host tries to 
2241:           *                  suspend the device
2242:           *
2243:           * Note:            None
2244:           *******************************************************************/
2245:          static void USBSuspend(void)
2246:          {
2247:              /*
2248:               * NOTE: Do not clear UIRbits.ACTVIF here!
2249:               * Reason:
2250:               * ACTVIF is only generated once an IDLEIF has been generated.
2251:               * This is a 1:1 ratio interrupt generation.
2252:               * For every IDLEIF, there will be only one ACTVIF regardless of
2253:               * the number of subsequent bus transitions.
2254:               *
2255:               * If the ACTIF is cleared here, a problem could occur when:
2256:               * [       IDLE       ][bus activity ->
2257:               * <--- 3 ms ----->     ^
2258:               *                ^     ACTVIF=1
2259:               *                IDLEIF=1
2260:               *  #           #           #           #   (#=Program polling flags)
2261:               *                          ^
2262:               *                          This polling loop will see both
2263:               *                          IDLEIF=1 and ACTVIF=1.
2264:               *                          However, the program services IDLEIF first
2265:               *                          because ACTIVIE=0.
2266:               *                          If this routine clears the only ACTIVIF,
2267:               *                          then it can never get out of the suspend
2268:               *                          mode.
2269:               */
2270:              USBActivityIE = 1;                     // Enable bus activity interrupt
1119  003D     MOVLB 0x1D
1138  003D     MOVLB 0x1D
1139  1512     BSF UIE, 0x2
2271:              USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
111B  30EF     MOVLW 0xEF
111C  0020     MOVLB 0x0
111D  00E6     MOVWF 0x66
111E  0866     MOVF 0x66, W
111F  003D     MOVLB 0x1D
1120  0590     ANDWF UIR, F
113A  30EF     MOVLW 0xEF
113B  0021     MOVLB 0x1
113C  00BA     MOVWF 0xBA
113D  083A     MOVF 0xBA, W
113E  003D     MOVLB 0x1D
113F  0590     ANDWF UIR, F
2272:          
2273:              #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2274:                  U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
1121  148E     BSF UCON, 0x1
1140  148E     BSF UCON, 0x1
2275:                                                          // mode, SIE clock inactive
2276:              #endif
2277:              USBBusIsSuspended = true;
1122  3001     MOVLW 0x1
1123  0020     MOVLB 0x0
1124  00E6     MOVWF 0x66
1125  0866     MOVF 0x66, W
1126  0023     MOVLB 0x3
1127  00DF     MOVWF USBBusIsSuspended
1141  3001     MOVLW 0x1
1142  0021     MOVLB 0x1
1143  00BA     MOVWF 0xBA
1144  083A     MOVF 0xBA, W
1145  0023     MOVLB 0x3
1146  00DF     MOVWF USBBusIsSuspended
2278:              USBTicksSinceSuspendEnd = 0;
1128  01D6     CLRF USBTicksSinceSuspendEnd
1147  01D6     CLRF USBTicksSinceSuspendEnd
2279:           
2280:              /*
2281:               * At this point the PIC can go into sleep,idle, or
2282:               * switch to a slower clock, etc.  This should be done in the
2283:               * USBCBSuspend() if necessary.
2284:               */
2285:              USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
1129  3075     MOVLW 0x75
112A  0020     MOVLB 0x0
112B  00E0     MOVWF __pcstackBANK0h
112C  3000     MOVLW 0x0
112D  00E1     MOVWF 0x61
112E  3000     MOVLW 0x0
112F  00E2     MOVWF pdata
1130  3000     MOVLW 0x0
1131  00E3     MOVWF 0x63
1132  3000     MOVLW 0x0
1133  00E4     MOVWF size
1134  00E5     MOVWF 0x65
1135  3192     MOVLP 0x12
1136  2205     CALL 0x205
1148  3075     MOVLW 0x75
1149  0021     MOVLB 0x1
114A  00B4     MOVWF event
114B  3000     MOVLW 0x0
114C  00B5     MOVWF 0xB5
114D  3000     MOVLW 0x0
114E  00B6     MOVWF pdata
114F  3000     MOVLW 0x0
1150  00B7     MOVWF numBytesRead
1151  3000     MOVLW 0x0
1152  00B8     MOVWF size
1153  00B9     MOVWF 0xB9
1154  3192     MOVLP 0x12
1155  2235     CALL 0x235
2286:          }
1137  0008     RETURN
1156  0008     RETURN
2287:          
2288:          /********************************************************************
2289:           * Function:        void USBWakeFromSuspend(void)
2290:           *
2291:           * PreCondition:    None
2292:           *
2293:           * Input:           None
2294:           *
2295:           * Output:          None
2296:           *
2297:           * Side Effects:    None
2298:           *
2299:           * Overview:
2300:           *
2301:           * Note:            None
2302:           *******************************************************************/
2303:          static void USBWakeFromSuspend(void)
2304:          {
2305:              USBBusIsSuspended = false;
1177  0023     MOVLB 0x3
1197  0023     MOVLB 0x3
1198  01DF     CLRF USBBusIsSuspended
2306:          
2307:              /*
2308:               * If using clock switching, the place to restore the original
2309:               * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
2310:               */
2311:              USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
1179  3074     MOVLW 0x74
117A  0020     MOVLB 0x0
117B  00E0     MOVWF __pcstackBANK0h
117C  3000     MOVLW 0x0
117D  00E1     MOVWF 0x61
117E  3000     MOVLW 0x0
117F  00E2     MOVWF pdata
1180  3000     MOVLW 0x0
1181  00E3     MOVWF 0x63
1182  3000     MOVLW 0x0
1183  00E4     MOVWF size
1184  00E5     MOVWF 0x65
1185  3192     MOVLP 0x12
1186  2205     CALL 0x205
1187  3191     MOVLP 0x11
1199  3074     MOVLW 0x74
119A  0021     MOVLB 0x1
119B  00B4     MOVWF event
119C  3000     MOVLW 0x0
119D  00B5     MOVWF 0xB5
119E  3000     MOVLW 0x0
119F  00B6     MOVWF pdata
11A0  3000     MOVLW 0x0
11A1  00B7     MOVWF numBytesRead
11A2  3000     MOVLW 0x0
11A3  00B8     MOVWF size
11A4  00B9     MOVWF 0xB9
11A5  3192     MOVLP 0x12
11A6  2235     CALL 0x235
11A7  3191     MOVLP 0x11
2312:          
2313:              #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2314:                  //To avoid improperly clocking the USB module, make sure the oscillator
2315:                  //settings are consistent with USB operation before clearing the SUSPND bit.
2316:                  //Make sure the correct oscillator settings are selected in the 
2317:                  //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
2318:                  U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
1188  003D     MOVLB 0x1D
1189  108E     BCF UCON, 0x1
11A8  003D     MOVLB 0x1D
11A9  108E     BCF UCON, 0x1
2319:                                          // mode.
2320:              #endif
2321:          
2322:          
2323:              USBActivityIE = 0;
118A  1112     BCF UIE, 0x2
11AA  1112     BCF UIE, 0x2
2324:          
2325:              /********************************************************************
2326:              Bug Fix: Feb 26, 2007 v2.1
2327:              *********************************************************************
2328:              The ACTVIF bit cannot be cleared immediately after the USB module wakes
2329:              up from Suspend or while the USB module is suspended. A few clock cycles
2330:              are required to synchronize the internal hardware state machine before
2331:              the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
2332:              before the internal hardware is synchronized may not have an effect on
2333:              the value of ACTVIF. Additionally, if the USB module uses the clock from
2334:              the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
2335:              module may not be immediately operational while waiting for the 96 MHz
2336:              PLL to lock.
2337:              ********************************************************************/
2338:          
2339:              // UIRbits.ACTVIF = 0;                      // Removed
2340:              #if defined(__18CXX) || defined(__XC8)
2341:              while(USBActivityIF)
118B  1D10     BTFSS UIR, 0x2
118C  2994     GOTO 0x194
1193  298B     GOTO 0x18B
11AB  1D10     BTFSS UIR, 0x2
11AC  29B4     GOTO 0x1B4
11B3  29AB     GOTO 0x1AB
2342:              #endif
2343:              {
2344:                  USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
118D  30FB     MOVLW 0xFB
118E  0020     MOVLB 0x0
118F  00E6     MOVWF 0x66
1190  0866     MOVF 0x66, W
1191  003D     MOVLB 0x1D
1192  0590     ANDWF UIR, F
11AD  30FB     MOVLW 0xFB
11AE  0021     MOVLB 0x1
11AF  00BA     MOVWF 0xBA
11B0  083A     MOVF 0xBA, W
11B1  003D     MOVLB 0x1D
11B2  0590     ANDWF UIR, F
2345:              }  // Added
2346:          
2347:              USBTicksSinceSuspendEnd = 0;
1194  0023     MOVLB 0x3
1195  01D6     CLRF USBTicksSinceSuspendEnd
11B4  0023     MOVLB 0x3
11B5  01D6     CLRF USBTicksSinceSuspendEnd
2348:          
2349:          }//end USBWakeFromSuspend
1196  0008     RETURN
11B6  0008     RETURN
2350:          
2351:          /********************************************************************
2352:           * Function:        void USBCtrlEPService(void)
2353:           *
2354:           * PreCondition:    USTAT is loaded with a valid endpoint address.
2355:           *
2356:           * Input:           None
2357:           *
2358:           * Output:          None
2359:           *
2360:           * Side Effects:    None
2361:           *
2362:           * Overview:        USBCtrlEPService checks for three transaction
2363:           *                  types that it knows how to service and services
2364:           *                  them:
2365:           *                  1. EP0 SETUP
2366:           *                  2. EP0 OUT
2367:           *                  3. EP0 IN
2368:           *                  It ignores all other types (i.e. EP1, EP2, etc.)
2369:           *
2370:           * Note:            None
2371:           *******************************************************************/
2372:          static void USBCtrlEPService(void)
2373:          {
2374:              //If we get to here, that means a successful transaction has just occurred 
2375:              //on EP0.  This means "progress" has occurred in the currently pending 
2376:              //control transfer, so we should re-initialize our timeout counter.
2377:              #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
2378:                  USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
15CC  302D     MOVLW 0x2D
1628  302D     MOVLW 0x2D
1629  0024     MOVLB 0x4
162A  00CF     MOVWF __pcstackBANK4
162B  084F     MOVF __pcstackBANK4, W
162C  0023     MOVLB 0x3
162D  00DC     MOVWF USBStatusStageTimeoutCounter
2379:              #endif
2380:          	
2381:          	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
2382:              if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
15D2  086D     MOVF USTATcopy, W
15D3  39FD     ANDLW 0xFD
15D4  1D03     BTFSS 0x183, 0x2
15D5  2E1C     GOTO 0x61C
162E  086D     MOVF USTATcopy, W
162F  39FD     ANDLW 0xFD
1630  1D03     BTFSS 0x183, 0x2
1631  2E78     GOTO 0x678
2383:              {
2384:          		//Point to the EP0 OUT buffer of the buffer that arrived
2385:                  #if defined (_PIC14E) || defined(__18CXX) || defined(__XC8)
2386:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
15D6  366D     LSRF USTATcopy, W
15D7  393F     ANDLW 0x3F
15D8  0021     MOVLB 0x1
15D9  00A0     MOVWF __pcstackBANK1
15DA  3001     MOVLW 0x1
15DB  35A0     LSLF __pcstackBANK1, F
15DC  3EFF     ADDLW 0xFF
15DD  1D03     BTFSS 0x83, 0x2
15DE  2DDB     GOTO 0x5DB
15DF  3520     LSLF __pcstackBANK1, W
15E0  3E20     ADDLW 0x20
15E1  00A1     MOVWF 0xA1
15E2  0821     MOVF 0xA1, W
15E3  0023     MOVLB 0x3
15E4  00E4     MOVWF pBDTEntryEP0OutCurrent
1632  366D     LSRF USTATcopy, W
1633  393F     ANDLW 0x3F
1634  0024     MOVLB 0x4
1635  00CF     MOVWF __pcstackBANK4
1636  3001     MOVLW 0x1
1637  35CF     LSLF __pcstackBANK4, F
1638  3EFF     ADDLW 0xFF
1639  1D03     BTFSS 0x203, 0x2
163A  2E37     GOTO 0x637
163B  354F     LSLF __pcstackBANK4, W
163C  3E20     ADDLW 0x20
163D  00D0     MOVWF 0x250
163E  0850     MOVF 0x250, W
163F  0023     MOVLB 0x3
1640  00E4     MOVWF pBDTEntryEP0OutCurrent
2387:                  #elif defined(__C30__) || defined(__C32__) || defined __XC16__
2388:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
2389:                  #else
2390:                      #error "unimplemented"
2391:                  #endif
2392:          
2393:          		//Set the next out to the current out packet
2394:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
15E5  0864     MOVF pBDTEntryEP0OutCurrent, W
15E6  0021     MOVLB 0x1
15E7  00C8     MOVWF pBDTEntryEP0OutNext
15E8  39FF     ANDLW 0xFF
15E9  1D03     BTFSS 0x83, 0x2
15EA  3000     MOVLW 0x0
15EB  00C9     MOVWF 0xC9
1641  0864     MOVF 0xE4, W
1642  0021     MOVLB 0x1
1643  00C8     MOVWF pBDTEntryEP0OutNext
1644  39FF     ANDLW 0xFF
1645  1D03     BTFSS 0x83, 0x2
1646  3000     MOVLW 0x0
1647  00C9     MOVWF 0xC9
2395:          		//Toggle it to the next ping pong buffer (if applicable)
2396:                  pBDTEntryEP0OutNext = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryEP0OutNext) ^ USB_NEXT_EP0_OUT_PING_PONG);
15EC  3004     MOVLW 0x4
15ED  0648     XORWF pBDTEntryEP0OutNext, W
15EE  00C8     MOVWF pBDTEntryEP0OutNext
15EF  3000     MOVLW 0x0
15F0  0649     XORWF 0xC9, W
15F1  00C9     MOVWF 0xC9
1648  3004     MOVLW 0x4
1649  0648     XORWF pBDTEntryEP0OutNext, W
164A  00C8     MOVWF pBDTEntryEP0OutNext
164B  3000     MOVLW 0x0
164C  0649     XORWF 0xC9, W
164D  00C9     MOVWF 0xC9
2397:          
2398:          		//If the current EP0 OUT buffer has a SETUP packet
2399:                  if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
15F2  0023     MOVLB 0x3
15F3  0864     MOVF pBDTEntryEP0OutCurrent, W
15F4  0086     MOVWF 0x186
15F5  0187     CLRF 0x187
15F6  0C01     RRF 0x181, W
15F7  0C89     RRF 0x189, F
15F8  390F     ANDLW 0xF
15F9  3A0D     XORLW 0xD
15FA  1D03     BTFSS 0x183, 0x2
15FB  2E19     GOTO 0x619
164E  0023     MOVLB 0x3
164F  0864     MOVF pBDTEntryEP0OutCurrent, W
1650  0086     MOVWF 0x186
1651  0187     CLRF 0x187
1652  0C01     RRF 0x181, W
1653  0C89     RRF 0x189, F
1654  390F     ANDLW 0xF
1655  3A0D     XORLW 0xD
1656  1D03     BTFSS 0x183, 0x2
1657  2E75     GOTO 0x675
2400:                  {
2401:          	        //The SETUP transaction data may have gone into the the CtrlTrfData 
2402:          	        //buffer, or elsewhere, depending upon how the BDT was prepared
2403:          	        //before the transaction.  Therefore, we should copy the data to the 
2404:          	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().		    
2405:                      memcpy((uint8_t*)&SetupPkt, (uint8_t*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR), 8);
15FC  3050     MOVLW 0x50
15FD  0086     MOVWF 0x186
15FE  0187     CLRF 0x187
15FF  0023     MOVLB 0x3
1600  0864     MOVF pBDTEntryEP0OutCurrent, W
1601  3E02     ADDLW 0x2
1602  0084     MOVWF 0x184
1603  0185     CLRF 0x185
1604  3F00     MOVIW 0[FSR0]
1605  0021     MOVLB 0x1
1606  00A0     MOVWF __pcstackBANK1
1607  3F01     MOVIW 1[FSR0]
1608  00A1     MOVWF 0xA1
1609  0820     MOVF __pcstackBANK1, W
160A  0084     MOVWF 0x84
160B  0821     MOVF 0xA1, W
160C  0085     MOVWF 0x85
160D  3008     MOVLW 0x8
160E  00A2     MOVWF 0xA2
160F  0822     MOVF 0xA2, W
1610  1903     BTFSC 0x83, 0x2
1611  2E16     GOTO 0x616
1612  0012     MOVIW FSR0++
1613  001E     MOVWI FSR1++
1614  0BA2     DECFSZ 0xA2, F
1615  2E12     GOTO 0x612
1658  3050     MOVLW 0x50
1659  0086     MOVWF 0x86
165A  0187     CLRF 0x87
165B  0023     MOVLB 0x3
165C  0864     MOVF pBDTEntryEP0OutCurrent, W
165D  3E02     ADDLW 0x2
165E  0084     MOVWF 0x184
165F  0185     CLRF 0x185
1660  3F00     MOVIW 0[FSR0]
1661  0024     MOVLB 0x4
1662  00CF     MOVWF __pcstackBANK4
1663  3F01     MOVIW 1[FSR0]
1664  00D0     MOVWF 0x250
1665  084F     MOVF __pcstackBANK4, W
1666  0084     MOVWF 0x204
1667  0850     MOVF 0x250, W
1668  0085     MOVWF 0x205
1669  3008     MOVLW 0x8
166A  00D1     MOVWF 0x251
166B  0851     MOVF 0x251, W
166C  1903     BTFSC 0x203, 0x2
166D  2E72     GOTO 0x672
166E  0012     MOVIW FSR0++
166F  001E     MOVWI FSR1++
1670  0BD1     DECFSZ 0x251, F
1671  2E6E     GOTO 0x66E
2406:          
2407:          			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
2408:                      USBCtrlTrfSetupHandler();
1616  3194     MOVLP 0x14
1617  241A     CALL 0x41A
1672  3193     MOVLP 0x13
1673  23CA     CALL 0x3CA
2409:                  }
1618  0008     RETURN
1674  0008     RETURN
2410:                  else
2411:                  {
2412:          			//Handle the DATA transfer
2413:                      USBCtrlTrfOutHandler();
1619  3192     MOVLP 0x12
161A  2265     CALL 0x265
1675  3192     MOVLP 0x12
1676  22D1     CALL 0x2D1
2414:                  }
2415:              }
161B  0008     RETURN
1677  0008     RETURN
2416:              else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
161C  30FD     MOVLW 0xFD
161D  0023     MOVLB 0x3
161E  056D     ANDWF USTATcopy, W
161F  0021     MOVLB 0x1
1620  00A0     MOVWF __pcstackBANK1
1621  3004     MOVLW 0x4
1622  0620     XORWF __pcstackBANK1, W
1623  1D03     BTFSS 0x83, 0x2
1624  0008     RETURN
1678  30FD     MOVLW 0xFD
1679  0023     MOVLB 0x3
167A  056D     ANDWF USTATcopy, W
167B  0024     MOVLB 0x4
167C  00CF     MOVWF __pcstackBANK4
167D  3004     MOVLW 0x4
167E  064F     XORWF __pcstackBANK4, W
167F  1D03     BTFSS 0x203, 0x2
1680  0008     RETURN
2417:              {
2418:          		//Otherwise the transmission was and EP0 IN
2419:          		//  so take care of the IN transfer
2420:                  USBCtrlTrfInHandler();
1625  3188     MOVLP 0x8
1626  20EB     CALL 0xEB
1681  3189     MOVLP 0x9
1682  21BF     CALL 0x1BF
2421:              }
1627  0008     RETURN
1683  0008     RETURN
2422:          
2423:          }//end USBCtrlEPService
2424:          
2425:          /********************************************************************
2426:           * Function:        void USBCtrlTrfSetupHandler(void)
2427:           *
2428:           * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
2429:           *
2430:           * Input:           None
2431:           *
2432:           * Output:          None
2433:           *
2434:           * Side Effects:    None
2435:           *
2436:           * Overview:        This routine is a task dispatcher and has 3 stages.
2437:           *                  1. It initializes the control transfer state machine.
2438:           *                  2. It calls on each of the module that may know how to
2439:           *                     service the Setup Request from the host.
2440:           *                     Module Example: USBD, HID, CDC, MSD, ...
2441:           *                     A callback function, USBCBCheckOtherReq(),
2442:           *                     is required to call other module handlers.
2443:           *                  3. Once each of the modules has had a chance to check if
2444:           *                     it is responsible for servicing the request, stage 3
2445:           *                     then checks direction of the transfer to determine how
2446:           *                     to prepare EP0 for the control transfer.
2447:           *                     Refer to USBCtrlEPServiceComplete() for more details.
2448:           *
2449:           * Note:            Microchip USB Firmware has three different states for
2450:           *                  the control transfer state machine:
2451:           *                  1. WAIT_SETUP
2452:           *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
2453:           *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
2454:           *                  Refer to firmware manual to find out how one state
2455:           *                  is transitioned to another.
2456:           *
2457:           *                  A Control Transfer is composed of many USB transactions.
2458:           *                  When transferring data over multiple transactions,
2459:           *                  it is important to keep track of data source, data
2460:           *                  destination, and data count. These three parameters are
2461:           *                  stored in pSrc,pDst, and wCount. A flag is used to
2462:           *                  note if the data source is from const or RAM.
2463:           *
2464:           *******************************************************************/
2465:          static void USBCtrlTrfSetupHandler(void)
2466:          {
2467:              //--------------------------------------------------------------------------
2468:              //1. Re-initialize state tracking variables related to control transfers.
2469:              //--------------------------------------------------------------------------
2470:              shortPacketStatus = SHORT_PKT_NOT_USED;  
13CA  0023     MOVLB 0x3
13CB  01E3     CLRF shortPacketStatus
141A  0023     MOVLB 0x3
2471:              USBDeferStatusStagePacket = false;
13CC  01DB     CLRF USBDeferStatusStagePacket
141C  01DB     CLRF USBDeferStatusStagePacket
2472:              USBDeferINDataStagePackets = false;
13CD  01D8     CLRF USBDeferINDataStagePackets
141D  01D8     CLRF USBDeferINDataStagePackets
2473:              USBDeferOUTDataStagePackets = false;
13CE  01D7     CLRF USBDeferOUTDataStagePackets
141E  01D7     CLRF USBDeferOUTDataStagePackets
2474:              BothEP0OutUOWNsSet = false;
13CF  01DD     CLRF BothEP0OutUOWNsSet
141F  01DD     CLRF BothEP0OutUOWNsSet
2475:              controlTransferState = WAIT_SETUP;
13D0  01E2     CLRF controlTransferState
1420  01E2     CLRF controlTransferState
2476:          
2477:              //Abandon any previous control transfers that might have been using EP0.
2478:              //Ordinarily, nothing actually needs abandoning, since the previous control
2479:              //transfer would have completed successfully prior to the host sending the next
2480:              //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
2481:              //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
2482:              //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
2483:              //by the class request handler that will be called next.
2484:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);  
13D1  307F     MOVLW 0x7F
13D2  0021     MOVLB 0x1
13D3  00C2     MOVWF 0xC2
13D4  0023     MOVLB 0x3
13D5  0837     MOVF pBDTEntryIn, W
13D6  0086     MOVWF 0x186
13D7  0838     MOVF 0x1B8, W
13D8  0087     MOVWF 0x187
13D9  0021     MOVLB 0x1
13DA  0842     MOVF 0xC2, W
13DB  0581     ANDWF 0x81, F
1421  307F     MOVLW 0x7F
1422  0020     MOVLB 0x0
1423  00EE     MOVWF 0x6E
1424  0023     MOVLB 0x3
1425  0837     MOVF pBDTEntryIn, W
1426  0086     MOVWF 0x186
1427  0838     MOVF 0x1B8, W
1428  0087     MOVWF 0x187
1429  0020     MOVLB 0x0
142A  086E     MOVF 0x6E, W
142B  0581     ANDWF INDF1, F
2485:              
2486:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
13DC  3004     MOVLW 0x4
13DD  0023     MOVLB 0x3
13DE  0637     XORWF pBDTEntryIn, W
13DF  00B7     MOVWF pBDTEntryIn
13E0  3000     MOVLW 0x0
13E1  0638     XORWF 0x1B8, W
13E2  00B8     MOVWF 0x1B8
142C  3004     MOVLW 0x4
142D  0023     MOVLB 0x3
142E  0637     XORWF pBDTEntryIn, W
142F  00B7     MOVWF pBDTEntryIn
1430  3000     MOVLW 0x0
1431  0638     XORWF 0x1B8, W
1432  00B8     MOVWF 0x1B8
2487:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);      
13E3  307F     MOVLW 0x7F
13E4  0021     MOVLB 0x1
13E5  00C2     MOVWF 0xC2
13E6  0023     MOVLB 0x3
13E7  0837     MOVF pBDTEntryIn, W
13E8  0086     MOVWF 0x186
13E9  0838     MOVF 0x1B8, W
13EA  0087     MOVWF 0x187
13EB  0021     MOVLB 0x1
13EC  0842     MOVF 0xC2, W
13ED  0581     ANDWF 0x81, F
1433  307F     MOVLW 0x7F
1434  0020     MOVLB 0x0
1435  00EE     MOVWF 0x6E
1436  0023     MOVLB 0x3
1437  0837     MOVF pBDTEntryIn, W
1438  0086     MOVWF 0x186
1439  0838     MOVF 0x1B8, W
143A  0087     MOVWF 0x187
143B  0020     MOVLB 0x0
143C  086E     MOVF 0x6E, W
143D  0581     ANDWF INDF1, F
2488:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
13EE  3004     MOVLW 0x4
13EF  0023     MOVLB 0x3
13F0  0637     XORWF pBDTEntryIn, W
13F1  00B7     MOVWF pBDTEntryIn
13F2  3000     MOVLW 0x0
13F3  0638     XORWF 0x1B8, W
13F4  00B8     MOVWF 0x1B8
143E  3004     MOVLW 0x4
143F  0023     MOVLB 0x3
1440  0637     XORWF pBDTEntryIn, W
1441  00B7     MOVWF pBDTEntryIn
1442  3000     MOVLW 0x0
1443  0638     XORWF 0x1B8, W
1444  00B8     MOVWF 0x1B8
2489:              pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);         
13F5  307F     MOVLW 0x7F
13F6  0021     MOVLB 0x1
13F7  00C2     MOVWF 0xC2
13F8  0848     MOVF pBDTEntryEP0OutNext, W
13F9  0086     MOVWF 0x86
13FA  0849     MOVF 0xC9, W
13FB  0087     MOVWF 0x87
13FC  0842     MOVF 0xC2, W
13FD  0581     ANDWF 0x81, F
1445  307F     MOVLW 0x7F
1446  0020     MOVLB 0x0
1447  00EE     MOVWF 0x6E
1448  0021     MOVLB 0x1
1449  0848     MOVF pBDTEntryEP0OutNext, W
144A  0086     MOVWF 0x86
144B  0849     MOVF 0xC9, W
144C  0087     MOVWF 0x87
144D  0020     MOVLB 0x0
144E  086E     MOVF 0x6E, W
144F  0581     ANDWF INDF1, F
2490:          
2491:              inPipes[0].info.Val = 0;
13FE  01C5     CLRF 0x45
1450  0021     MOVLB 0x1
1451  01C5     CLRF 0xC5
2492:              inPipes[0].wCount.Val = 0;
13FF  01C6     CLRF 0xC6
1400  01C7     CLRF 0xC7
1452  01C6     CLRF 0xC6
1453  01C7     CLRF 0xC7
2493:              outPipes[0].info.Val = 0;
1401  0023     MOVLB 0x3
1402  01B2     CLRF 0x1B2
1454  0023     MOVLB 0x3
1455  01B2     CLRF 0x1B2
2494:              outPipes[0].wCount.Val = 0;
1403  01B3     CLRF 0x1B3
1404  01B4     CLRF 0x1B4
1456  01B3     CLRF 0x1B3
1457  01B4     CLRF 0x1B4
2495:              
2496:          
2497:              //--------------------------------------------------------------------------
2498:              //2. Now find out what was in the SETUP packet, and begin handling the request.
2499:              //--------------------------------------------------------------------------
2500:              USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
1405  3197     MOVLP 0x17
1406  279F     CALL 0x79F
1407  3193     MOVLP 0x13
1458  3188     MOVLP 0x8
1459  2026     CALL 0x26
145A  3194     MOVLP 0x14
2501:              USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
1408  3000     MOVLW 0x0
1409  0021     MOVLB 0x1
140A  00B5     MOVWF 0xB5
140B  3003     MOVLW 0x3
140C  00B4     MOVWF event
140D  3000     MOVLW 0x0
140E  00B6     MOVWF pdata
140F  3000     MOVLW 0x0
1410  00B7     MOVWF numBytesRead
1411  3000     MOVLW 0x0
1412  00B8     MOVWF size
1413  00B9     MOVWF 0xB9
1414  3192     MOVLP 0x12
1415  2235     CALL 0x235
1416  3193     MOVLP 0x13
145B  3000     MOVLW 0x0
145C  0020     MOVLB 0x0
145D  00E1     MOVWF 0x61
145E  3003     MOVLW 0x3
145F  00E0     MOVWF __pcstackBANK0h
1460  3000     MOVLW 0x0
1461  00E2     MOVWF pdata
1462  3000     MOVLW 0x0
1463  00E3     MOVWF 0x63
1464  3000     MOVLW 0x0
1465  00E4     MOVWF size
1466  00E5     MOVWF 0x65
1467  3192     MOVLP 0x12
1468  2205     CALL 0x205
1469  3194     MOVLP 0x14
2502:          
2503:          
2504:              //--------------------------------------------------------------------------
2505:              //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in 
2506:              //   progress.  If one of the above handlers (in step 2) knew how to process
2507:              //   the request, it will have set one of the inPipes[0].info.bits.busy or
2508:              //   outPipes[0].info.bits.busy flags = 1.  This lets the
2509:              //   USBCtrlEPServiceComplete() function know how and which endpoints to 
2510:              //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
2511:              //   process the request.  In this case, the default behavior will be to
2512:              //   perform protocol STALL on EP0.
2513:              //-------------------------------------------------------------------------- 
2514:              USBCtrlEPServiceComplete();
1417  318E     MOVLP 0xE
1418  26C8     CALL 0x6C8
146A  318E     MOVLP 0xE
146B  2637     CALL 0x637
2515:          }//end USBCtrlTrfSetupHandler
1419  0008     RETURN
146C  0008     RETURN
2516:          
2517:          
2518:          /******************************************************************************
2519:           * Function:        void USBCtrlTrfOutHandler(void)
2520:           *
2521:           * PreCondition:    None
2522:           *
2523:           * Input:           None
2524:           *
2525:           * Output:          None
2526:           *
2527:           * Side Effects:    None
2528:           *
2529:           * Overview:        This routine handles an OUT transaction according to
2530:           *                  which control transfer state is currently active.
2531:           *
2532:           * Note:            Note that if the the control transfer was from
2533:           *                  host to device, the session owner should be notified
2534:           *                  at the end of each OUT transaction to service the
2535:           *                  received data.
2536:           *
2537:           *****************************************************************************/
2538:          static void USBCtrlTrfOutHandler(void)
2539:          {
2540:              if(controlTransferState == CTRL_TRF_RX)
1265  3002     MOVLW 0x2
12D1  3002     MOVLW 0x2
12D2  0023     MOVLB 0x3
12D3  0662     XORWF controlTransferState, W
12D4  1D03     BTFSS 0x183, 0x2
12D5  2AD9     GOTO 0x2D9
2541:              {
2542:                  USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
126A  318F     MOVLP 0xF
126B  275D     CALL 0x75D
12D6  3186     MOVLP 0x6
12D7  2619     CALL 0x619
2543:              }
126C  0008     RETURN
12D8  0008     RETURN
2544:              else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
2545:              {
2546:                  //If the status stage is complete, this means we are done with the 
2547:                  //control transfer.  Go back to the idle "WAIT_SETUP" state.
2548:                  controlTransferState = WAIT_SETUP;
126D  0023     MOVLB 0x3
126E  01E2     CLRF controlTransferState
12D9  0023     MOVLB 0x3
12DA  01E2     CLRF controlTransferState
2549:          
2550:                  //Prepare EP0 OUT for the next SETUP transaction, however, it may have
2551:                  //already been prepared if ping-pong buffering was enabled on EP0 OUT,
2552:                  //and the last control transfer was of direction: device to host, see
2553:                  //USBCtrlEPServiceComplete().  If it was already prepared, do not want
2554:                  //to do anything to the BDT.
2555:                  if(BothEP0OutUOWNsSet == false)
126F  085D     MOVF BothEP0OutUOWNsSet, W
1270  1D03     BTFSS 0x183, 0x2
1271  2A98     GOTO 0x298
12DB  085D     MOVF BothEP0OutUOWNsSet, W
12DC  1D03     BTFSS 0x183, 0x2
12DD  2B04     GOTO 0x304
2556:                  {
2557:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1272  0021     MOVLB 0x1
1273  0848     MOVF pBDTEntryEP0OutNext, W
1274  3E01     ADDLW 0x1
1275  00F6     MOVWF 0xF6
1276  3000     MOVLW 0x0
1277  3D49     ADDWFC 0xC9, W
1278  00F7     MOVWF 0xF7
1279  0876     MOVF 0xF6, W
127A  0086     MOVWF 0x86
127B  0877     MOVF 0xF7, W
127C  0087     MOVWF 0x87
127D  3008     MOVLW 0x8
127E  0081     MOVWF 0x81
12DE  0021     MOVLB 0x1
12DF  0848     MOVF pBDTEntryEP0OutNext, W
12E0  3E01     ADDLW 0x1
12E1  00AC     MOVWF handle
12E2  3000     MOVLW 0x0
12E3  3D49     ADDWFC 0xC9, W
12E4  00AD     MOVWF options
12E5  082C     MOVF handle, W
12E6  0086     MOVWF 0x86
12E7  082D     MOVF options, W
12E8  0087     MOVWF 0x87
12E9  3008     MOVLW 0x8
12EA  0081     MOVWF 0x81
2558:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
127F  3050     MOVLW 0x50
1280  00F6     MOVWF 0xF6
1281  3000     MOVLW 0x0
1282  00F7     MOVWF 0xF7
1283  0848     MOVF pBDTEntryEP0OutNext, W
1284  0086     MOVWF 0x86
1285  0849     MOVF 0xC9, W
1286  0087     MOVWF 0x87
1287  3142     ADDFSR 1, 2
1288  0876     MOVF 0xF6, W
1289  3FC0     MOVWI 0[FSR1]
128A  0877     MOVF 0xF7, W
128B  3FC1     MOVWI 1[FSR1]
12EB  3050     MOVLW 0x50
12EC  00AC     MOVWF handle
12ED  3000     MOVLW 0x0
12EE  00AD     MOVWF options
12EF  0848     MOVF pBDTEntryEP0OutNext, W
12F0  0086     MOVWF 0x86
12F1  0849     MOVF 0xC9, W
12F2  0087     MOVWF 0x87
12F3  3142     ADDFSR 1, 2
12F4  082C     MOVF handle, W
12F5  3FC0     MOVWI 0[FSR1]
12F6  082D     MOVF options, W
12F7  3FC1     MOVWI 1[FSR1]
2559:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
128C  0848     MOVF pBDTEntryEP0OutNext, W
128D  0086     MOVWF 0x86
128E  0849     MOVF 0xC9, W
128F  0087     MOVWF 0x87
1290  300C     MOVLW 0xC
1291  0081     MOVWF 0x81
12F8  0848     MOVF pBDTEntryEP0OutNext, W
12F9  0086     MOVWF 0x86
12FA  0849     MOVF 0xC9, W
12FB  0087     MOVWF 0x87
12FC  300C     MOVLW 0xC
12FD  0081     MOVWF 0x81
2560:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1292  0848     MOVF pBDTEntryEP0OutNext, W
1293  0086     MOVWF 0x86
1294  0849     MOVF 0xC9, W
1295  0087     MOVWF 0x87
1296  1781     BSF 0x81, 0x7
12FE  0848     MOVF pBDTEntryEP0OutNext, W
12FF  0086     MOVWF 0x86
1300  0849     MOVF 0xC9, W
1301  0087     MOVWF 0x87
1302  1781     BSF 0x81, 0x7
2561:                  }
1297  0008     RETURN
1303  0008     RETURN
2562:                  else
2563:                  {
2564:                          BothEP0OutUOWNsSet = false;
1298  0023     MOVLB 0x3
1299  01DD     CLRF BothEP0OutUOWNsSet
1304  0023     MOVLB 0x3
1305  01DD     CLRF BothEP0OutUOWNsSet
2565:                  }
129A  0008     RETURN
1306  0008     RETURN
2566:              }
2567:          }
2568:          
2569:          /******************************************************************************
2570:           * Function:        void USBCtrlTrfInHandler(void)
2571:           *
2572:           * PreCondition:    None
2573:           *
2574:           * Input:           None
2575:           *
2576:           * Output:          None
2577:           *
2578:           * Side Effects:    None
2579:           *
2580:           * Overview:        This routine handles an IN transaction according to
2581:           *                  which control transfer state is currently active.
2582:           *
2583:           * Note:            A Set Address Request must not change the actual address
2584:           *                  of the device until the completion of the control
2585:           *                  transfer. The end of the control transfer for Set Address
2586:           *                  Request is an IN transaction. Therefore it is necessary
2587:           *                  to service this unique situation when the condition is
2588:           *                  right. Macro mUSBCheckAdrPendingState is defined in
2589:           *                  usb9.h and its function is to specifically service this
2590:           *                  event.
2591:           *****************************************************************************/
2592:          static void USBCtrlTrfInHandler(void)
2593:          {
2594:              uint8_t lastDTS;
2595:          
2596:              lastDTS = pBDTEntryIn[0]->STAT.DTS;
08EB  0023     MOVLB 0x3
09BF  0023     MOVLB 0x3
09C0  0837     MOVF pBDTEntryIn, W
09C1  0086     MOVWF 0x186
09C2  0838     MOVF 0x1B8, W
09C3  0087     MOVWF 0x187
09C4  3000     MOVLW 0x0
09C5  1B01     BTFSC 0x181, 0x6
09C6  3001     MOVLW 0x1
09C7  0021     MOVLB 0x1
09C8  00AB     MOVWF EPNum
2597:          
2598:              //switch to the next ping pong buffer
2599:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
08F4  3004     MOVLW 0x4
08F5  0637     XORWF numBytesRead, W
08F6  00B7     MOVWF numBytesRead
08F7  3000     MOVLW 0x0
08F8  0638     XORWF size, W
08F9  00B8     MOVWF size
09C9  3004     MOVLW 0x4
09CA  0023     MOVLB 0x3
09CB  0637     XORWF pBDTEntryIn, W
09CC  00B7     MOVWF pBDTEntryIn
09CD  3000     MOVLW 0x0
09CE  0638     XORWF 0x1B8, W
09CF  00B8     MOVWF 0x1B8
2600:          
2601:              //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
2602:              //now, since the IN status stage of the (set address) control transfer has 
2603:              //evidently completed successfully.
2604:              if(USBDeviceState == ADR_PENDING_STATE)
08FA  3008     MOVLW 0x8
08FB  0665     XORWF USBDeviceState, W
08FC  1D03     BTFSS 0x183, 0x2
08FD  290D     GOTO 0x10D
09D0  3008     MOVLW 0x8
09D1  0665     XORWF USBDeviceState, W
09D2  1D03     BTFSS 0x183, 0x2
09D3  29E4     GOTO 0x1E4
2605:              {
2606:                  U1ADDR = (SetupPkt.bDevADR & 0x7F);
08FE  0020     MOVLB 0x0
08FF  0852     MOVF 0x52, W
0900  397F     ANDLW 0x7F
0901  003D     MOVLB 0x1D
0902  0096     MOVWF UADDR
09D4  0020     MOVLB 0x0
09D5  0852     MOVF 0x52, W
09D6  397F     ANDLW 0x7F
09D7  003D     MOVLB 0x1D
09D8  0096     MOVWF UADDR
2607:                  if(U1ADDR != 0u)
0903  0816     MOVF UADDR, W
0904  1903     BTFSC 0xE83, 0x2
0905  2908     GOTO 0x108
09D9  0816     MOVF UADDR, W
09DA  1903     BTFSC 0xE83, 0x2
09DB  29DE     GOTO 0x1DE
2608:                  {
2609:                      USBDeviceState=ADDRESS_STATE;
0906  3010     MOVLW 0x10
0907  2909     GOTO 0x109
09DC  3010     MOVLW 0x10
09DD  29DF     GOTO 0x1DF
2610:                  }
2611:                  else
2612:                  {
2613:                      USBDeviceState=DEFAULT_STATE;
0908  3004     MOVLW 0x4
0909  00F3     MOVWF 0xEF3
090A  0873     MOVF 0xEF3, W
090B  0023     MOVLB 0x3
090C  00E5     MOVWF USBDeviceState
09DE  3004     MOVLW 0x4
09DF  0021     MOVLB 0x1
09E0  00A9     MOVWF len
09E1  0829     MOVF len, W
09E2  0023     MOVLB 0x3
09E3  00E5     MOVWF USBDeviceState
2614:                  }
2615:              }//end if
2616:          
2617:          
2618:              if(controlTransferState == CTRL_TRF_TX)
090D  0362     DECF controlTransferState, W
090E  1D03     BTFSS 0x183, 0x2
090F  294C     GOTO 0x14C
09E4  0362     DECF controlTransferState, W
09E5  1D03     BTFSS 0x183, 0x2
09E6  2A29     GOTO 0x229
2619:              {
2620:                  pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
0910  3058     MOVLW 0x58
0911  00F3     MOVWF 0x1F3
0912  3000     MOVLW 0x0
0913  00F4     MOVWF 0x1F4
0914  0837     MOVF pBDTEntryIn, W
0915  0086     MOVWF 0x186
0916  0838     MOVF 0x1B8, W
0917  0087     MOVWF 0x187
0918  3142     ADDFSR 1, 2
0919  0873     MOVF 0x1F3, W
091A  3FC0     MOVWI 0[FSR1]
091B  0874     MOVF 0x1F4, W
091C  3FC1     MOVWI 1[FSR1]
09E7  3058     MOVLW 0x58
09E8  0021     MOVLB 0x1
09E9  00A9     MOVWF len
09EA  3000     MOVLW 0x0
09EB  00AA     MOVWF i
09EC  0023     MOVLB 0x3
09ED  0837     MOVF pBDTEntryIn, W
09EE  0086     MOVWF 0x186
09EF  0838     MOVF 0x1B8, W
09F0  0087     MOVWF 0x187
09F1  3142     ADDFSR 1, 2
09F2  0021     MOVLB 0x1
09F3  0829     MOVF len, W
09F4  3FC0     MOVWI 0[FSR1]
09F5  082A     MOVF i, W
09F6  3FC1     MOVWI 1[FSR1]
2621:                  USBCtrlTrfTxService();
091D  318A     MOVLP 0xA
091E  2230     CALL 0x230
091F  3188     MOVLP 0x8
09F7  318A     MOVLP 0xA
09F8  22A4     CALL 0x2A4
09F9  3189     MOVLP 0x9
2622:          
2623:                  //Check if we have already sent a short packet.  If so, configure
2624:                  //the endpoint to STALL in response to any further IN tokens (in the
2625:                  //case that the host erroneously tries to receive more data than it
2626:                  //should).
2627:                  if(shortPacketStatus == SHORT_PKT_SENT)
0920  3002     MOVLW 0x2
0921  0023     MOVLB 0x3
0922  0663     XORWF shortPacketStatus, W
0923  1D03     BTFSS 0x183, 0x2
0924  2931     GOTO 0x131
09FA  3002     MOVLW 0x2
09FB  0023     MOVLB 0x3
09FC  0663     XORWF shortPacketStatus, W
09FD  1D03     BTFSS 0x183, 0x2
09FE  2A0B     GOTO 0x20B
2628:                  {
2629:                      // If a short packet has been sent, don't want to send any more,
2630:                      // stall next time if host is still trying to read.
2631:                      pBDTEntryIn[0]->STAT.Val = _BSTALL;
0925  0837     MOVF pBDTEntryIn, W
0926  0086     MOVWF 0x186
0927  0838     MOVF 0x1B8, W
0928  0087     MOVWF 0x187
0929  3004     MOVLW 0x4
092A  0081     MOVWF 0x181
09FF  0837     MOVF pBDTEntryIn, W
0A00  0086     MOVWF 0x186
0A01  0838     MOVF 0x1B8, W
0A02  0087     MOVWF 0x187
0A03  3004     MOVLW 0x4
0A04  0081     MOVWF 0x181
2632:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
092B  0837     MOVF pBDTEntryIn, W
092C  0086     MOVWF 0x186
092D  0838     MOVF 0x1B8, W
092E  0087     MOVWF 0x187
092F  1781     BSF 0x181, 0x7
0A05  0837     MOVF pBDTEntryIn, W
0A06  0086     MOVWF 0x186
0A07  0838     MOVF 0x1B8, W
0A08  0087     MOVWF 0x187
0A09  1781     BSF 0x181, 0x7
2633:                  }
0930  0008     RETURN
0A0A  0008     RETURN
2634:                  else
2635:                  {
2636:                      if(lastDTS == 0)
0931  0875     MOVF 0x1F5, W
0932  1D03     BTFSS 0x183, 0x2
0933  2940     GOTO 0x140
0A0B  0021     MOVLB 0x1
0A0C  082B     MOVF EPNum, W
0A0D  1D03     BTFSS 0x83, 0x2
0A0E  2A1C     GOTO 0x21C
2637:                      {
2638:                          pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0934  0837     MOVF numBytesRead, W
0935  0086     MOVWF 0x86
0936  0838     MOVF size, W
0937  0087     MOVWF 0x87
0938  3048     MOVLW 0x48
0939  0081     MOVWF 0x81
0A0F  0023     MOVLB 0x3
0A10  0837     MOVF pBDTEntryIn, W
0A11  0086     MOVWF 0x186
0A12  0838     MOVF 0x1B8, W
0A13  0087     MOVWF 0x187
0A14  3048     MOVLW 0x48
0A15  0081     MOVWF 0x181
2639:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
093A  0837     MOVF pBDTEntryIn, W
093B  0086     MOVWF 0x186
093C  0838     MOVF 0x1B8, W
093D  0087     MOVWF 0x187
093E  1781     BSF 0x181, 0x7
0A16  0837     MOVF pBDTEntryIn, W
0A17  0086     MOVWF 0x186
0A18  0838     MOVF 0x1B8, W
0A19  0087     MOVWF 0x187
0A1A  1781     BSF 0x181, 0x7
2640:                      }
093F  0008     RETURN
0A1B  0008     RETURN
2641:                      else
2642:                      {
2643:                          pBDTEntryIn[0]->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
0940  0837     MOVF pBDTEntryIn, W
0941  0086     MOVWF 0x186
0942  0838     MOVF 0x1B8, W
0943  0087     MOVWF 0x187
0944  3008     MOVLW 0x8
0945  0081     MOVWF 0x181
0A1C  0023     MOVLB 0x3
0A1D  0837     MOVF pBDTEntryIn, W
0A1E  0086     MOVWF 0x186
0A1F  0838     MOVF 0x1B8, W
0A20  0087     MOVWF 0x187
0A21  3008     MOVLW 0x8
0A22  0081     MOVWF 0x181
2644:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
0946  0837     MOVF pBDTEntryIn, W
0947  0086     MOVWF 0x186
0948  0838     MOVF 0x1B8, W
0949  0087     MOVWF 0x187
094A  1781     BSF 0x181, 0x7
0A23  0837     MOVF pBDTEntryIn, W
0A24  0086     MOVWF 0x186
0A25  0838     MOVF 0x1B8, W
0A26  0087     MOVWF 0x187
0A27  1781     BSF 0x181, 0x7
2645:                      }
2646:                  }//end if(...)else
2647:              }
094B  0008     RETURN
0A28  0008     RETURN
2648:          	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
2649:          	{
2650:                  //if someone is still expecting data from the control transfer
2651:                  //  then make sure to terminate that request and let them know that
2652:                  //  they are done
2653:                  if(outPipes[0].info.bits.busy == 1)
094C  1FB2     BTFSS 0x1B2, 0x7
094D  2951     GOTO 0x151
0A29  1FB2     BTFSS 0x1B2, 0x7
0A2A  2A2E     GOTO 0x22E
2654:                  {
2655:                      if(outPipes[0].pFunc != NULL)
094E  0835     MOVF 0x1B5, W
094F  0836     MOVF 0x1B6, W
0A2B  0835     MOVF 0x1B5, W
0A2C  0836     MOVF 0x1B6, W
2656:                      {
2657:                          outPipes[0].pFunc();
2658:                      }
2659:                      outPipes[0].info.bits.busy = 0;
0950  13B2     BCF 0x1B2, 0x7
0A2D  13B2     BCF 0x1B2, 0x7
2660:                  }
2661:              	
2662:                  controlTransferState = WAIT_SETUP;
0951  01E2     CLRF controlTransferState
0952  0008     RETURN
0A2E  01E2     CLRF controlTransferState
0A2F  0008     RETURN
2663:                  //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
2664:                  //got processed by the USBCtrlTrfRxService() handler.
2665:          	}	
2666:          
2667:          }
2668:          
2669:          
2670:          /********************************************************************
2671:           * Function:        void USBCheckStdRequest(void)
2672:           *
2673:           * PreCondition:    None
2674:           *
2675:           * Input:           None
2676:           *
2677:           * Output:          None
2678:           *
2679:           * Side Effects:    None
2680:           *
2681:           * Overview:        This routine checks the setup data packet to see
2682:           *                  if it knows how to handle it
2683:           *
2684:           * Note:            None
2685:           *******************************************************************/
2686:          static void USBCheckStdRequest(void)
2687:          {
2688:              if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
0826  0020     MOVLB 0x0
179F  0020     MOVLB 0x0
17A0  0E50     SWAPF SetupPkt, W
17A1  0C89     RRF WREG, F
17A2  3903     ANDLW 0x3
17A3  3A00     XORLW 0x0
17A4  1D03     BTFSS STATUS, 0x2
17A5  0008     RETURN
17A6  2FF4     GOTO 0x7F4
2689:          
2690:              switch(SetupPkt.bRequest)
087C  0020     MOVLB 0x0
087D  0851     MOVF 0x51, W
087E  0084     MOVWF FSR0
087F  300D     MOVLW 0xD
0880  0204     SUBWF FSR0, W
0881  1803     BTFSC STATUS, 0x0
0882  0008     RETURN
0883  3190     MOVLP 0x10
0884  3504     LSLF FSR0, W
0885  3E1A     ADDLW 0x1A
0886  0082     MOVWF PCL
1000  3197     MOVLP 0x17
101A  3188     MOVLP 0x8
17F4  0020     MOVLB 0x0
17F5  0851     MOVF 0x51, W
17F6  0084     MOVWF FSR0
17F7  300D     MOVLW 0xD
17F8  0204     SUBWF FSR0, W
17F9  1803     BTFSC STATUS, 0x0
17FA  0008     RETURN
17FB  3190     MOVLP 0x10
17FC  3504     LSLF FSR0, W
17FD  3E00     ADDLW 0x0
17FE  0082     MOVWF PCL
2691:              {
2692:                  case USB_REQUEST_SET_ADDRESS:
2693:                      inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
082E  0021     MOVLB 0x1
082F  17C5     BSF 0xC5, 0x7
17A7  0021     MOVLB 0x1
17A8  17C5     BSF 0xC5, 0x7
2694:                      USBDeviceState = ADR_PENDING_STATE;       // Update state only
0830  3008     MOVLW 0x8
0831  0020     MOVLB 0x0
0832  00ED     MOVWF 0x6D
0833  086D     MOVF 0x6D, W
0834  0023     MOVLB 0x3
0835  00E5     MOVWF USBDeviceState
17A9  3008     MOVLW 0x8
17AA  00C1     MOVWF 0x1C1
17AB  0841     MOVF 0x1C1, W
17AC  0023     MOVLB 0x3
17AD  00E5     MOVWF USBDeviceState
2695:                      /* See USBCtrlTrfInHandler() for the next step */
2696:                      break;
0836  0008     RETURN
17AE  0008     RETURN
2697:                  case USB_REQUEST_GET_DESCRIPTOR:
2698:                      USBStdGetDscHandler();
0837  318B     MOVLP 0xB
0838  2398     CALL 0x398
17AF  318C     MOVLP 0xC
17B0  2417     CALL 0x417
2699:                      break;
0839  0008     RETURN
17B1  0008     RETURN
2700:                  case USB_REQUEST_SET_CONFIGURATION:
2701:                      USBStdSetCfgHandler();
083A  318D     MOVLP 0xD
083B  2519     CALL 0x519
17B2  318D     MOVLP 0xD
17B3  25A8     CALL 0x5A8
2702:                      break;
083C  0008     RETURN
17B4  0008     RETURN
2703:                  case USB_REQUEST_GET_CONFIGURATION:
2704:                      inPipes[0].pSrc.bRam = (uint8_t*)&USBActiveConfiguration;         // Set Source
083D  30EE     MOVLW 0xEE
083E  0021     MOVLB 0x1
083F  00C3     MOVWF inPipes
0840  3001     MOVLW 0x1
0841  00C4     MOVWF 0xC4
17B5  30EE     MOVLW 0xEE
17B6  0021     MOVLB 0x1
17B7  00C3     MOVWF inPipes
17B8  3001     MOVLW 0x1
17B9  00C4     MOVWF 0xC4
2705:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
0842  1445     BSF 0xC5, 0x0
17BA  1445     BSF 0xC5, 0x0
2706:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
0843  3001     MOVLW 0x1
0844  0020     MOVLB 0x0
0845  00ED     MOVWF 0x6D
0846  086D     MOVF 0x6D, W
0847  0021     MOVLB 0x1
0848  00C6     MOVWF 0xC6
17BB  3001     MOVLW 0x1
17BC  00C1     MOVWF 0xC1
17BD  0841     MOVF 0xC1, W
17BE  00C6     MOVWF 0xC6
2707:                      inPipes[0].info.bits.busy = 1;
0849  17C5     BSF 0xC5, 0x7
17BF  17C5     BSF 0xC5, 0x7
2708:                      break;
084A  0008     RETURN
17C0  0008     RETURN
2709:                  case USB_REQUEST_GET_STATUS:
2710:                      USBStdGetStatusHandler();
084B  3194     MOVLP 0x14
084C  246D     CALL 0x46D
17C1  3195     MOVLP 0x15
17C2  2517     CALL 0x517
2711:                      break;
084D  0008     RETURN
17C3  0008     RETURN
2712:                  case USB_REQUEST_CLEAR_FEATURE:
2713:                  case USB_REQUEST_SET_FEATURE:
2714:                      USBStdFeatureReqHandler();
084E  3181     MOVLP 0x1
084F  219C     CALL 0x19C
17C4  3180     MOVLP 0x0
17C5  205F     CALL 0x5F
2715:                      break;
0850  0008     RETURN
17C6  0008     RETURN
2716:                  case USB_REQUEST_GET_INTERFACE:
2717:                      inPipes[0].pSrc.bRam = (uint8_t*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
0851  0020     MOVLB 0x0
0852  0854     MOVF 0x54, W
0853  3EEB     ADDLW 0xEB
0854  0021     MOVLB 0x1
0855  00C3     MOVWF inPipes
0856  3001     MOVLW 0x1
0857  00C4     MOVWF 0xC4
17C7  0020     MOVLB 0x0
17C8  0854     MOVF 0x54, W
17C9  3EEB     ADDLW 0xEB
17CA  0021     MOVLB 0x1
17CB  00C3     MOVWF inPipes
17CC  3001     MOVLW 0x1
17CD  00C4     MOVWF 0xC4
2718:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
0858  1445     BSF 0xC5, 0x0
17CE  1445     BSF 0xC5, 0x0
2719:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
0859  3001     MOVLW 0x1
085A  0020     MOVLB 0x0
085B  00ED     MOVWF 0x6D
085C  086D     MOVF 0x6D, W
085D  0021     MOVLB 0x1
085E  00C6     MOVWF 0xC6
17CF  3001     MOVLW 0x1
17D0  00C1     MOVWF 0xC1
17D1  0841     MOVF 0xC1, W
17D2  00C6     MOVWF 0xC6
2720:                      inPipes[0].info.bits.busy = 1;
085F  17C5     BSF 0xC5, 0x7
17D3  17C5     BSF 0xC5, 0x7
2721:                      break;
0860  0008     RETURN
17D4  0008     RETURN
2722:                  case USB_REQUEST_SET_INTERFACE:
2723:                      inPipes[0].info.bits.busy = 1;
0861  0021     MOVLB 0x1
0862  17C5     BSF 0xC5, 0x7
17D5  0021     MOVLB 0x1
17D6  17C5     BSF 0xC5, 0x7
2724:                      USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
0863  0020     MOVLB 0x0
0864  0852     MOVF 0x52, W
0865  00ED     MOVWF 0x6D
0866  0854     MOVF 0x54, W
0867  3EEB     ADDLW 0xEB
0868  0086     MOVWF FSR1
0869  3001     MOVLW 0x1
086A  0087     MOVWF FSR1H
086B  086D     MOVF 0x6D, W
086C  0081     MOVWF INDF1
17D7  0020     MOVLB 0x0
17D8  0852     MOVF 0x52, W
17D9  0021     MOVLB 0x1
17DA  00C1     MOVWF 0xC1
17DB  0020     MOVLB 0x0
17DC  0854     MOVF 0x54, W
17DD  3EEB     ADDLW 0xEB
17DE  0086     MOVWF FSR1
17DF  3001     MOVLW 0x1
17E0  0087     MOVWF FSR1H
17E1  0021     MOVLB 0x1
17E2  0841     MOVF 0xC1, W
17E3  0081     MOVWF 0x81
2725:                      break;
086D  0008     RETURN
17E4  0008     RETURN
2726:                  case USB_REQUEST_SET_DESCRIPTOR:
2727:                      USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
086E  3000     MOVLW 0x0
086F  00E1     MOVWF 0xE1
0870  3002     MOVLW 0x2
0871  00E0     MOVWF 0xE0
0872  3000     MOVLW 0x0
0873  00E2     MOVWF 0xE2
0874  3000     MOVLW 0x0
0875  00E3     MOVWF 0xE3
0876  3000     MOVLW 0x0
0877  00E4     MOVWF 0xE4
0878  00E5     MOVWF 0xE5
0879  3192     MOVLP 0x12
087A  2205     CALL 0x205
17E5  3000     MOVLW 0x0
17E6  0021     MOVLB 0x1
17E7  00B5     MOVWF 0xB5
17E8  3002     MOVLW 0x2
17E9  00B4     MOVWF event
17EA  3000     MOVLW 0x0
17EB  00B6     MOVWF pdata
17EC  3000     MOVLW 0x0
17ED  00B7     MOVWF numBytesRead
17EE  3000     MOVLW 0x0
17EF  00B8     MOVWF size
17F0  00B9     MOVWF 0xB9
17F1  3192     MOVLP 0x12
17F2  2235     CALL 0x235
2728:                      break;
2729:                  case USB_REQUEST_SYNCH_FRAME:
2730:                  default:
2731:                      break;
2732:              }//end switch
087B  0008     RETURN
17F3  0008     RETURN
2733:          }//end USBCheckStdRequest
0887  0008     RETURN
17FF  0008     RETURN
2734:          
2735:          /********************************************************************
2736:           * Function:        void USBStdFeatureReqHandler(void)
2737:           *
2738:           * PreCondition:    None
2739:           *
2740:           * Input:           None
2741:           *
2742:           * Output:          Can alter BDT entries.  Can also modify USB stack
2743:           *                  Maintained variables.
2744:           *
2745:           * Side Effects:    None
2746:           *
2747:           * Overview:        This routine handles the standard SET & CLEAR
2748:           *                  FEATURES requests
2749:           *
2750:           * Note:            This is a private function, intended for internal 
2751:           *                  use by the USB stack, when processing SET/CLEAR
2752:           *                  feature requests.  
2753:           *******************************************************************/
2754:          static void USBStdFeatureReqHandler(void)
2755:          {
2756:              BDT_ENTRY *p;
2757:              EP_STATUS current_ep_data;
2758:              #if defined(__C32__)
2759:                  uint32_t* pUEP;
2760:              #else
2761:                  unsigned char* pUEP;             
2762:              #endif
2763:              
2764:          
2765:              #ifdef	USB_SUPPORT_OTG
2766:              //Check for USB On-The-Go (OTG) specific requests
2767:              if ((SetupPkt.bFeature == OTG_FEATURE_B_HNP_ENABLE)&&
2768:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2769:              {  
2770:                  inPipes[0].info.bits.busy = 1;
2771:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2772:                      USBOTGEnableHnp();
2773:                  else
2774:                      USBOTGDisableHnp();
2775:              }
2776:          
2777:              if ((SetupPkt.bFeature == OTG_FEATURE_A_HNP_SUPPORT)&&
2778:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2779:              {
2780:                  inPipes[0].info.bits.busy = 1;
2781:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2782:                      USBOTGEnableSupportHnp();
2783:                  else
2784:                      USBOTGDisableSupportHnp();
2785:              }
2786:          
2787:              if ((SetupPkt.bFeature == OTG_FEATURE_A_ALT_HNP_SUPPORT)&&
2788:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2789:              {
2790:                  inPipes[0].info.bits.busy = 1;
2791:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2792:                      USBOTGEnableAltHnp();
2793:                  else
2794:                      USBOTGDisableAltHnp();
2795:              }
2796:              #endif   //#ifdef USB_SUPPORT_OTG 
2797:          
2798:              //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
2799:              if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
2800:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
005F  0020     MOVLB 0x0
0060  0352     DECF 0x52, W
0061  1D03     BTFSS STATUS, 0x2
0062  2878     GOTO 0x78
0063  0850     MOVF SetupPkt, W
0064  391F     ANDLW 0x1F
0065  3A00     XORLW 0x0
0066  1D03     BTFSS STATUS, 0x2
0067  2878     GOTO 0x78
019C  0020     MOVLB 0x0
2801:              {
2802:                  inPipes[0].info.bits.busy = 1;
0068  0021     MOVLB 0x1
0069  17C5     BSF 0xC5, 0x7
01A5  0021     MOVLB 0x1
01A6  17C5     BSF 0xC5, 0x7
2803:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
006A  3003     MOVLW 0x3
006B  0020     MOVLB 0x0
006C  0651     XORWF 0x51, W
006D  1D03     BTFSS STATUS, 0x2
006E  2876     GOTO 0x76
01A7  3003     MOVLW 0x3
01A8  0020     MOVLB 0x0
01A9  0651     XORWF 0x51, W
01AA  1D03     BTFSS STATUS, 0x2
01AB  29B2     GOTO 0x1B2
2804:                      RemoteWakeup = true;
006F  3001     MOVLW 0x1
0070  0021     MOVLB 0x1
0071  00BA     MOVWF 0xBA
0072  083A     MOVF 0xBA, W
0073  0023     MOVLB 0x3
0074  00E0     MOVWF RemoteWakeup
0075  2878     GOTO 0x78
01AC  3001     MOVLW 0x1
01AD  00E6     MOVWF control_signal_bitmap
01AE  0866     MOVF control_signal_bitmap, W
01AF  0023     MOVLB 0x3
01B0  00E0     MOVWF RemoteWakeup
01B1  29B4     GOTO 0x1B4
2805:                  else
2806:                      RemoteWakeup = false;
0076  0023     MOVLB 0x3
0077  01E0     CLRF RemoteWakeup
01B2  0023     MOVLB 0x3
01B3  01E0     CLRF RemoteWakeup
2807:              }//end if
2808:          
2809:              //Check if the host sent a valid SET or CLEAR endpoint halt request.
2810:              if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
2811:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
2812:                 (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
2813:                 (USBDeviceState == CONFIGURED_STATE))
0078  0020     MOVLB 0x0
0079  0852     MOVF 0x52, W
007A  1D03     BTFSS STATUS, 0x2
007B  0008     RETURN
007C  0850     MOVF SetupPkt, W
007D  391F     ANDLW 0x1F
007E  3A02     XORLW 0x2
007F  1D03     BTFSS STATUS, 0x2
0080  0008     RETURN
0081  0854     MOVF 0x54, W
0082  390F     ANDLW 0xF
0083  3A00     XORLW 0x0
0084  1903     BTFSC STATUS, 0x2
0085  0008     RETURN
0086  0854     MOVF 0x54, W
0087  390F     ANDLW 0xF
0088  0021     MOVLB 0x1
0089  00BA     MOVWF 0xBA
008A  3003     MOVLW 0x3
008B  023A     SUBWF 0xBA, W
008C  1803     BTFSC 0x83, 0x0
008D  0008     RETURN
008E  3020     MOVLW 0x20
008F  0023     MOVLB 0x3
0090  0665     XORWF USBDeviceState, W
0091  1D03     BTFSS 0x183, 0x2
0092  0008     RETURN
01B4  0020     MOVLB 0x0
01B5  0852     MOVF 0x52, W
01B6  1D03     BTFSS STATUS, 0x2
01B7  0008     RETURN
01B8  0850     MOVF SetupPkt, W
01B9  391F     ANDLW 0x1F
01BA  3A02     XORLW 0x2
01BB  1D03     BTFSS STATUS, 0x2
01BC  0008     RETURN
01BD  0854     MOVF 0x54, W
01BE  390F     ANDLW 0xF
01BF  3A00     XORLW 0x0
01C0  1903     BTFSC STATUS, 0x2
01C1  0008     RETURN
01C2  0854     MOVF 0x54, W
01C3  390F     ANDLW 0xF
01C4  00E6     MOVWF 0x66
01C5  3003     MOVLW 0x3
01C6  0266     SUBWF 0x66, W
01C7  1803     BTFSC STATUS, 0x0
01C8  0008     RETURN
01C9  3020     MOVLW 0x20
01CA  0023     MOVLB 0x3
01CB  0665     XORWF USBDeviceState, W
01CC  1D03     BTFSS 0x183, 0x2
01CD  0008     RETURN
2814:              {
2815:          		//The request was valid.  Take control of the control transfer and
2816:          		//perform the host requested action.
2817:          		inPipes[0].info.bits.busy = 1;
0093  0021     MOVLB 0x1
0094  17C5     BSF 0xC5, 0x7
01CE  0021     MOVLB 0x1
01CF  17C5     BSF 0xC5, 0x7
2818:          
2819:                  //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
2820:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
0095  0020     MOVLB 0x0
0096  1BD4     BTFSC 0x54, 0x7
0097  28A9     GOTO 0xA9
01D0  0020     MOVLB 0x0
01D1  1BD4     BTFSC 0x54, 0x7
01D2  29E2     GOTO 0x1E2
2821:                  {
2822:                      p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
0098  0854     MOVF 0x54, W
0099  390F     ANDLW 0xF
009A  0709     ADDWF WREG, W
009B  3EBD     ADDLW 0xBD
009C  0086     MOVWF FSR1
009D  3001     MOVLW 0x1
009E  0087     MOVWF FSR1H
009F  3F40     MOVIW 0[FSR1]
00A0  0021     MOVLB 0x1
00A1  00BF     MOVWF p
00A2  3F41     MOVIW 1[FSR1]
00A3  00C0     MOVWF 0xC0
01D3  0854     MOVF 0xD4, W
01D4  390F     ANDLW 0xF
01D5  0709     ADDWF 0x89, W
01D6  3EBD     ADDLW 0xBD
01D7  0086     MOVWF 0x86
01D8  3001     MOVLW 0x1
01D9  0087     MOVWF 0x87
01DA  3F40     MOVIW 0[FSR1]
01DB  00EB     MOVWF 0xEB
01DC  3F41     MOVIW 1[FSR1]
01DD  00EC     MOVWF 0xEC
2823:                      current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
00A4  0020     MOVLB 0x0
00A5  0854     MOVF 0x54, W
00A6  390F     ANDLW 0xF
00A7  3EC7     ADDLW 0xC7
00A8  28BA     GOTO 0xBA
01DE  0854     MOVF 0x54, W
01DF  390F     ANDLW 0xF
01E0  3EC7     ADDLW 0xC7
01E1  29F0     GOTO 0x1F0
2824:                  }
2825:                  else
2826:                  {
2827:                      p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
00A9  0020     MOVLB 0x0
00AA  0854     MOVF 0x54, W
00AB  390F     ANDLW 0xF
00AC  0709     ADDWF WREG, W
00AD  3EB7     ADDLW 0xB7
00AE  0086     MOVWF FSR1
00AF  3001     MOVLW 0x1
00B0  0087     MOVWF FSR1H
00B1  3F40     MOVIW 0[FSR1]
00B2  0021     MOVLB 0x1
00B3  00BF     MOVWF p
00B4  3F41     MOVIW 1[FSR1]
00B5  00C0     MOVWF 0xC0
01E2  0854     MOVF 0xD4, W
01E3  390F     ANDLW 0xF
01E4  0709     ADDWF 0x89, W
01E5  3EB7     ADDLW 0xB7
01E6  0086     MOVWF 0x86
01E7  3001     MOVLW 0x1
01E8  0087     MOVWF 0x87
01E9  3F40     MOVIW 0[FSR1]
01EA  00EB     MOVWF 0xEB
01EB  3F41     MOVIW 1[FSR1]
01EC  00EC     MOVWF 0xEC
2828:                      current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
00B6  0020     MOVLB 0x0
00B7  0854     MOVF 0x54, W
00B8  390F     ANDLW 0xF
00B9  3ECA     ADDLW 0xCA
00BA  0086     MOVWF FSR1
00BB  3001     MOVLW 0x1
00BC  0087     MOVWF FSR1H
00BD  0801     MOVF INDF1, W
00BE  0021     MOVLB 0x1
00BF  00BA     MOVWF 0xBA
00C0  083A     MOVF 0xBA, W
00C1  00BE     MOVWF i
01ED  0854     MOVF 0xD4, W
01EE  390F     ANDLW 0xF
01EF  3ECA     ADDLW 0xCA
01F0  0086     MOVWF 0x86
01F1  3001     MOVLW 0x1
01F2  0087     MOVWF 0x87
01F3  0801     MOVF 0x81, W
01F4  00E6     MOVWF 0xE6
01F5  0866     MOVF 0xE6, W
01F6  00EA     MOVWF 0xEA
2829:                  }
2830:          
2831:                  //If ping pong buffering is enabled on the requested endpoint, need 
2832:                  //to point to the one that is the active BDT entry which the SIE will 
2833:                  //use for the next attempted transaction on that EP number.
2834:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2835:                      if(current_ep_data.bits.ping_pong_state == 0) //Check if even
00C2  183E     BTFSC i, 0x0
00C3  28CE     GOTO 0xCE
01F7  186A     BTFSC 0xEA, 0x0
01F8  2A03     GOTO 0x203
2836:                      {
2837:                          p = (BDT_ENTRY*)(((uintptr_t)p) & (~USB_NEXT_PING_PONG));
00C4  30FB     MOVLW 0xFB
00C5  00BA     MOVWF 0xBA
00C6  30FF     MOVLW 0xFF
00C7  00BB     MOVWF p
00C8  083F     MOVF p, W
00C9  053A     ANDWF 0xBA, W
00CA  00BF     MOVWF p
00CB  0840     MOVF 0xC0, W
00CC  053B     ANDWF p, W
00CD  28D3     GOTO 0xD3
01F9  30FB     MOVLW 0xFB
01FA  00E6     MOVWF 0xE6
01FB  30FF     MOVLW 0xFF
01FC  00E7     MOVWF 0xE7
01FD  086B     MOVF 0xEB, W
01FE  0566     ANDWF 0xE6, W
01FF  00EB     MOVWF 0xEB
0200  086C     MOVF 0xEC, W
0201  0567     ANDWF 0xE7, W
0202  2A08     GOTO 0x208
2838:                      }
2839:                      else //else must have been odd
2840:                      {
2841:                          p = (BDT_ENTRY*)(((uintptr_t)p) | USB_NEXT_PING_PONG);
00CE  3004     MOVLW 0x4
00CF  043F     IORWF p, W
00D0  00BF     MOVWF p
00D1  3000     MOVLW 0x0
00D2  0440     IORWF 0xC0, W
00D3  00C0     MOVWF 0xC0
0203  3004     MOVLW 0x4
0204  046B     IORWF 0xEB, W
0205  00EB     MOVWF 0xEB
0206  3000     MOVLW 0x0
0207  046C     IORWF 0xEC, W
0208  00EC     MOVWF 0xEC
2842:                      }
2843:                  #endif
2844:                  
2845:                  //Update the BDT pointers with the new, next entry based on the feature
2846:                  //  request
2847:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
00D4  0020     MOVLB 0x0
00D5  1BD4     BTFSC 0x54, 0x7
00D6  28E4     GOTO 0xE4
0209  1BD4     BTFSC 0x54, 0x7
020A  2A17     GOTO 0x217
2848:                  {
2849:                      pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
00D7  0854     MOVF 0x54, W
00D8  390F     ANDLW 0xF
00D9  0709     ADDWF WREG, W
00DA  3EBD     ADDLW 0xBD
00DB  0086     MOVWF FSR1
00DC  3001     MOVLW 0x1
00DD  0087     MOVWF FSR1H
00DE  0021     MOVLB 0x1
00DF  083F     MOVF p, W
00E0  3FC0     MOVWI 0[FSR1]
00E1  0840     MOVF 0xC0, W
00E2  3FC1     MOVWI 1[FSR1]
020B  0854     MOVF 0xD4, W
020C  390F     ANDLW 0xF
020D  0709     ADDWF 0x89, W
020E  3EBD     ADDLW 0xBD
020F  0086     MOVWF 0x86
0210  3001     MOVLW 0x1
0211  0087     MOVWF 0x87
0212  086B     MOVF 0xEB, W
0213  3FC0     MOVWI 0[FSR1]
0214  086C     MOVF 0xEC, W
0215  3FC1     MOVWI 1[FSR1]
2850:                  }
00E3  28F1     GOTO 0xF1
0216  2A22     GOTO 0x222
2851:                  else
2852:                  {
2853:                      pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
00E4  0020     MOVLB 0x0
00E5  0854     MOVF 0x54, W
00E6  390F     ANDLW 0xF
00E7  0709     ADDWF WREG, W
00E8  3EB7     ADDLW 0xB7
00E9  0086     MOVWF FSR1
00EA  3001     MOVLW 0x1
00EB  0087     MOVWF FSR1H
00EC  0021     MOVLB 0x1
00ED  083F     MOVF p, W
00EE  3FC0     MOVWI 0[FSR1]
00EF  0840     MOVF 0xC0, W
00F0  3FC1     MOVWI 1[FSR1]
0217  0854     MOVF 0xD4, W
0218  390F     ANDLW 0xF
0219  0709     ADDWF 0x89, W
021A  3EB7     ADDLW 0xB7
021B  0086     MOVWF 0x86
021C  3001     MOVLW 0x1
021D  0087     MOVWF 0x87
021E  086B     MOVF 0xEB, W
021F  3FC0     MOVWI 0[FSR1]
0220  086C     MOVF 0xEC, W
0221  3FC1     MOVWI 1[FSR1]
2854:                  }
2855:          
2856:          		//Check if it was a SET_FEATURE endpoint halt request
2857:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
00F1  3003     MOVLW 0x3
00F2  0020     MOVLB 0x0
00F3  0651     XORWF 0x51, W
00F4  1D03     BTFSS STATUS, 0x2
00F5  2917     GOTO 0x117
0222  3003     MOVLW 0x3
0223  0651     XORWF 0x51, W
0224  1D03     BTFSS STATUS, 0x2
0225  2A44     GOTO 0x244
2858:                  {
2859:                      if(p->STAT.UOWN == 1)
00F6  0021     MOVLB 0x1
00F7  083F     MOVF p, W
00F8  0086     MOVWF 0x86
00F9  0840     MOVF 0xC0, W
00FA  0087     MOVWF 0x87
00FB  1F81     BTFSS 0x81, 0x7
00FC  290B     GOTO 0x10B
0226  086B     MOVF 0xEB, W
0227  0086     MOVWF 0x86
0228  086C     MOVF 0xEC, W
0229  0087     MOVWF 0x87
022A  1F81     BTFSS 0x81, 0x7
022B  2A39     GOTO 0x239
2860:                      {
2861:                          //Mark that we are terminating this transfer and that the user
2862:                          //  needs to be notified later
2863:                          if(SetupPkt.EPDir == OUT_FROM_HOST)
00FD  0020     MOVLB 0x0
00FE  1BD4     BTFSC 0x54, 0x7
00FF  2904     GOTO 0x104
022C  1BD4     BTFSC 0x54, 0x7
022D  2A32     GOTO 0x232
2864:                          {
2865:                              ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
0100  0854     MOVF 0x54, W
0101  390F     ANDLW 0xF
0102  3EC7     ADDLW 0xC7
0103  2907     GOTO 0x107
022E  0854     MOVF 0x54, W
022F  390F     ANDLW 0xF
0230  3EC7     ADDLW 0xC7
0231  2A35     GOTO 0x235
2866:                          }
2867:                          else
2868:                          {
2869:                              ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
0104  0854     MOVF 0x54, W
0105  390F     ANDLW 0xF
0106  3ECA     ADDLW 0xCA
0107  0086     MOVWF FSR1
0108  3001     MOVLW 0x1
0109  0087     MOVWF FSR1H
010A  1481     BSF INDF1, 0x1
0232  0854     MOVF 0x54, W
0233  390F     ANDLW 0xF
0234  3ECA     ADDLW 0xCA
0235  0086     MOVWF FSR1
0236  3001     MOVLW 0x1
0237  0087     MOVWF FSR1H
0238  1481     BSF INDF1, 0x1
2870:                          }
2871:                      }
2872:          
2873:          			//Then STALL the endpoint
2874:                      p->STAT.Val |= _BSTALL;
010B  0021     MOVLB 0x1
010C  083F     MOVF p, W
010D  0086     MOVWF 0x86
010E  0840     MOVF 0xC0, W
010F  0087     MOVWF 0x87
0110  1501     BSF 0x81, 0x2
0239  086B     MOVF 0xEB, W
023A  0086     MOVWF 0x86
023B  086C     MOVF 0xEC, W
023C  0087     MOVWF 0x87
023D  1501     BSF 0x81, 0x2
2875:                      p->STAT.Val |= _USIE;
0111  083F     MOVF p, W
0112  0086     MOVWF 0x86
0113  0840     MOVF 0xC0, W
0114  0087     MOVWF 0x87
0115  1781     BSF 0x81, 0x7
023E  086B     MOVF 0xEB, W
023F  0086     MOVWF 0x86
0240  086C     MOVF 0xEC, W
0241  0087     MOVWF 0x87
0242  1781     BSF 0x81, 0x7
2876:                  }//if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
0116  0008     RETURN
0243  0008     RETURN
2877:                  else
2878:                  {
2879:          			//Else the request must have been a CLEAR_FEATURE endpoint halt.
2880:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2881:                          //toggle over the to the non-active BDT
2882:                          p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);  
0117  3004     MOVLW 0x4
0118  0021     MOVLB 0x1
0119  063F     XORWF p, W
011A  00BF     MOVWF p
011B  3000     MOVLW 0x0
011C  0640     XORWF 0xC0, W
011D  00C0     MOVWF 0xC0
0244  3004     MOVLW 0x4
0245  066B     XORWF 0xEB, W
0246  00EB     MOVWF 0xEB
0247  3000     MOVLW 0x0
0248  066C     XORWF 0xEC, W
0249  00EC     MOVWF 0xEC
2883:          
2884:                          if(p->STAT.UOWN == 1)
011E  083F     MOVF p, W
011F  0086     MOVWF 0x86
0120  0840     MOVF 0xC0, W
0121  0087     MOVWF 0x87
0122  1F81     BTFSS 0x81, 0x7
0123  2941     GOTO 0x141
024A  086B     MOVF 0xEB, W
024B  0086     MOVWF 0x86
024C  086C     MOVF 0xEC, W
024D  0087     MOVWF 0x87
024E  1F81     BTFSS 0x81, 0x7
024F  2A6D     GOTO 0x26D
2885:                          {
2886:                              //Clear UOWN and set DTS state so it will be correct the next time
2887:                              //the application firmware uses USBTransferOnePacket() on the EP.
2888:                              p->STAT.Val &= (~_USIE);    //Clear UOWN bit
0124  307F     MOVLW 0x7F
0125  00BA     MOVWF 0xBA
0126  083F     MOVF p, W
0127  0086     MOVWF 0x86
0128  0840     MOVF 0xC0, W
0129  0087     MOVWF 0x87
012A  083A     MOVF 0xBA, W
012B  0581     ANDWF 0x81, F
0250  307F     MOVLW 0x7F
0251  00E6     MOVWF 0xE6
0252  086B     MOVF 0xEB, W
0253  0086     MOVWF 0x86
0254  086C     MOVF 0xEC, W
0255  0087     MOVWF 0x87
0256  0866     MOVF 0xE6, W
0257  0581     ANDWF 0x81, F
2889:                              p->STAT.Val |= _DAT1;       //Set DTS to DATA1
012C  083F     MOVF p, W
012D  0086     MOVWF 0x86
012E  0840     MOVF 0xC0, W
012F  0087     MOVWF 0x87
0130  1701     BSF 0x81, 0x6
0258  086B     MOVF 0xEB, W
0259  0086     MOVWF 0x86
025A  086C     MOVF 0xEC, W
025B  0087     MOVWF 0x87
025C  1701     BSF 0x81, 0x6
2890:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
0131  3000     MOVLW 0x0
0132  00B5     MOVWF 0xB5
0133  3005     MOVLW 0x5
0134  00B4     MOVWF event
0135  0840     MOVF 0xC0, W
0136  00B7     MOVWF numBytesRead
0137  083F     MOVF p, W
0138  00B6     MOVWF pdata
0139  3002     MOVLW 0x2
013A  00B8     MOVWF size
013B  3000     MOVLW 0x0
013C  00B9     MOVWF 0xB9
013D  3192     MOVLP 0x12
013E  2235     CALL 0x235
013F  3180     MOVLP 0x0
025D  3000     MOVLW 0x0
025E  00E1     MOVWF 0xE1
025F  3005     MOVLW 0x5
0260  00E0     MOVWF 0xE0
0261  086C     MOVF 0xEC, W
0262  00E3     MOVWF 0xE3
0263  086B     MOVF 0xEB, W
0264  00E2     MOVWF 0xE2
0265  3002     MOVLW 0x2
0266  00E4     MOVWF 0xE4
0267  3000     MOVLW 0x0
0268  00E5     MOVWF 0xE5
0269  3192     MOVLP 0x12
026A  2205     CALL 0x205
026B  3181     MOVLP 0x1
2891:                          }
0140  2947     GOTO 0x147
026C  2A73     GOTO 0x273
2892:                          else
2893:                          {
2894:                              //UOWN already clear, but still need to set DTS to DATA1     
2895:          					p->STAT.Val |= _DAT1;
0141  0021     MOVLB 0x1
0142  083F     MOVF p, W
0143  0086     MOVWF 0x86
0144  0840     MOVF 0xC0, W
0145  0087     MOVWF 0x87
0146  1701     BSF 0x81, 0x6
026D  0020     MOVLB 0x0
026E  086B     MOVF USBStdFeatureReqHandler, W
026F  0086     MOVWF FSR1
0270  086C     MOVF 0x6C, W
0271  0087     MOVWF FSR1H
0272  1701     BSF INDF1, 0x6
2896:                          }
2897:          
2898:                          //toggle back to the active BDT (the one the SIE is currently looking at
2899:                          //and will use for the next successful transaction to take place on the EP
2900:                          p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);
0147  3004     MOVLW 0x4
0148  0021     MOVLB 0x1
0149  063F     XORWF p, W
014A  00BF     MOVWF p
014B  3000     MOVLW 0x0
014C  0640     XORWF 0xC0, W
014D  00C0     MOVWF 0xC0
0273  3004     MOVLW 0x4
0274  0020     MOVLB 0x0
0275  066B     XORWF USBStdFeatureReqHandler, W
0276  00EB     MOVWF USBStdFeatureReqHandler
0277  3000     MOVLW 0x0
0278  066C     XORWF 0x6C, W
0279  00EC     MOVWF 0x6C
2901:                          
2902:                          //Check if we are currently terminating, or have previously terminated
2903:                          //a transaction on the given endpoint.  If so, need to clear UOWN,
2904:                          //set DTS to the proper state, and call the application callback
2905:                          //function.
2906:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
014E  18BE     BTFSC 0x3E, 0x1
014F  2956     GOTO 0x156
0150  083F     MOVF 0x3F, W
0151  0086     MOVWF FSR1
0152  0840     MOVF 0x40, W
0153  0087     MOVWF FSR1H
0154  1F81     BTFSS INDF1, 0x7
0155  297D     GOTO 0x17D
027A  18EA     BTFSC USBStdSetCfgHandler, 0x1
027B  2A82     GOTO 0x282
027C  086B     MOVF USBStdFeatureReqHandler, W
027D  0086     MOVWF FSR1
027E  086C     MOVF 0x6C, W
027F  0087     MOVWF FSR1H
0280  1F81     BTFSS INDF1, 0x7
0281  2AA7     GOTO 0x2A7
2907:                          {
2908:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
0156  0020     MOVLB 0x0
0157  1BD4     BTFSC 0x54, 0x7
0158  295D     GOTO 0x15D
0282  1BD4     BTFSC 0x54, 0x7
0283  2A88     GOTO 0x288
2909:                              {
2910:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
0159  0854     MOVF 0x54, W
015A  390F     ANDLW 0xF
015B  3EC7     ADDLW 0xC7
015C  2960     GOTO 0x160
0284  0854     MOVF 0x54, W
0285  390F     ANDLW 0xF
0286  3EC7     ADDLW 0xC7
0287  2A8B     GOTO 0x28B
2911:                              }
2912:                              else
2913:                              {
2914:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
015D  0854     MOVF 0x54, W
015E  390F     ANDLW 0xF
015F  3ECA     ADDLW 0xCA
0160  0086     MOVWF FSR1
0161  3001     MOVLW 0x1
0162  0087     MOVWF FSR1H
0163  1081     BCF INDF1, 0x1
0288  0854     MOVF 0x54, W
0289  390F     ANDLW 0xF
028A  3ECA     ADDLW 0xCA
028B  0086     MOVWF FSR1
028C  3001     MOVLW 0x1
028D  0087     MOVWF FSR1H
028E  1081     BCF INDF1, 0x1
2915:                              }
2916:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
2917:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);  
0164  303B     MOVLW 0x3B
0165  0021     MOVLB 0x1
0166  00BA     MOVWF 0xBA
0167  083F     MOVF p, W
0168  0086     MOVWF 0x86
0169  0840     MOVF 0xC0, W
016A  0087     MOVWF 0x87
016B  083A     MOVF 0xBA, W
016C  0581     ANDWF 0x81, F
028F  303B     MOVLW 0x3B
0290  00E6     MOVWF 0xE6
0291  086B     MOVF 0xEB, W
0292  0086     MOVWF 0x86
0293  086C     MOVF 0xEC, W
0294  0087     MOVWF 0x87
0295  0866     MOVF 0xE6, W
0296  0581     ANDWF 0x81, F
2918:                              //Call the application event handler callback function, so it can 
2919:          					//decide if the endpoint should get re-armed again or not.
2920:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
016D  3000     MOVLW 0x0
016E  00B5     MOVWF 0xB5
016F  3005     MOVLW 0x5
0170  00B4     MOVWF event
0171  0840     MOVF 0xC0, W
0172  00B7     MOVWF numBytesRead
0173  083F     MOVF p, W
0174  00B6     MOVWF pdata
0175  3002     MOVLW 0x2
0176  00B8     MOVWF size
0177  3000     MOVLW 0x0
0178  00B9     MOVWF 0xB9
0179  3192     MOVLP 0x12
017A  2235     CALL 0x235
017B  3180     MOVLP 0x0
0297  3000     MOVLW 0x0
0298  00E1     MOVWF 0xE1
0299  3005     MOVLW 0x5
029A  00E0     MOVWF 0xE0
029B  086C     MOVF 0xEC, W
029C  00E3     MOVWF 0xE3
029D  086B     MOVF 0xEB, W
029E  00E2     MOVWF 0xE2
029F  3002     MOVLW 0x2
02A0  00E4     MOVWF 0xE4
02A1  3000     MOVLW 0x0
02A2  00E5     MOVWF 0xE5
02A3  3192     MOVLP 0x12
02A4  2205     CALL 0x205
02A5  3181     MOVLP 0x1
2921:                          }
017C  2986     GOTO 0x186
02A6  2AB0     GOTO 0x2B0
2922:                          else
2923:                          {
2924:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
2925:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL); 
017D  303B     MOVLW 0x3B
017E  0021     MOVLB 0x1
017F  00BA     MOVWF 0xBA
0180  083F     MOVF p, W
0181  0086     MOVWF 0x86
0182  0840     MOVF 0xC0, W
0183  0087     MOVWF 0x87
0184  083A     MOVF 0xBA, W
0185  0581     ANDWF 0x81, F
02A7  303B     MOVLW 0x3B
02A8  0020     MOVLB 0x0
02A9  00E6     MOVWF 0x66
02AA  086B     MOVF USBStdFeatureReqHandler, W
02AB  0086     MOVWF FSR1
02AC  086C     MOVF 0x6C, W
02AD  0087     MOVWF FSR1H
02AE  0866     MOVF 0x66, W
02AF  0581     ANDWF INDF1, F
2926:                          } 
2927:                      #else //else we must not be using ping-pong buffering on the requested endpoint
2928:                          //Check if we need to call the user transfer terminated event callback function.
2929:                          //We should call the callback, if the endpoint was previously terminated,
2930:                          //or the endpoint is currently armed, and the host is performing clear
2931:                          //endpoint halt, even though the endpoint wasn't stalled.
2932:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
2933:                          {
2934:                              //We are going to call the user transfer terminated callback.
2935:                              //Clear the flag so we know we took care of it and don't need
2936:                              //to call it again later.
2937:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
2938:                              {
2939:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
2940:                              }
2941:                              else
2942:                              {
2943:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
2944:                              }
2945:           
2946:                              //Clear UOWN and remove the STALL condition.   
2947:                              //  In this case we also need to set the DTS bit to 1 so that
2948:                              //  it toggles to DATA0 the next time the application firmware
2949:                              //  calls USBTransferOnePacket() (or equivalent macro).  
2950:                              p->STAT.Val &= ~(_USIE | _BSTALL);  
2951:                              p->STAT.Val |= _DAT1;
2952:                              //Let the application firmware know a transaction just
2953:                              //got terminated by the host, and that it is now free to
2954:                              //re-arm the endpoint or do other tasks if desired.                                        
2955:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
2956:                          }
2957:                          else
2958:                          {
2959:                              //Clear UOWN and remove the STALL condition.   
2960:                              //  In this case we also need to set the DTS bit to 1 so that
2961:                              //  it toggles to DATA0 the next time the application firmware
2962:                              //  calls USBTransferOnePacket() (or equivalent macro).  
2963:                              p->STAT.Val &= ~(_USIE | _BSTALL);  
2964:                              p->STAT.Val |= _DAT1;
2965:                          } 
2966:                      #endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2967:                      
2968:          			//Get a pointer to the appropriate UEPn register
2969:                      #if defined(__C32__)
2970:                          pUEP = (uint32_t*)(&U1EP0);
2971:                          pUEP += (SetupPkt.EPNum*4);
2972:                      #else
2973:                          pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
0186  0020     MOVLB 0x0
0187  0854     MOVF 0x54, W
0188  390F     ANDLW 0xF
0189  3E98     ADDLW 0x98
018A  0021     MOVLB 0x1
018B  00BA     MOVWF 0xBA
018C  01BB     CLRF p
018D  300E     MOVLW 0xE
018E  3DBB     ADDWFC p, F
018F  083A     MOVF 0xBA, W
0190  00BC     MOVWF pUEP
0191  083B     MOVF p, W
0192  00BD     MOVWF i
02B0  0020     MOVLB 0x0
02B1  0854     MOVF 0x54, W
02B2  390F     ANDLW 0xF
02B3  3E98     ADDLW 0x98
02B4  00E6     MOVWF 0x66
02B5  01E7     CLRF USBStdSetCfgHandler
02B6  300E     MOVLW 0xE
02B7  3DE7     ADDWFC USBStdSetCfgHandler, F
02B8  0866     MOVF 0x66, W
02B9  00E8     MOVWF USBStdFeatureReqHandler
02BA  0867     MOVF USBStdSetCfgHandler, W
02BB  00E9     MOVWF USBStdSetCfgHandler
2974:                      #endif
2975:          
2976:          			//Clear the STALL bit in the UEP register
2977:                      *pUEP &= ~UEP_STALL;            
0193  30FE     MOVLW 0xFE
0194  00BA     MOVWF 0x3A
0195  083C     MOVF 0x3C, W
0196  0086     MOVWF FSR1
0197  083D     MOVF 0x3D, W
0198  0087     MOVWF FSR1H
0199  083A     MOVF 0x3A, W
019A  0581     ANDWF INDF1, F
02BC  30FE     MOVLW 0xFE
02BD  00E6     MOVWF 0x66
02BE  0868     MOVF USBStdFeatureReqHandler, W
02BF  0086     MOVWF FSR1
02C0  0869     MOVF USBStdSetCfgHandler, W
02C1  0087     MOVWF FSR1H
02C2  0866     MOVF 0x66, W
02C3  0581     ANDWF INDF1, F
2978:                  }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
019B  0008     RETURN
02C4  0008     RETURN
2979:              }//end if (lots of checks for set/clear endpoint halt)
2980:          }//end USBStdFeatureReqHandler
2981:          
2982:          
2983:          
2984:          
2985:          /**************************************************************************
2986:              Function:
2987:                  void USBIncrement1msInternalTimers(void)
2988:          
2989:              Description:
2990:                  This function increments internal 1ms time base counters, which are
2991:                  useful for application code (that can use a 1ms time base/counter), and
2992:                  for certain USB event timing specific purposes.
2993:          
2994:                  In USB full speed applications, the application code does not need to (and should
2995:                  not) explicitly call this function, as the USBDeviceTasks() function will
2996:                  automatically call this function whenever a 1ms time interval has elapsed
2997:                  (assuming the code is calling USBDeviceTasks() frequently enough in USB_POLLING
2998:                  mode, or that USB interrupts aren't being masked for more than 1ms at a time
2999:                  in USB_INTERRUPT mode).
3000:          
3001:                  In USB low speed applications, the application firmware is responsible for
3002:                  periodically calling this function at a ~1ms rate.  This can be done using
3003:                  a general purpose microcontroller timer set to interrupt every 1ms for example.
3004:                  If the low speed application code does not call this function, the internal timers
3005:                  will not increment, and the USBGet1msTickCount() API function will not be available.
3006:                  Additionally, certain USB stack operations (like control transfer timeouts)
3007:                  may be unavailable.
3008:          
3009:              Precondition:
3010:                  This function should be called only after USBDeviceInit() has been
3011:                  called (at least once at the start of the application).  Ordinarily,
3012:                  application code should never call this function, unless it is a low speed
3013:                  USB device.
3014:          
3015:              Parameters:
3016:                  None
3017:          
3018:              Return Values:
3019:                  None
3020:          
3021:              Remarks:
3022:                  This function does not need to be called during USB suspend conditions, when
3023:                  the USB module/stack is disabled, or when the USB cable is detached from the host.
3024:            ***************************************************************************/
3025:          void USBIncrement1msInternalTimers(void)
3026:          {
3027:              #if(USB_SPEED_OPTION == USB_LOW_SPEED)
3028:                  #warning "For low speed USB applications, read the function comments for the USBIncrement1msInternalTimers() function, and implement code to call this function periodically."
3029:              #endif
3030:          
3031:              //Increment timekeeping 1ms tick counters.  Useful for other APIs/code
3032:              //that needs a 1ms time base that is active during USB non-suspended operation.
3033:              USB1msTickCount++;
1095  3001     MOVLW 0x1
10E0  3001     MOVLW 0x1
10E1  0023     MOVLB 0x3
10E2  07C3     ADDWF USB1msTickCount, F
10E3  3000     MOVLW 0x0
10E4  3DC4     ADDWFC 0x1C4, F
10E5  3000     MOVLW 0x0
10E6  3DC5     ADDWFC 0x1C5, F
10E7  3000     MOVLW 0x0
10E8  3DC6     ADDWFC 0x1C6, F
3034:              if(USBIsBusSuspended() == false)
109E  085F     MOVF USBBusIsSuspended, W
109F  1D03     BTFSS 0x183, 0x2
10A0  0008     RETURN
10E9  085F     MOVF USBBusIsSuspended, W
10EA  1D03     BTFSS 0x183, 0x2
10EB  0008     RETURN
3035:              {
3036:                  USBTicksSinceSuspendEnd++;
10A1  3001     MOVLW 0x1
10A2  00F0     MOVWF 0x1F0
10A3  0870     MOVF 0x1F0, W
10A4  07D6     ADDWF USBTicksSinceSuspendEnd, F
10EC  3001     MOVLW 0x1
10ED  0021     MOVLB 0x1
10EE  00A6     MOVWF length
10EF  0826     MOVF length, W
10F0  0023     MOVLB 0x3
10F1  07D6     ADDWF USBTicksSinceSuspendEnd, F
3037:                  //Check for 8-bit wraparound.  If so, force it to saturate at 255.
3038:                  if(USBTicksSinceSuspendEnd == 0)
10A5  0856     MOVF USBTicksSinceSuspendEnd, W
10A6  1D03     BTFSS 0x183, 0x2
10A7  0008     RETURN
10F2  0856     MOVF USBTicksSinceSuspendEnd, W
10F3  1D03     BTFSS 0x183, 0x2
10F4  0008     RETURN
3039:                  {
3040:                      USBTicksSinceSuspendEnd = 255;
10A8  30FF     MOVLW 0xFF
10A9  00F0     MOVWF 0x1F0
10AA  0870     MOVF 0x1F0, W
10AB  00D6     MOVWF USBTicksSinceSuspendEnd
10F5  30FF     MOVLW 0xFF
10F6  0021     MOVLB 0x1
10F7  00A6     MOVWF length
10F8  0826     MOVF length, W
10F9  0023     MOVLB 0x3
10FA  00D6     MOVWF USBTicksSinceSuspendEnd
3041:                  }
10AC  0008     RETURN
10FB  0008     RETURN
3042:              }
3043:          }
3044:          
3045:          
3046:          
3047:          
3048:          /**************************************************************************
3049:              Function:
3050:                  uint32_t USBGet1msTickCount(void)
3051:          
3052:              Description:
3053:                  This function retrieves a 32-bit unsigned integer that normally increments by
3054:                  one every one millisecond.  The count value starts from zero when the
3055:                  USBDeviceInit() function is first called.  See the remarks section for
3056:                  details on special circumstances where the tick count will not increment.
3057:          
3058:              Precondition:
3059:                  This function should be called only after USBDeviceInit() has been
3060:                  called (at least once at the start of the application).
3061:          
3062:              Parameters:
3063:                  None
3064:          
3065:              Return Values:
3066:                  uint32_t representing the approximate millisecond count, since the time the
3067:                  USBDeviceInit() function was first called.
3068:          
3069:              Remarks:
3070:                  On 8-bit USB full speed devices, the internal counter is incremented on
3071:                  every SOF packet detected.  Therefore, it will not increment during suspend
3072:                  or when the USB cable is detached.  However, on 16-bit devices, the T1MSECIF
3073:                  hardware interrupt source is used to increment the internal counter.  Therefore,
3074:                  on 16-bit devices, the count continue to increment during USB suspend or
3075:                  detach events, so long as the application code has not put the microcontroller
3076:                  to sleep during these events, and the application firmware is regularly
3077:                  calling the USBDeviceTasks() function (or allowing it to execute, if using
3078:                  USB_INTERRUPT mode operation).
3079:          
3080:                  In USB low speed applications, the host does not broadcast SOF packets to
3081:                  the device, so the application firmware becomes responsible for calling
3082:                  USBIncrement1msInternalTimers() periodically (ex: from a general purpose
3083:                  timer interrupt handler), or else the returned value from this function will
3084:                  not increment.
3085:                  
3086:                  Prior to calling USBDeviceInit() for the first time the returned value will
3087:                  be unpredictable.
3088:          
3089:                  This function is USB_INTERRUPT mode safe and may be called from main loop
3090:                  code without risk of retrieving a partially updated 32-bit number.
3091:          
3092:                  However, this value only increments when the USBDeviceTasks() function is allowed
3093:                  to execute.  If USB_INTERRUPT mode is used, it is allowable to block on this
3094:                  function.  If however USB_POLLING mode is used, one must not block on this
3095:                  function without also calling USBDeviceTasks() continuously for the blocking
3096:                  duration (since the USB stack must still be allowed to execute, and the USB
3097:                  stack is also responsible for updating the tick counter internally).
3098:          
3099:                  If the application is operating in USB_POLLING mode, this function should
3100:                  only be called from the main loop context, and not from an interrupt handler,
3101:                  as the returned value could be incorrect, if the main loop context code was in
3102:                  the process of updating the internal count at the moment of the interrupt event.
3103:             ***************************************************************************/
3104:          uint32_t USBGet1msTickCount(void)
3105:          {
3106:              #if defined (USB_INTERRUPT)
3107:                  uint32_t localContextValue;
3108:          
3109:                  //Repeatedly read the interrupt context variable, until we get a stable/unchanging
3110:                  //value.  This ensures that the complete 32-bit value got read without
3111:                  //getting interrupted in between bytes.
3112:                  do
3113:                  {
3114:                      localContextValue = USB1msTickCount;
3115:                  }while(localContextValue != USB1msTickCount);
3116:          
3117:                  return localContextValue;    
3118:              
3119:              #else
3120:                  return USB1msTickCount;
3121:              #endif
3122:          }
3123:          
3124:          
3125:          
3126:          
3127:          
3128:          
3129:          /** EOF USBDevice.c *****************************************************/
---  C:/Users/LarsErik/MPLABXProjects/blink.X/mcc_generated_files/pin_manager.c  ------------------------
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using MPLAB(c) Code Configurator
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 4.35
17:                    Device            :  PIC16F1454
18:                    Driver Version    :  1.02
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.40
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            
25:                Microchip licenses to you the right to use, modify, copy and distribute
26:                Software only when embedded on a Microchip microcontroller or digital signal
27:                controller that is integrated into your product or third party product
28:                (pursuant to the sublicense terms in the accompanying license agreement).
29:            
30:                You should refer to the license agreement accompanying this Software for
31:                additional information regarding your rights and obligations.
32:            
33:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:            
44:            */
45:            
46:            #include <xc.h>
47:            #include "pin_manager.h"
48:            #include "stdbool.h"
49:            
50:            
51:            
52:            void PIN_MANAGER_Initialize(void)
53:            {
54:                /**
55:                LATx registers
56:                */   
57:                LATA = 0x00;    
1069  0022     MOVLB 0x2
106A  018C     CLRF LATA
58:                LATC = 0x00;    
106B  018E     CLRF LATC
59:            
60:                /**
61:                TRISx registers
62:                */    
63:                TRISA = 0x30;
106C  3030     MOVLW 0x30
106D  0021     MOVLB 0x1
106E  008C     MOVWF TRISA
64:                TRISC = 0x37;
106F  3037     MOVLW 0x37
1070  008E     MOVWF TRISC
65:            
66:                /**
67:                ANSELx registers
68:                */   
69:                ANSELC = 0x0F;
1071  300F     MOVLW 0xF
1072  0023     MOVLB 0x3
1073  008E     MOVWF ANSELC
70:                ANSELA = 0x10;
1074  3010     MOVLW 0x10
1075  008C     MOVWF ANSELA
71:            
72:                /**
73:                WPUx registers
74:                */ 
75:                WPUA = 0x00;
1076  0024     MOVLB 0x4
1077  018C     CLRF WPUA
76:                OPTION_REGbits.nWPUEN = 1;
1078  0021     MOVLB 0x1
1079  1795     BSF OPTION_REG, 0x7
77:            
78:                
79:                /**
80:                APFCONx registers
81:                */
82:                APFCON = 0x00;
107A  0022     MOVLB 0x2
107B  019D     CLRF APFCON
83:            
84:            
85:               
86:                
87:            }       
107C  0008     RETURN
88:            
89:            void PIN_MANAGER_IOC(void)
90:            {   
91:            
92:            }
93:            
94:            /**
95:             End of File
96:            */
---  C:/Users/LarsErik/MPLABXProjects/blink.X/mcc_generated_files/mcc.c  --------------------------------
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65
17:                    Device            :  PIC16F1454
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45 or later
21:                    MPLAB             :  MPLAB X 4.10
22:            */
23:            
24:            /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:            */
45:            
46:            // Configuration bits: selected in the GUI
47:            
48:            // CONFIG1
49:            #pragma config FOSC = INTOSC    // Oscillator Selection Bits->INTOSC oscillator: I/O function on CLKIN pin
50:            #pragma config WDTE = OFF    // Watchdog Timer Enable->WDT disabled
51:            #pragma config PWRTE = OFF    // Power-up Timer Enable->PWRT disabled
52:            #pragma config MCLRE = ON    // MCLR Pin Function Select->MCLR/VPP pin function is MCLR
53:            #pragma config CP = OFF    // Flash Program Memory Code Protection->Program memory code protection is disabled
54:            #pragma config BOREN = ON    // Brown-out Reset Enable->Brown-out Reset enabled
55:            #pragma config CLKOUTEN = OFF    // Clock Out Enable->CLKOUT function is disabled. I/O or oscillator function on the CLKOUT pin
56:            #pragma config IESO = ON    // Internal/External Switchover Mode->Internal/External Switchover Mode is enabled
57:            #pragma config FCMEN = ON    // Fail-Safe Clock Monitor Enable->Fail-Safe Clock Monitor is enabled
58:            
59:            // CONFIG2
60:            #pragma config WRT = OFF    // Flash Memory Self-Write Protection->Write protection off
61:            #pragma config CPUDIV = NOCLKDIV    // CPU System Clock Selection Bit->NO CPU system divide
62:            #pragma config USBLSCLK = 48MHz    // USB Low SPeed Clock Selection bit->System clock expects 48 MHz, FS/LS USB CLKENs divide-by is set to 8.
63:            #pragma config PLLMULT = 3x    // PLL Multipler Selection Bit->3x Output Frequency Selected
64:            #pragma config PLLEN = ENABLED    // PLL Enable Bit->3x or 4x PLL Enabled
65:            #pragma config STVREN = ON    // Stack Overflow/Underflow Reset Enable->Stack Overflow or Underflow will cause a Reset
66:            #pragma config BORV = LO    // Brown-out Reset Voltage Selection->Brown-out Reset Voltage (Vbor), low trip point selected.
67:            #pragma config LPBOR = OFF    // Low-Power Brown Out Reset->Low-Power BOR is disabled
68:            #pragma config LVP = ON    // Low-Voltage Programming Enable->Low-voltage programming enabled
69:            
70:            #include "mcc.h"
71:            
72:            
73:            void SYSTEM_Initialize(void)
74:            {
75:            
76:                PIN_MANAGER_Initialize();
1039  3190     MOVLP 0x10
103A  2069     CALL 0x69
103B  3190     MOVLP 0x10
77:                OSCILLATOR_Initialize();
103C  319F     MOVLP 0x1F
103D  27DC     CALL 0x7DC
103E  3190     MOVLP 0x10
78:                WDT_Initialize();
103F  3187     MOVLP 0x7
1040  27FC     CALL 0x7FC
1041  3190     MOVLP 0x10
79:                USBDeviceInit();
1042  3185     MOVLP 0x5
1043  2562     CALL 0x562
1044  3190     MOVLP 0x10
80:                USBDeviceAttach();
1045  3190     MOVLP 0x10
1046  20FC     CALL 0xFC
81:            }
1047  0008     RETURN
82:            
83:            void OSCILLATOR_Initialize(void)
84:            {
85:                // SCS FOSC; SPLLMULT 3xPLL; SPLLEN disabled; IRCF 16MHz_HF; 
86:                OSCCON = 0x7C;
1FDC  307C     MOVLW 0x7C
1FDD  0021     MOVLB 0x1
1FDE  0099     MOVWF OSCCON
87:                // TUN 0; 
88:                OSCTUNE = 0x00;
1FDF  0198     CLRF OSCTUNE
89:                // ACTSRC SOSC; ACTUD enabled; ACTEN disabled; 
90:                ACTCON = 0x00;
1FE0  0027     MOVLB 0x7
1FE1  019B     CLRF ACTCON
91:                // SBOREN disabled; BORFS disabled; 
92:                BORCON = 0x00;
1FE2  0022     MOVLB 0x2
1FE3  0196     CLRF BORCON
93:                // Wait for PLL to stabilize
94:                while(PLLRDY == 0)
95:                {
96:                }
1FE4  0021     MOVLB 0x1
1FE5  1B1A     BTFSC OSCSTAT, 0x6
1FE6  0008     RETURN
1FE7  2FE4     GOTO 0x7E4
97:            }
0004  147E     BSF 0xFE, 0x0
98:            
99:            void WDT_Initialize(void)
100:           {
101:               // WDTPS 1:65536; SWDTEN OFF; 
102:               WDTCON = 0x16;
07FC  3016     MOVLW 0x16
07FD  0021     MOVLB 0x1
07FE  0097     MOVWF WDTCON
103:           }
07FF  0008     RETURN
104:           
105:           /**
106:            End of File
107:           */
---  C:/Users/LarsErik/MPLABXProjects/blink.X/mcc_generated_files/interrupt_manager.c  ------------------
1:             /**
2:               Generated Interrupt Manager Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.c
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65
19:                    Device            :  PIC16F1454
20:                    Driver Version    :  1.03
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 1.45 or later
23:                    MPLAB 	          :  MPLAB X 4.10
24:            */
25:            
26:            /*
27:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
28:                software and any derivatives exclusively with Microchip products.
29:            
30:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
31:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
32:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
33:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
34:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
35:            
36:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
37:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
38:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
39:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
40:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
41:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
42:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
43:            
44:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
45:                TERMS.
46:            */
47:            
48:            #include "interrupt_manager.h"
49:            #include "mcc.h"
50:            
51:            void interrupt INTERRUPT_InterruptManager (void)
0004  147E     BSF 0xFE, 0x0
0005  3180     MOVLP 0x0
0006  0020     MOVLB 0x0
0007  087F     MOVF 0x7F, W
0008  0021     MOVLB 0x1
0009  00A5     MOVWF 0xA5
52:            {
53:                // interrupt handler
54:                if(INTCONbits.PEIE == 1)
000A  1B0B     BTFSC 0x8B, 0x6
55:                {
56:                    if(PIE2bits.USBIE == 1 && PIR2bits.USBIF == 1)
000B  1D12     BTFSS PIE2, 0x2
000C  2812     GOTO 0x12
000D  0020     MOVLB 0x0
000E  1D12     BTFSS PIR2, 0x2
000F  2812     GOTO 0x12
57:                    {
58:                        USB_USBDeviceTasks();
0010  3183     MOVLP 0x3
0011  23AE     CALL 0x3AE
59:                    } 
60:                    else
61:                    {
62:                        //Unhandled Interrupt
63:                    }
64:                }      
65:                else
66:                {
67:                    //Unhandled Interrupt
68:                }
69:            }
0012  0021     MOVLB 0x1
0013  0825     MOVF 0xA5, W
0014  0020     MOVLB 0x0
0015  00FF     MOVWF 0x7F
0016  107E     BCF 0x7E, 0x0
0017  0009     RETFIE
70:            /**
71:             End of File
72:            */
---  C:/Users/LarsErik/MPLABXProjects/blink.X/main.c  ---------------------------------------------------
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65
17:                    Device            :  PIC16F1454
18:                    Driver Version    :  2.00
19:            */
20:            
21:            /*
22:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
23:                software and any derivatives exclusively with Microchip products.
24:            
25:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
26:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
27:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
28:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
29:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
30:            
31:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
32:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
33:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
34:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
35:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
36:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
37:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
38:            
39:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
40:                TERMS.
41:            */
42:            
43:            #include "mcc_generated_files/mcc.h"
44:            
45:            /** VARIABLES ******************************************************/
46:            
47:            static bool buttonPressed;
48:            static char buttonMessage[] = "Button pressed.\r\n";
49:            static uint8_t readBuffer[CDC_DATA_OUT_EP_SIZE];
50:            static uint8_t writeBuffer[CDC_DATA_IN_EP_SIZE];
51:            
52:            
53:            void UserApplication(void);
54:            
55:            /*
56:                                     Main application
57:             */
58:            void main(void)
59:            {
60:                
61:                // initialize the device
62:                SYSTEM_Initialize();
1048  3190     MOVLP 0x10
1049  2039     CALL 0x39
104A  3190     MOVLP 0x10
63:                CDCInitEP();
104B  3193     MOVLP 0x13
104C  2307     CALL 0x307
104D  3190     MOVLP 0x10
64:                RC3 = 0;
104E  0020     MOVLB 0x0
104F  118E     BCF PORTC, 0x3
65:                // When using interrupts, you need to set the Global and Peripheral Interrupt Enable bits
66:                // Use the following macros to:
67:            
68:                // Enable the Global Interrupts
69:                //INTERRUPT_GlobalInterruptEnable();
70:            
71:                // Enable the Peripheral Interrupts
72:                //INTERRUPT_PeripheralInterruptEnable();
73:            
74:                // Disable the Global Interrupts
75:                //INTERRUPT_GlobalInterruptDisable();
76:            
77:                // Disable the Peripheral Interrupts
78:                //INTERRUPT_PeripheralInterruptDisable();
79:                
80:                
81:                while(1)
1056  2850     GOTO 0x50
82:                {
83:                    USBDeviceTasks(); //Takes care of enumeration and other USB events
1050  3182     MOVLP 0x2
1051  22C5     CALL 0x2C5
1052  3190     MOVLP 0x10
84:                    
85:                    
86:            
87:                    //Otherwise we are free to run USB and non-USB related user 
88:                    //application code.
89:                    UserApplication();
1053  3194     MOVLP 0x14
1054  24C2     CALL 0x4C2
1055  3190     MOVLP 0x10
1056  2850     GOTO 0x50
90:                        
91:                    
92:                }
93:            }
94:            
95:            void UserApplication(void) 
96:            {
97:                 /* If the USB device isn't configured yet, we can't really do anything
98:                 * else since we don't have a host to talk to.  So jump back to the
99:                 * top of the while loop. 
100:                * OR If we are currently suspended, then we need to see if we need to
101:                * issue a remote wakeup.  In either case, we shouldn't process any
102:                * keyboard commands since we aren't currently communicating to the host
103:                * thus just continue back to the start of the while loop. */
104:               if( USBGetDeviceState() < CONFIGURED_STATE || USBIsDeviceSuspended()== true )
14C2  3020     MOVLW 0x20
14C3  0023     MOVLB 0x3
14C4  0265     SUBWF USBDeviceState, W
14C5  1C03     BTFSS 0x183, 0x0
14C6  0008     RETURN
14C7  003D     MOVLB 0x1D
14C8  188E     BTFSC UCON, 0x1
14C9  0008     RETURN
105:               {
106:                   return;
107:               }
108:           
109:               
110:               
111:                   
112:              
113:                 
114:               /* Make sure that the CDC driver is ready for a transmission.
115:               
116:               if(mUSBUSARTIsTxTrfReady() == true)
117:               {
118:                   putrsUSBUSART(buttonMessage);
119:           
120:               }*/
121:                   
122:           
123:               /* Check to see if there is a transmission in progress, if there isn't, then
124:                * we can see about performing an echo response to data received.
125:                */
126:               if( USBUSARTIsTxTrfReady() == true)
14CA  0023     MOVLB 0x3
14CB  0869     MOVF cdc_trf_state, W
14CC  1D03     BTFSS 0x183, 0x2
14CD  2D14     GOTO 0x514
127:               {
128:                   uint8_t i;
129:                   uint8_t numBytesRead;
130:           
131:                   numBytesRead = getsUSBUSART(readBuffer, sizeof(readBuffer));
14CE  3040     MOVLW 0x40
14CF  0021     MOVLB 0x1
14D0  00B5     MOVWF 0xB5
14D1  0835     MOVF 0xB5, W
14D2  00B1     MOVWF len
14D3  30A0     MOVLW 0xA0
14D4  3196     MOVLP 0x16
14D5  2684     CALL 0x684
14D6  3194     MOVLP 0x14
14D7  0021     MOVLB 0x1
14D8  00B6     MOVWF pdata
14D9  0836     MOVF pdata, W
14DA  00B7     MOVWF numBytesRead
132:           
133:                   /* For every byte that was read... */
134:                   for(i=0; i<numBytesRead; i++)
14DB  01B8     CLRF size
14DC  2CF7     GOTO 0x4F7
14F3  3001     MOVLW 0x1
14F4  00B5     MOVWF 0xB5
14F5  0835     MOVF 0xB5, W
14F6  07B8     ADDWF size, F
14F7  0837     MOVF numBytesRead, W
14F8  0238     SUBWF size, W
14F9  1803     BTFSC 0x83, 0x0
14FA  2D09     GOTO 0x509
1508  2CF3     GOTO 0x4F3
135:                   {
136:                       switch(readBuffer[i])
14FB  0838     MOVF size, W
14FC  3EA0     ADDLW 0xA0
14FD  0086     MOVWF 0x86
14FE  3002     MOVLW 0x2
14FF  0087     MOVWF 0x87
1500  0801     MOVF 0x81, W
1501  3A0A     XORLW 0xA
1502  1903     BTFSC 0x83, 0x2
1503  2CDD     GOTO 0x4DD
1504  3A07     XORLW 0x7
1505  1903     BTFSC 0x83, 0x2
1506  2CDD     GOTO 0x4DD
1507  2CE4     GOTO 0x4E4
137:                       {
138:                           /* If we receive new line or line feed commands, just echo
139:                            * them direct.
140:                            */
141:                           case 0x0A:
142:                           case 0x0D:
143:                               writeBuffer[i] = readBuffer[i];
14DD  0838     MOVF size, W
14DE  3EA0     ADDLW 0xA0
14DF  0086     MOVWF 0x86
14E0  3002     MOVLW 0x2
14E1  0087     MOVWF 0x87
14E2  0801     MOVF 0x81, W
14E3  2CEB     GOTO 0x4EB
144:                               break;
145:           
146:                           /* If we receive something else, then echo it plus one
147:                            * so that if we receive 'a', we echo 'b' so that the
148:                            * user knows that it isn't the echo enabled on their
149:                            * terminal program.
150:                            */
151:                           default:
152:                               writeBuffer[i] = readBuffer[i] + 1;
14E4  0838     MOVF size, W
14E5  3EA0     ADDLW 0xA0
14E6  0086     MOVWF 0x86
14E7  3002     MOVLW 0x2
14E8  0087     MOVWF 0x87
14E9  0801     MOVF 0x81, W
14EA  3E01     ADDLW 0x1
14EB  00B5     MOVWF 0xB5
14EC  0838     MOVF size, W
14ED  3E20     ADDLW 0x20
14EE  0086     MOVWF 0x86
14EF  3003     MOVLW 0x3
14F0  0087     MOVWF 0x87
14F1  0835     MOVF 0xB5, W
14F2  0081     MOVWF 0x81
153:                               break;
154:                       }
155:                   }
156:           
157:                   if(numBytesRead > 0)
1509  0837     MOVF numBytesRead, W
150A  1903     BTFSC 0x83, 0x2
150B  2D14     GOTO 0x514
158:                   {
159:                       /* After processing all of the received data, we need to send out
160:                        * the "echo" data now.
161:                        */
162:                       putUSBUSART(writeBuffer,numBytesRead);
150C  0837     MOVF numBytesRead, W
150D  00B5     MOVWF 0xB5
150E  0835     MOVF 0xB5, W
150F  00A6     MOVWF length
1510  3020     MOVLW 0x20
1511  3190     MOVLP 0x10
1512  20C6     CALL 0xC6
1513  3194     MOVLP 0x14
163:                   }
164:               }
165:           
166:               CDCTxService();
1514  3184     MOVLP 0x4
1515  2496     CALL 0x496
167:           }
1516  0008     RETURN
168:           
169:           /**
170:            End of File
171:           */
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/common/memset.c  --------------------------------
1:             #include	<string.h>
2:             
3:             #ifdef _PIC16
4:             far void *
5:             memset(far void * p1, int c, register size_t n)
6:             #else /*  _PIC16 */
7:             void *
8:             memset(void * p1, int c, register size_t n)
9:             #endif /* _PIC16 */
10:            {
11:            
12:            #ifdef _PIC16
13:            	register far char *	p;
14:            #else /*  _PIC16 */
15:            	register char *		p;
16:            #endif /* _PIC16 */
17:            
18:            	p = p1;
107D  0871     MOVF 0xF1, W
10AD  0021     MOVLB 0x1
10AE  0827     MOVF p, W
10AF  00AD     MOVWF options
10B0  0826     MOVF length, W
10B1  00AC     MOVWF handle
19:            	while(n--)
1081  3001     MOVLW 0x1
1082  02F4     SUBWF 0xF4, F
1083  3000     MOVLW 0x0
1084  3BF5     SUBWFB 0xF5, F
1085  0A74     INCF 0xF4, W
1086  1903     BTFSC 0x83, 0x2
1087  0A75     INCF 0xF5, W
1088  1903     BTFSC 0x83, 0x2
1089  0008     RETURN
1094  2881     GOTO 0x81
10B2  3001     MOVLW 0x1
10B3  02AA     SUBWF i, F
10B4  3000     MOVLW 0x0
10B5  3BAB     SUBWFB EPNum, F
10B6  0A2A     INCF i, W
10B7  1903     BTFSC 0x83, 0x2
10B8  0A2B     INCF EPNum, W
10B9  1903     BTFSC 0x83, 0x2
10BA  0008     RETURN
10C5  28B2     GOTO 0xB2
20:            		*p++ = c;
108A  0876     MOVF 0xF6, W
108B  0086     MOVWF 0x86
108C  0877     MOVF 0xF7, W
108D  0087     MOVWF 0x87
108E  0872     MOVF 0xF2, W
108F  0081     MOVWF 0x81
1090  3001     MOVLW 0x1
1091  07F6     ADDWF 0xF6, F
1092  3000     MOVLW 0x0
1093  3DF7     ADDWFC 0xF7, F
10BB  082C     MOVF handle, W
10BC  0086     MOVWF 0x86
10BD  082D     MOVF options, W
10BE  0087     MOVWF 0x87
10BF  0828     MOVF data, W
10C0  0081     MOVWF 0x81
10C1  3001     MOVLW 0x1
10C2  07AC     ADDWF handle, F
10C3  3000     MOVLW 0x0
10C4  3DAD     ADDWFC options, F
10C5  28B2     GOTO 0xB2
21:            	return p1;
22:            }
